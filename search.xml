<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2023/08/14/Topological-sort/"/>
      <url>/2023/08/14/Topological-sort/</url>
      
        <content type="html"><![CDATA[<blockquote><p>💡 <strong>拓扑排序思想：有向无环图（DAG图）</strong></p></blockquote><h2 id="1-拓扑排序算法思想："><a href="#1-拓扑排序算法思想：" class="headerlink" title="1. 拓扑排序算法思想："></a>1. 拓扑排序算法思想：</h2><p><strong>拓扑排序</strong>是指将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。利用拓扑排序可以将事件按照顺序排序后进行处理，可以确定事件发生的先后顺序。我们把入度为 0 的那些顶点放入 queue 中，然后通过每次执行 queue 中的顶点，就可以让依赖这个被执行的顶点的那些点的 入度-1，如果有顶点的入度变成了 0，就可以放入 queue 了，直到 queue 为空。</p><img src="/2023/08/14/Topological-sort/1.png" class=""><blockquote><p>拓扑排序必须为有向无环图</p></blockquote><p><strong>拓扑排序中存在度</strong></p><ul><li>例如<strong>3</strong>的<strong>入度（既指向3的边的个数）\</strong>是*<em>2<strong>，</strong>出度（从3指出的边的个数）*<em>是**1</em></em></li></ul><h2 id="2-拓扑排序算法实现方式："><a href="#2-拓扑排序算法实现方式：" class="headerlink" title="2. 拓扑排序算法实现方式："></a>2. 拓扑排序算法实现方式：</h2><ul><li>把入度为0的点放入一个queue中， 然后就需要把某些点拿出去执行了，把 C1 拿出来执行，那这意味「以 C1 为顶点」的「指向其他点」的「边」都消失了，也就是 C1 的出度变成了 0.</li></ul><img src="/2023/08/14/Topological-sort/2.png" class=""><p>此时我们更新了C3和C8点的入度：（此时队列中的数为C2，C8）</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">c3</th><th>c4</th><th>c5</th><th>c6</th><th>c7</th><th>c8</th><th>c9</th></tr></thead><tbody><tr><td>入度</td><td style="text-align:center">1</td><td>2</td><td>1</td><td>2</td><td>2</td><td>0</td><td>1</td></tr></tbody></table></div><ul><li>下一个我们再执行 C2，C2 所指向的 C3, C5 的 入度就要减一</li></ul><img src="/2023/08/14/Topological-sort/3.png" class=""><p>更新表格：（此时队列中的数为C8，C3, C5）</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">c3</th><th>c4</th><th>c5</th><th>c6</th><th>c7</th><th>c9</th></tr></thead><tbody><tr><td>入度</td><td style="text-align:center">0</td><td>2</td><td>0</td><td>2</td><td>2</td><td>1</td></tr></tbody></table></div><ul><li>如此继续执行，直到queue为空即可</li></ul><h2 id="3-拓扑排序代码模板："><a href="#3-拓扑排序代码模板：" class="headerlink" title="3. 拓扑排序代码模板："></a>3. 拓扑排序代码模板：</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">拓扑排序 —— 模板题 AcWing <span class="token number">848.</span> 有向图的拓扑序列时间复杂度 <span class="token function">O</span><span class="token punctuation">(</span>n<span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token function">O</span><span class="token punctuation">(</span>n<span class="token operator">+</span>m<span class="token punctuation">)</span><span class="token punctuation">,</span> nn 表示点数，mm 表示边数<span class="token keyword">bool</span> <span class="token function">topsort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// d[i] 存储点i的入度</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">[</span>hh <span class="token operator">++</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span> d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span>    <span class="token keyword">return</span> tt <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/08/14/sort/"/>
      <url>/2023/08/14/sort/</url>
      
        <content type="html"><![CDATA[<h2 id="1-快速排序-Quick-sort"><a href="#1-快速排序-Quick-sort" class="headerlink" title="1.快速排序(Quick sort)"></a>1.快速排序(Quick sort)</h2><blockquote><p>💡 时间复杂度：$N*log N$</p></blockquote><h3 id="a-快速排序算法实现方式"><a href="#a-快速排序算法实现方式" class="headerlink" title="(a)快速排序算法实现方式:"></a>(a)快速排序算法实现方式:</h3><blockquote><p>快速排序的核心思想是分治法，分而治之。它的实现方式是每次从序列中选出一个基准值，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边，然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动，重复步骤，直到最后都变成单个元素，整个数组就成了有序的序列。</p></blockquote><img src="/2023/08/14/sort/1.gif" class="" title="This is an quick_sort image"><h3 id="b-算法描述"><a href="#b-算法描述" class="headerlink" title="(b)算法描述:"></a>(b)算法描述:</h3><p>&#x3D;&#x3D;快速排序是使用分治的方法将一个串分为两个子串，然后递归的方法继续划分，具体算法描述如下：&#x3D;&#x3D;</p><ul><li>定义两个指针L和R分别指向序列的两端。</li><li>从序列中挑选一个指针元素P，称为 “基准”（pivot）</li><li>一般选 P &#x3D; ( L + R ) &#x2F; 2</li><li>分区操作：重新排序序列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。<br>&#x3D;&#x3D;[ 比基准值小的数] 基准值P [ 比基准值大的数]&#x3D;&#x3D;</li><li>接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时（递归排序左右两边“[ ]”中的子序列）同样也会使用快速排序。</li></ul><h3 id="c-快速排序代码模板："><a href="#c-快速排序代码模板：" class="headerlink" title="(c)快速排序代码模板："></a>(c)快速排序代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;快速排序模板void quick_sort(int q[], int l, int r)&#123;if(l &gt;&#x3D; r) return;&#x2F;&#x2F;如果l &gt;&#x3D; r则数列只有一个数或数列为空int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[(l + r) &gt;&gt; 1];&#x2F;&#x2F;定义双指针，i指向左端，j指向右端，x为数列的基准值while(i &lt; j)&#123;&#x2F;&#x2F;将小于x的数放在x的左边，大于x的数放在x的右边do i++ ;while(q[i] &lt; x);do j-- ;while(q[j] &gt; x);if(i &lt; j) swap(q[i], q[j]);&#125;quick_sort(q, l, j);&#x2F;&#x2F;递归左边quick_sort(q, j + 1, r);&#x2F;&#x2F;递归右边&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-归并排序-Merge-sort"><a href="#2-归并排序-Merge-sort" class="headerlink" title="2.归并排序(Merge sort)"></a>2.归并排序(Merge sort)</h2><blockquote><p>💡 时间复杂度：$N* log N$</p></blockquote><h3 id="a-快速排序算法实现方式-1"><a href="#a-快速排序算法实现方式-1" class="headerlink" title="(a)快速排序算法实现方式:"></a>(a)快速排序算法实现方式:</h3><blockquote><p>归并排序(Merge sort)是建立在归并操作上的一种有效的排序算法，归并排序对序列的元素进行逐层折半分组，然后从最小分组开始比较排序，合并成一个大的分组，逐层进行，最终所有的元素都是有序的</p></blockquote><img src="/2023/08/14/sort/2.gif" class="" title="This is an merge_sort image"><h3 id="b-算法描述-1"><a href="#b-算法描述-1" class="headerlink" title="(b)算法描述:"></a>(b)算法描述:</h3><ul><li>定义三个指针 L， R， mid， 分别指向序列的左右两端和中间。</li><li>首先找到序列的中间值mid &#x3D;（ L + R） &#x2F; 2，将序列分为两个子序列。</li><li>对左序列（ L — mid）和右序列 （ mid + 1— R ）递归将序列划分成若干个子序列。</li><li>然后从下往上逐层合并，首先对第一层序列的数字进行排序合并，然后再依次排序合并各层。</li></ul><h3 id="c-归并排序代码模板："><a href="#c-归并排序代码模板：" class="headerlink" title="(c)归并排序代码模板："></a>(c)归并排序代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void merge_sort(int q[], int l, int r)    &#123;if (l &gt;&#x3D; r) return;&#x2F;&#x2F;将一整个数列拆分成若干个数int mid &#x3D; l + r &gt;&gt; 1;merge_sort(q, l, mid);merge_sort(q, mid + 1, r);&#x2F;&#x2F;合并int k &#x3D; 0, i &#x3D; l, j &#x3D; mid + 1;&#x2F;&#x2F;***while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r)&#x2F;&#x2F;比较两个数，将较小的数存入tmp[]数组中    if (q[i] &lt;&#x3D; q[j]) tmp[k ++ ] &#x3D; q[i ++ ];    else tmp[k ++ ] &#x3D; q[j ++ ];&#x2F;&#x2F;将比较厚剩余的数加到数组的后面while (i &lt;&#x3D; mid) tmp[k ++ ] &#x3D; q[i ++ ];while (j &lt;&#x3D; r) tmp[k ++ ] &#x3D; q[j ++ ];&#x2F;&#x2F;将tmp[]数组中的值搬回q[]数组中for (i &#x3D; l, j &#x3D; 0; i &lt;&#x3D; r; i ++, j ++ ) q[i] &#x3D; tmp[j];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2023/08/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/08/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><blockquote><p>类是对事物的一种描述，对象则为具体存在的事物</p></blockquote><h3 id="1-1-类的定义"><a href="#1-1-类的定义" class="headerlink" title="1.1 类的定义"></a>1.1 类的定义</h3><p>类的组成是由属性和行为两部分组成</p><ul><li>属性：在类中通过成员变量来体现（类中方法外的变量）</li><li>行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</li></ul><p>类的定义步骤：</p><ol><li><p>定义类</p></li><li><p>编写类的成员变量</p></li><li><p>编写类的成员方法</p></li></ol><ul><li>类包含属性和方法（使用class关键字定义）</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">class className &#123;    属性；    方法；  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>类可以分为类名和类体</li></ul><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 定义了一个Person的类public class Person &#123;  private int age; &#x2F;&#x2F; 全局变量  private String name;  &#x2F;&#x2F; 定义了一个say的方法  public void say() &#123;    System.out.println(&quot;定义方法&quot;);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-对象创建和使用"><a href="#1-2-对象创建和使用" class="headerlink" title="1.2 对象创建和使用"></a>1.2 对象创建和使用</h3><p>创建对象格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">类名 对象名 &#x3D; new 类名();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用成员的格式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">对象名.成员变量对象名.成员方法();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>类名的首字母大写</p></li><li><p>变量名和方法名的首字母小写</p></li></ul><p>示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    创建对象        格式：类名 对象名 &#x3D; new 类名();        范例：Phone p &#x3D; new Phone();    使用对象        1：使用成员变量            格式：对象名.变量名            范例：p.brand        2：使用成员方法            格式：对象名.方法名()            范例：p.call() *&#x2F;public class PhoneDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建对象        Phone p &#x3D; new Phone();        &#x2F;&#x2F;使用成员变量        System.out.println(p.brand);        System.out.println(p.price);        p.brand &#x3D; &quot;小米&quot;;        p.price &#x3D; 2999;        System.out.println(p.brand);        System.out.println(p.price);        &#x2F;&#x2F;使用成员方法        p.call();        p.sendMessage();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-对象的内存图"><a href="#1-3-对象的内存图" class="headerlink" title="1.3 对象的内存图"></a>1.3 对象的内存图</h3><h4 id="1-3-1-单个对象内存图"><a href="#1-3-1-单个对象内存图" class="headerlink" title="1.3.1 单个对象内存图"></a>1.3.1 单个对象内存图</h4><ul><li>成员变量使用过程</li></ul><p><img src="E:\桌面\itheima\day08-面向对象\笔记\images\1.png" alt="1"></p><ul><li>成员方法调用过程</li></ul><p><img src="E:\桌面\itheima\day08-面向对象\笔记\images\2.png" alt="2"></p><h4 id="1-3-2-多个对象内存图"><a href="#1-3-2-多个对象内存图" class="headerlink" title="1.3.2 多个对象内存图"></a>1.3.2 多个对象内存图</h4><ul><li>成员变量使用过程</li></ul><p><img src="E:\桌面\itheima\day08-面向对象\笔记\images\3.png" alt="3"></p><ul><li>成员方法调用过程</li></ul><p><img src="E:\桌面\itheima\day08-面向对象\笔记\images\4.png" alt="4"></p><ul><li><p>总结：</p><p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</p></li></ul><h3 id="1-4-成员变量和局部变量"><a href="#1-4-成员变量和局部变量" class="headerlink" title="1.4 成员变量和局部变量"></a>1.4 成员变量和局部变量</h3><h4 id="1-4-1变量的分类"><a href="#1-4-1变量的分类" class="headerlink" title="1.4.1变量的分类"></a>1.4.1变量的分类</h4><ul><li>局部变量</li><li>成员变量（全局变量）</li><li>类变量（用static修饰的变量）</li><li>实例变量（没有static修饰的变量）</li></ul><blockquote><p>类变量：用关键字static定义，调用时使用 <strong>类名.变量名</strong> 访问</p></blockquote><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class one &#123;    static int age &#x3D; 18; &#x2F;&#x2F; 静态变量    public static void main(String[] args) &#123;        System.out.println(one.age);    &#125;&#125;&#x2F;&#x2F; 输出结果为： 18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>实例变量：与类的实例对应。当实例被创建时，分配内存空间；当实例销毁时，内存空间回收。</p></blockquote><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">  public class Student &#123;    public static int amount &#x3D; 10;&#x2F;&#x2F;静态        public int age &#x3D; 24;&#x2F;&#x2F;实例&#125;public class Student &#123;    public static int a &#x3D; 20; &#x2F;&#x2F; 静态变量    &#x2F;&#x2F;public int age &#x3D; 22； &#x2F;&#x2F; 实例变量  &#x2F;&#x2F; 定义的一个方法    public void get_stu() &#123;        int a &#x3D; 18;        System.out.println(&quot;我现在的年龄为&quot; + a);    &#125; &#x2F;&#x2F; 主方法    public static void main(String[] args) &#123;        Student gn &#x3D; new Student();  &#x2F;&#x2F; 这里要new一个对象gn来接受值        gn.get_stu();    &#125;&#125;&#x2F;&#x2F; &gt;&gt; 我现在的年龄为18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.pragect;public class two &#123;    private static int sid &#x3D; 0;    private String name;    int id;    two(String name) &#123;        id &#x3D; sid ++;        this.name &#x3D; &quot;hhh&quot;;    &#125;    public void inof() &#123;        System.out.println(&quot;My name is &quot; + name + &quot;, Num is :&quot; + id );    &#125;    public static void main(String[] args) &#123;        two.sid &#x3D; 30;        two mm &#x3D; new two(&quot;mm&quot;);        two pp &#x3D; new two(&quot;pp&quot;);        mm.inof();        pp.inof();    &#125;&#125;&#x2F;&#x2F; &gt;&gt; My name is hhh, Num is :30&#x2F;&#x2F; &gt;&gt; My name is hhh, Num is :31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-2-成员变量和局部变量的区别"><a href="#1-4-2-成员变量和局部变量的区别" class="headerlink" title="1.4.2 成员变量和局部变量的区别"></a>1.4.2 成员变量和局部变量的区别</h4><ul><li>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</li><li>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</li><li>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）</li><li>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</li></ul><h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2. 面向对象"></a>2. 面向对象</h2><blockquote><p> 20世纪80年底后期，人们提出了面向对象(Object Oriented Programming，OOP)的设计思路。面向对象的程序是由对象组成的，每个对象含有对用户公开的部分和私有的隐藏部分，将数据和处理数据的方法结合起来，形成类；再将类实例化，形成对象。面向对象不需要程序员考虑数据结构和函数功能，只关注对象。</p></blockquote><p><strong>面向过程：</strong></p><ul><li>将事物的发展划分为若干个块，以函数实现，最后将这些块进行调用和连接。</li><li>缺点：当客户需求不断增加，软件规模越来越大，开发周期长，难以维护。</li></ul><h3 id="2-1-面向对象的基本特征"><a href="#2-1-面向对象的基本特征" class="headerlink" title="2.1 面向对象的基本特征"></a>2.1 面向对象的基本特征</h3><ul><li>封装性</li></ul><p>把对象的全部属性和方法结合在一起，形成不可分割的整体，当与外部发生作用时，依靠接口实现</p><ul><li>继承性</li></ul><p>特殊类可以拥有一般类的属性和方法，称为继承。被继承的类称为父类，继承的类称为子类</p><ul><li>多态性</li></ul><p>父类的属性和方法被继承后，可以有不同的表现形式</p><h2 id="3-This关键字"><a href="#3-This关键字" class="headerlink" title="3. This关键字"></a>3. This关键字</h2><p>this关键字是java中的一个关键字，表示某个对象（不可以出现在类方法中）</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package com.pragect;public class three &#123;        int leg, hand;        String name;       &#x2F;&#x2F; this关键字在类中的用法（我认为相当于C语言中的结构体）        three (String s) &#123;            this.name &#x3D; s;            this.init();        &#125;        public void init() &#123;            leg &#x3D; 2;            hand &#x3D; 2;            System.out.println(&quot;我的名字叫&quot; + name + &quot;, 我有&quot; + hand + &quot;只手, &quot; + leg + &quot;只脚&quot;);        &#125;    public static void main(String[] args) &#123;        new three(&quot;Tom&quot;);    &#125;&#125; &#x2F;&#x2F; &gt;&gt; 我的名字叫Tom, 我有2只手, 2只脚package com.pragect;public class Student &#123;    static String words &#x3D; &quot; ##全局变量## &quot;;    public void getStu() &#123;        String words &#x3D; &quot; **局部变量** &quot;;        System.out.println(&quot;words的局部变量是&quot; + words);        System.out.println(&quot;访问的全局变量是&quot; + this.words);    &#125;    public static void main(String[] args) &#123;        Student stu &#x3D; new Student();        stu.getStu();    &#125;&#125;&#x2F;&#x2F; &gt;&gt; words的局部变量是 **局部变量** &#x2F;&#x2F; &gt;&gt; 访问的全局变量是 ##全局变量## <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-package"><a href="#4-package" class="headerlink" title="4. package"></a>4. package</h2><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">package语句作为Java源文件的第一条语句，为该源文件中声明的类指定包名。通过关键字package声明包语句。package语句的一般格式为：package 包名;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>import语句</strong></li></ul><p><strong>一个类可能需要另一个类声明的对象作为自己的成员或方法中的局部变量</strong>，如果这两个类在同一个包中，当然没有问题如果一个类想要使用的那个类和它不在一个包中，要使用<strong>import语句</strong>完成使命。引入的包，可以是系统自带的，也可以是自定义的。</p><ul><li><strong>public修饰符</strong></li></ul><p>•用public修饰的变量和方法称为“共有变量”和“共有方法”，当我们在任何一个类中创建一个对象后，该对象可以访问自己的public变量和类中的public方法，也可以通过继承的方式来操作成员变量和方法．</p><ul><li><strong>private修饰符</strong></li></ul><p>用关键字private修饰的变量或方法称为“私有变量”或“私有方法”，只在本类中起作用，在其他类中无法正常识别.</p><ul><li><strong>protected修饰符</strong></li></ul><p>们定义一个父类，其中有protected类型的变量或方法，此时我们又定义了一个子类，不管父类和子类是否在同一个包中，子类对象可以任意调用父类中的protected类型的内容。</p><ul><li><strong>default修饰符</strong></li></ul><p>default类型称为友好的，也称为默认的，就是变量的数据类型前面什么修饰符都不添加．有以下特性。如果我们定义一个父类，其中有default类型的变量或方法，此时我们又定义了一个子类，则只有当父类和子类在同一个包中，子类对象才可以访问父类中的default变量。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/08/01/git/"/>
      <url>/2023/08/01/git/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-Git概述"><a href="#第一章-Git概述" class="headerlink" title="第一章 Git概述"></a>第一章 Git概述</h2><p>Git是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。<br>Git 易于学习，占地面积小，性能极快。它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于Subversion、CVS、Perforce和 ClearCase等版本控制工具</p><h3 id="1-1版本控制"><a href="#1-1版本控制" class="headerlink" title="1.1版本控制"></a>1.1版本控制</h3><p>版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><img src="/2023/08/01/git/image.png" class=""><h3 id="1-2-为什么需要版本控制"><a href="#1-2-为什么需要版本控制" class="headerlink" title="1.2 为什么需要版本控制"></a>1.2 为什么需要版本控制</h3><p>个人开发过渡到团队协作</p><img src="/2023/08/01/git/image1.png" class=""><h3 id="1-3-版本控制工具"><a href="#1-3-版本控制工具" class="headerlink" title="1.3 版本控制工具"></a>1.3 版本控制工具</h3><p><strong>集中式版本控制工具</strong></p><p><strong>CVS、SVN(Subversion)、VSS….</strong></p><ol><li>集中化的版本控制系统诸如CVS、SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</li><li>这种做法带来了许多好处,每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</li><li>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</li></ol><img src="/2023/08/01/git/image2.png" class=""><p><strong>分布式版本控制工具</strong></p><p><strong>Git、Mercurial、Bazzar、Darcs …..</strong></p><p>像Git这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库)。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都定一次对整个文件仓库的完整备份。</p><p><strong>分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:</strong></p><ol><li><p>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</p></li><li><p>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全)</p></li></ol><img src="/2023/08/01/git/image3.png" class=""><h3 id="1-4-Git发展历史"><a href="#1-4-Git发展历史" class="headerlink" title="1.4 Git发展历史"></a>1.4 Git发展历史</h3><img src="/2023/08/01/git/image4.png" class=""><h3 id="1-5-Git工作机制"><a href="#1-5-Git工作机制" class="headerlink" title="1.5 Git工作机制"></a>1.5 Git工作机制</h3><img src="/2023/08/01/git/image5.png" class=""><ul><li><p>git add (工作区 -&gt; 暂存区)</p></li><li><p>git commit（暂存区 -&gt; 本地库）</p></li></ul><p>本地库代码会形成<strong>历史版本</strong>，<strong>无法删除</strong></p><h3 id="1-6-Git和代码托管中心"><a href="#1-6-Git和代码托管中心" class="headerlink" title="1.6 Git和代码托管中心"></a>1.6 Git和代码托管中心</h3><p>代码托管中心是局域网络服务器的远程代码仓库，一般我们简单称为<strong>远程库</strong>。</p><ul><li><p>局域网（GitLab）</p></li><li><p>互联网（GitHub、Gitee）</p></li></ul><h2 id="第二章-Git安装"><a href="#第二章-Git安装" class="headerlink" title="第二章 Git安装"></a>第二章 Git安装</h2><p>下载地址：<a href="https://git-scm.com/">https://git-scm.com</a></p><h2 id="第三章-Git常用命令"><a href="#第三章-Git常用命令" class="headerlink" title="第三章 Git常用命令"></a>第三章 Git常用命令</h2><img src="/2023/08/01/git/image6.png" class=""><h3 id="3-1-设置用户签名"><a href="#3-1-设置用户签名" class="headerlink" title="3.1 设置用户签名"></a>3.1 设置用户签名</h3><img src="/2023/08/01/git/image7.png" class=""><p>签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到,以此确认本次提交是谁做的。<strong>Git首次安装必须设置一下用户签名，否则无法提交代码。</strong></p><img src="/2023/08/01/git/image8.png" class=""><h3 id="3-2-初始化本地库"><a href="#3-2-初始化本地库" class="headerlink" title="3.2 初始化本地库"></a>3.2 初始化本地库</h3><img src="/2023/08/01/git/image9.png" class=""><h3 id="3-3-查看本地库状态"><a href="#3-3-查看本地库状态" class="headerlink" title="3.3 查看本地库状态"></a>3.3 查看本地库状态</h3><img src="/2023/08/01/git/image10.png" class=""><p><strong>查看步骤：</strong></p><ul><li><p>进入编辑模式之前先按<strong>“i”键</strong></p></li><li><p>退出编辑 按 <strong>“Esc”键</strong></p></li><li><p>把光标移动到要复制的行</p></li><li><p><strong>“yy”键</strong> 是复制</p></li><li><p><strong>“p”键</strong> 是粘贴</p></li></ul><p>在Vim编辑器中保存文件，可以按照以下步骤操作：</p><ol><li><p>进入普通模式：按下 <code>Esc</code> 键，确保你处于普通模式下。</p></li><li><p>输入保存命令：在普通模式下，输入 <code>:w</code> 命令，表示保存文件。</p></li><li><p>按下回车键执行命令：按下回车键，Vim将保存当前文件。</p></li></ol><p>另外，如果你想同时保存并退出Vim编辑器，可以使用 <code>:wq</code> 命令。这将保存文件并退出编辑器。</p><img src="/2023/08/01/git/image11.png" class=""><h3 id="3-4-添加暂存区（git-add）"><a href="#3-4-添加暂存区（git-add）" class="headerlink" title="3.4 添加暂存区（git add）"></a>3.4 添加暂存区（git add）</h3><img src="/2023/08/01/git/image12.png" class=""><h3 id="3-5-提交本地库-git-commit"><a href="#3-5-提交本地库-git-commit" class="headerlink" title="3.5 提交本地库(git commit)"></a>3.5 提交本地库(git commit)</h3><img src="/2023/08/01/git/image13.png" class=""><img src="/2023/08/01/git/image14.png" class=""><h3 id="3-6-修改文件"><a href="#3-6-修改文件" class="headerlink" title="3.6 修改文件"></a>3.6 修改文件</h3><img src="/2023/08/01/git/image15.png" class=""><h3 id="3-7-查看历史版本"><a href="#3-7-查看历史版本" class="headerlink" title="3.7 查看历史版本"></a>3.7 查看历史版本</h3><img src="/2023/08/01/git/image16.png" class=""><img src="/2023/08/01/git/image17.png" class=""><img src="/2023/08/01/git/image18.png" class=""><img src="/2023/08/01/git/image19.png" class=""><img src="/2023/08/01/git/image20.png" class=""><img src="/2023/08/01/git/image21.png" class=""><h2 id="第四章-Git分支操作"><a href="#第四章-Git分支操作" class="headerlink" title="第四章 Git分支操作"></a>第四章 Git分支操作</h2><img src="/2023/08/01/git/image22.png" class=""><h3 id="4-1-什么是分支"><a href="#4-1-什么是分支" class="headerlink" title="4.1 什么是分支"></a>4.1 什么是分支</h3><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来,开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。(分支底层其实也是指针的引用)</p><img src="/2023/08/01/git/image23.png" class=""><h3 id="4-2-分支的好处"><a href="#4-2-分支的好处" class="headerlink" title="4.2 分支的好处"></a>4.2 分支的好处</h3><ul><li><p>同时并行推进多个功能开发，提高开发效率。</p></li><li><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p></li></ul><h3 id="4-3-分支的操作"><a href="#4-3-分支的操作" class="headerlink" title="4.3 分支的操作"></a>4.3 分支的操作</h3><img src="/2023/08/01/git/image24.png" class=""><h4 id="4-3-1-查看分支"><a href="#4-3-1-查看分支" class="headerlink" title="4.3.1 查看分支"></a>4.3.1 查看分支</h4><img src="/2023/08/01/git/image25.png" class=""><h4 id="4-3-2-创建分支"><a href="#4-3-2-创建分支" class="headerlink" title="4.3.2 创建分支"></a>4.3.2 创建分支</h4><img src="/2023/08/01/git/image26.png" class=""><h4 id="4-3-3-修改分支"><a href="#4-3-3-修改分支" class="headerlink" title="4.3.3 修改分支"></a>4.3.3 修改分支</h4><img src="/2023/08/01/git/image27.png" class=""><h4 id="4-3-4-切换分支"><a href="#4-3-4-切换分支" class="headerlink" title="4.3.4 切换分支"></a>4.3.4 切换分支</h4><img src="/2023/08/01/git/image28.png" class=""><h4 id="4-3-5-合并分支"><a href="#4-3-5-合并分支" class="headerlink" title="4.3.5 合并分支"></a>4.3.5 合并分支</h4><img src="/2023/08/01/git/image29.png" class=""><h4 id="4-3-6-产生冲突"><a href="#4-3-6-产生冲突" class="headerlink" title="4.3.6 产生冲突"></a>4.3.6 产生冲突</h4><p>冲突产生的原因：合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git我们决定使用哪一个。必须<strong>人为决定</strong>新代码内容。</p><p>查看状态（检测到有文件有两处修改）</p><img src="/2023/08/01/git/image30.png" class=""><img src="/2023/08/01/git/image31.png" class=""><h4 id="4-3-7-解决冲突"><a href="#4-3-7-解决冲突" class="headerlink" title="4.3.7 解决冲突"></a>4.3.7 解决冲突</h4><img src="/2023/08/01/git/image32.png" class=""><img src="/2023/08/01/git/image33.png" class=""><img src="/2023/08/01/git/image34.png" class=""><img src="/2023/08/01/git/image35.png" class=""><h2 id="第五章-Git团队协作机制"><a href="#第五章-Git团队协作机制" class="headerlink" title="第五章 Git团队协作机制"></a>第五章 Git团队协作机制</h2><img src="/2023/08/01/git/image36.png" class=""><img src="/2023/08/01/git/image37.png" class="">]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Java Swing图书管理系统</title>
      <link href="/2023/07/03/bookmanager/"/>
      <url>/2023/07/03/bookmanager/</url>
      
        <content type="html"><![CDATA[<h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h2><h3 id="1-1-项目结构："><a href="#1-1-项目结构：" class="headerlink" title="1.1 项目结构："></a>1.1 项目结构：</h3><ul><li><p>用户注册</p></li><li><p>用户登录</p></li><li><p>用户管理员操作界面</p></li></ul><p><strong>用户</strong></p><img src="/2023/07/03/bookmanager/1.png" class=""><p><strong>管理员</strong></p><img src="/2023/07/03/bookmanager/2.png" class=""><h3 id="1-2-E—R图"><a href="#1-2-E—R图" class="headerlink" title="1.2 E—R图"></a>1.2 E—R图</h3><p><strong>user</strong></p><img src="/2023/07/03/bookmanager/3.png" class=""><p><strong>book</strong></p><img src="/2023/07/03/bookmanager/4.png" class=""><p><strong>book_type</strong></p><img src="/2023/07/03/bookmanager/5.png" class=""><p><strong>borrowdetail</strong></p><img src="/2023/07/03/bookmanager/6.png" class=""><h2 id="2-项目环境搭建"><a href="#2-项目环境搭建" class="headerlink" title="2. 项目环境搭建"></a>2. 项目环境搭建</h2><h3 id="2-1-确定项目开发环境"><a href="#2-1-确定项目开发环境" class="headerlink" title="2.1 确定项目开发环境"></a>2.1 确定项目开发环境</h3><p><strong>操作系统：window 10</strong></p><p><strong>Java开发包：jdk18</strong></p><p><strong>数据库：mysql 8.0(Navicate)</strong></p><p><strong>开发工具：IntelliJ IDEA 2022.2.2</strong></p><h3 id="2-2-创建数据库"><a href="#2-2-创建数据库" class="headerlink" title="2.2 创建数据库"></a>2.2 创建数据库</h3><p>在Navicat中连接MySQL数据库后新建数据库mybookmanager，并在该数据库中建立相应的表</p><h3 id="2-3-引入jar包"><a href="#2-3-引入jar包" class="headerlink" title="2.3 引入jar包"></a>2.3 引入jar包</h3><img src="/2023/07/03/bookmanager/11.png" class=""><h3 id="2-4-创建包目录结构"><a href="#2-4-创建包目录结构" class="headerlink" title="2.4 创建包目录结构"></a>2.4 创建包目录结构</h3><img src="/2023/07/03/bookmanager/12.png" class=""><ul><li>dao包下的java文件为与数据库进行交互的类</li><li>Jframe包下的java文件为UI界面</li><li>model包下的java文件为实体类</li><li>utils包中的类为项目中所用到的工具类</li></ul><h2 id="3-数据库设计"><a href="#3-数据库设计" class="headerlink" title="3. 数据库设计"></a>3. 数据库设计</h2><p><strong>数据库名：mybookmanager</strong></p><p><strong>字符集：utf-8</strong></p><p><strong>端口号：3306</strong></p><p><strong>user</strong></p><img src="/2023/07/03/bookmanager/7.png" class=""><p><strong>book</strong></p><img src="/2023/07/03/bookmanager/8.png" class=""><p><strong>book_type</strong></p><img src="/2023/07/03/bookmanager/9.png" class=""><p><strong>borrowdetail</strong></p><img src="/2023/07/03/bookmanager/10.png" class=""><p><strong>建表以及插入语句</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">&#x2F;* Navicat Premium Data Transfer Source Server         : Java Source Server Type    : MySQL Source Server Version : 80026 (8.0.26) Source Host           : localhost:3306 Source Schema         : bookmanager Target Server Type    : MySQL Target Server Version : 80026 (8.0.26) File Encoding         : 65001 Date: 04&#x2F;07&#x2F;2023 12:34:07*&#x2F;SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS &#x3D; 0;-- ------------------------------ Table structure for book-- ----------------------------DROP TABLE IF EXISTS &#96;book&#96;;CREATE TABLE &#96;book&#96;  (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;book_name&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;tyPE_id&#96; int NULL DEFAULT NULL,  &#96;author&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;publish&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;PRice&#96; double(10, 2) NULL DEFAULT NULL,  &#96;number&#96; int NULL DEFAULT NULL,  &#96;status&#96; int NULL DEFAULT 1 COMMENT &#39;状态 1上架0下架&#39;,  &#96;remark&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;) USING BTREE) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 17 CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; COMPACT;-- ------------------------------ Records of book-- ----------------------------INSERT INTO &#96;book&#96; VALUES (1, &#39;Java核心技术&#39;, 1, &#39;霍斯特曼&#39;, &#39;人民邮电出版社&#39;, 69.00, 16, 1, &#39;Java基础教学&#39;);INSERT INTO &#96;book&#96; VALUES (2, &#39;Tomcat与Java web&#39;, 1, &#39;孙卫琴&#39;, &#39;人民邮电出版社&#39;, 119.00, 16, 1, &#39;javaweb教学&#39;);INSERT INTO &#96;book&#96; VALUES (3, &#39;;mySQL基础教程&#39;, 1, &#39;西泽梦路&#39;, &#39;人民邮电出版社&#39;, 129.00, 16, 1, &#39;MySQL基础教学&#39;);INSERT INTO &#96;book&#96; VALUES (4, &#39;西游记&#39;, 3, &#39;吴承恩&#39;, &#39;机械工业出版社&#39;, 23.00, 213, 1, &#39;四大名著之一&#39;);INSERT INTO &#96;book&#96; VALUES (6, &#39;SpringCloud微服务架构开发&#39;, 1, &#39;黑马程序员&#39;, &#39;人民邮电出版社&#39;, 28.00, 20, 1, &#39;微服务实战开发&#39;);INSERT INTO &#96;book&#96; VALUES (7, &#39;水浒传&#39;, 3, &#39;施耐庵 &#39;, &#39;人民文学出版社&#39;, 29.00, 30, 1, &#39;四大名著之一&#39;);INSERT INTO &#96;book&#96; VALUES (16, &#39;jspringboot&#39;, 4, &#39;cc&#39;, &#39;xx&#39;, 5.20, 1000, 1, &#39;springboot&#39;);-- ------------------------------ Table structure for book_type-- ----------------------------DROP TABLE IF EXISTS &#96;book_type&#96;;CREATE TABLE &#96;book_type&#96;  (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;type_name&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;remark&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;) USING BTREE) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 5 CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; COMPACT;-- ------------------------------ Records of book_type-- ----------------------------INSERT INTO &#96;book_type&#96; VALUES (1, &#39;技术&#39;, &#39;技术hhh&#39;);INSERT INTO &#96;book_type&#96; VALUES (2, &#39;人文&#39;, &#39;人文类&#39;);INSERT INTO &#96;book_type&#96; VALUES (3, &#39;小说&#39;, &#39;人生情感小说&#39;);INSERT INTO &#96;book_type&#96; VALUES (4, &#39;科技类&#39;, &#39;科技类&#39;);-- ------------------------------ Table structure for borrowdetail-- ----------------------------DROP TABLE IF EXISTS &#96;borrowdetail&#96;;CREATE TABLE &#96;borrowdetail&#96;  (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;user_id&#96; int NOT NULL,  &#96;book_id&#96; int NOT NULL,  &#96;status&#96; int NOT NULL COMMENT &#39;状态  1在借2已还&#39;,  &#96;borrow_time&#96; bigint NULL DEFAULT NULL,  &#96;return_time&#96; bigint NULL DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;) USING BTREE) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 30 CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; COMPACT;-- ------------------------------ Records of borrowdetail-- ----------------------------INSERT INTO &#96;borrowdetail&#96; VALUES (1, 1, 2, 2, 1546414916391, 1546414948498);INSERT INTO &#96;borrowdetail&#96; VALUES (2, 1, 3, 2, 1546414932877, 1556417443285);INSERT INTO &#96;borrowdetail&#96; VALUES (3, 1, 2, 2, 1546416530026, 1546416640210);INSERT INTO &#96;borrowdetail&#96; VALUES (4, 1, 1, 2, 1546565100120, 1556334334816);INSERT INTO &#96;borrowdetail&#96; VALUES (5, 1, 4, 2, 1546565102870, 1688392384101);INSERT INTO &#96;borrowdetail&#96; VALUES (6, 3, 1, 2, 1546565519776, 1556207839074);INSERT INTO &#96;borrowdetail&#96; VALUES (7, 3, 4, 1, 1546565522374, NULL);INSERT INTO &#96;borrowdetail&#96; VALUES (8, 1, 1, 2, 1556427836809, 1688392380686);INSERT INTO &#96;borrowdetail&#96; VALUES (9, 4, 3, 1, 1556433544156, NULL);INSERT INTO &#96;borrowdetail&#96; VALUES (10, 7, 5, 1, 1556503388763, NULL);INSERT INTO &#96;borrowdetail&#96; VALUES (11, 8, 5, 2, 1556507260569, 1556507349243);INSERT INTO &#96;borrowdetail&#96; VALUES (27, 1, 6, 1, 1688389422921, NULL);INSERT INTO &#96;borrowdetail&#96; VALUES (28, 1, 4, 1, 1688429793391, NULL);INSERT INTO &#96;borrowdetail&#96; VALUES (29, 1, 2, 1, 1688445082661, NULL);-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS &#96;user&#96;;CREATE TABLE &#96;user&#96;  (  &#96;id&#96; int NOT NULL AUTO_INCREMENT,  &#96;username&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;password&#96; varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;role&#96; int NULL DEFAULT NULL COMMENT &#39;角色  1学生 2管理员&#39;,  &#96;sex&#96; varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  &#96;phone&#96; char(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (&#96;id&#96;) USING BTREE) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 17 CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; COMPACT;-- ------------------------------ Records of user-- ----------------------------INSERT INTO &#96;user&#96; VALUES (1, &#39;xx&#39;, &#39;111111&#39;, 1, &#39;男&#39;, &#39;13195648799&#39;);INSERT INTO &#96;user&#96; VALUES (2, &#39;admin&#39;, &#39;111111&#39;, 2, &#39;男&#39;, &#39;13198645975&#39;);INSERT INTO &#96;user&#96; VALUES (3, &#39;徐某人&#39;, &#39;xkj123&#39;, 1, &#39;女&#39;, &#39;13195648529&#39;);INSERT INTO &#96;user&#96; VALUES (4, &#39;肖淼&#39;, &#39;sDF78978&#39;, 1, &#39;女&#39;, &#39;13195698458&#39;);INSERT INTO &#96;user&#96; VALUES (12, &#39;1111&#39;, &#39;1111yyyy&#39;, 1, &#39;男&#39;, &#39;15076281789&#39;);INSERT INTO &#96;user&#96; VALUES (13, &#39;11&#39;, &#39;15076281789yy&#39;, 1, &#39;男&#39;, &#39;15076281789&#39;);INSERT INTO &#96;user&#96; VALUES (14, &#39;222&#39;, &#39;15076281789yy&#39;, 1, &#39;男&#39;, &#39;15076281789&#39;);INSERT INTO &#96;user&#96; VALUES (15, &#39;xxn&#39;, &#39;12345yyy&#39;, 1, &#39;男&#39;, &#39;15076281789&#39;);INSERT INTO &#96;user&#96; VALUES (16, &#39;xxx&#39;, &#39;12345678yy&#39;, 2, &#39;男&#39;, &#39;15076281789&#39;);SET FOREIGN_KEY_CHECKS &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-实体类设计-model"><a href="#4-实体类设计-model" class="headerlink" title="4. 实体类设计(model)"></a>4. 实体类设计(model)</h2><h3 id="4-1-User"><a href="#4-1-User" class="headerlink" title="4.1 User"></a>4.1 User</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.model;&#x2F;&#x2F; 用户类public class User &#123;private Integer userId;  &#x2F;&#x2F; 用户idprivate String userName; &#x2F;&#x2F; 用户名private String password; &#x2F;&#x2F; 密码private Integer role; &#x2F;&#x2F;用户角色  1普通  2管理员private String sex;&#x2F;&#x2F; 用户性别private String phone;   &#x2F;&#x2F; 用户手机号&#x2F;** * 获取 * @return userId *&#x2F;public Integer getUserId() &#123;return userId;&#125;&#x2F;** * 设置 * @param userId *&#x2F;public void setUserId(Integer userId) &#123;this.userId &#x3D; userId;&#125;&#x2F;** * 获取 * @return userName *&#x2F;public String getUserName() &#123;return userName;&#125;&#x2F;** * 设置 * @param userName *&#x2F;public void setUserName(String userName) &#123;this.userName &#x3D; userName;&#125;&#x2F;** * 获取 * @return password *&#x2F;public String getPassword() &#123;return password;&#125;&#x2F;** * 设置 * @param password *&#x2F;public void setPassword(String password) &#123;this.password &#x3D; password;&#125;&#x2F;** * 获取 * @return role *&#x2F;public Integer getRole() &#123;return role;&#125;&#x2F;** * 设置 * @param role *&#x2F;public void setRole(Integer role) &#123;this.role &#x3D; role;&#125;&#x2F;** * 获取 * @return sex *&#x2F;public String getSex() &#123;return sex;&#125;&#x2F;** * 设置 * @param sex *&#x2F;public void setSex(String sex) &#123;this.sex &#x3D; sex;&#125;&#x2F;** * 获取 * @return phone *&#x2F;public String getPhone() &#123;return phone;&#125;&#x2F;** * 设置 * @param phone *&#x2F;public void setPhone(String phone) &#123;this.phone &#x3D; phone;&#125;public String toString() &#123;return &quot;User&#123;userId &#x3D; &quot; + userId +&quot;, userName &#x3D; &quot; + userName +&quot;, password &#x3D; &quot; + password +&quot;, role &#x3D; &quot; + role +&quot;, sex &#x3D; &quot; + sex +&quot;, phone &#x3D; &quot; + phone +&quot;&#125;&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-Book"><a href="#4-2-Book" class="headerlink" title="4.2 Book"></a>4.2 Book</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.model;&#x2F;&#x2F; 图书类public class Book &#123;private Integer bookId;private String bookName;private String author;private Integer status;&#x2F;&#x2F;状态 1上架  2下架private Integer bookTypeId;private String publish;private Integer number;&#x2F;&#x2F; 库存数量private double price;private String remark;&#x2F;** * 获取 * @return bookId *&#x2F;public Integer getBookId() &#123;return bookId;&#125;&#x2F;** * 设置 * @param bookId *&#x2F;public void setBookId(Integer bookId) &#123;this.bookId &#x3D; bookId;&#125;&#x2F;** * 获取 * @return bookName *&#x2F;public String getBookName() &#123;return bookName;&#125;&#x2F;** * 设置 * @param bookName *&#x2F;public void setBookName(String bookName) &#123;this.bookName &#x3D; bookName;&#125;&#x2F;** * 获取 * @return author *&#x2F;public String getAuthor() &#123;return author;&#125;&#x2F;** * 设置 * @param author *&#x2F;public void setAuthor(String author) &#123;this.author &#x3D; author;&#125;&#x2F;** * 获取 * @return status *&#x2F;public Integer getStatus() &#123;return status;&#125;&#x2F;** * 设置 * @param status *&#x2F;public void setStatus(Integer status) &#123;this.status &#x3D; status;&#125;&#x2F;** * 获取 * @return bookTypeId *&#x2F;public Integer getBookTypeId() &#123;return bookTypeId;&#125;&#x2F;** * 设置 * @param bookTypeId *&#x2F;public void setBookTypeId(Integer bookTypeId) &#123;this.bookTypeId &#x3D; bookTypeId;&#125;&#x2F;** * 获取 * @return publish *&#x2F;public String getPublish() &#123;return publish;&#125;&#x2F;** * 设置 * @param publish *&#x2F;public void setPublish(String publish) &#123;this.publish &#x3D; publish;&#125;&#x2F;** * 获取 * @return number *&#x2F;public Integer getNumber() &#123;return number;&#125;&#x2F;** * 设置 * @param number *&#x2F;public void setNumber(Integer number) &#123;this.number &#x3D; number;&#125;&#x2F;** * 获取 * @return price *&#x2F;public double getPrice() &#123;return price;&#125;&#x2F;** * 设置 * @param price *&#x2F;public void setPrice(double price) &#123;this.price &#x3D; price;&#125;&#x2F;** * 获取 * @return remark *&#x2F;public String getRemark() &#123;return remark;&#125;&#x2F;** * 设置 * @param remark *&#x2F;public void setRemark(String remark) &#123;this.remark &#x3D; remark;&#125;public String toString() &#123;return &quot;Book&#123;bookId &#x3D; &quot; + bookId +&quot;, bookName &#x3D; &quot; + bookName +&quot;, author &#x3D; &quot; + author +&quot;, status &#x3D; &quot; + status +&quot;, bookTypeId &#x3D; &quot; + bookTypeId +&quot;, publish &#x3D; &quot; + publish +&quot;, number &#x3D; &quot; + number +&quot;, price &#x3D; &quot; + price +&quot;, remark &#x3D; &quot; + remark +&quot;&#125;&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-BookType"><a href="#4-3-BookType" class="headerlink" title="4.3 BookType"></a>4.3 BookType</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.model;&#x2F;&#x2F; 图书类型public class BookType &#123;private Integer typeId;private String typeName;private String remark;&#x2F;** * 获取 * @return typeId *&#x2F;public Integer getTypeId() &#123;return typeId;&#125;&#x2F;** * 设置 * @param typeId *&#x2F;public void setTypeId(Integer typeId) &#123;this.typeId &#x3D; typeId;&#125;&#x2F;** * 获取 * @return typeName *&#x2F;public String getTypeName() &#123;return typeName;&#125;&#x2F;** * 设置 * @param typeName *&#x2F;public void setTypeName(String typeName) &#123;this.typeName &#x3D; typeName;&#125;&#x2F;** * 获取 * @return remark *&#x2F;public String getRemark() &#123;return remark;&#125;&#x2F;** * 设置 * @param remark *&#x2F;public void setRemark(String remark) &#123;this.remark &#x3D; remark;&#125;public String toString() &#123;return &quot;BookType&#123;typeId &#x3D; &quot; + typeId +&quot;, typeName &#x3D; &quot; + typeName +&quot;, remark &#x3D; &quot; + remark +&quot;&#125;&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-BorrowDetail"><a href="#4-4-BorrowDetail" class="headerlink" title="4.4 BorrowDetail"></a>4.4 BorrowDetail</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.model;&#x2F;&#x2F; 借阅信息public class BorrowDetail &#123;private Integer borrowId;private Integer userId;private Integer bookId;private Integer status;&#x2F;&#x2F;状态  1在借  2已还private Long borrowTime;private Long returnTime;&#x2F;** * 获取 * @return borrowId *&#x2F;public Integer getBorrowId() &#123;return borrowId;&#125;&#x2F;** * 设置 * @param borrowId *&#x2F;public void setBorrowId(Integer borrowId) &#123;this.borrowId &#x3D; borrowId;&#125;&#x2F;** * 获取 * @return userId *&#x2F;public Integer getUserId() &#123;return userId;&#125;&#x2F;** * 设置 * @param userId *&#x2F;public void setUserId(Integer userId) &#123;this.userId &#x3D; userId;&#125;&#x2F;** * 获取 * @return bookId *&#x2F;public Integer getBookId() &#123;return bookId;&#125;&#x2F;** * 设置 * @param bookId *&#x2F;public void setBookId(Integer bookId) &#123;this.bookId &#x3D; bookId;&#125;&#x2F;** * 获取 * @return status *&#x2F;public Integer getStatus() &#123;return status;&#125;&#x2F;** * 设置 * @param status *&#x2F;public void setStatus(Integer status) &#123;this.status &#x3D; status;&#125;&#x2F;** * 获取 * @return borrowTime *&#x2F;public Long getBorrowTime() &#123;return borrowTime;&#125;&#x2F;** * 设置 * @param borrowTime *&#x2F;public void setBorrowTime(Long borrowTime) &#123;this.borrowTime &#x3D; borrowTime;&#125;&#x2F;** * 获取 * @return returnTime *&#x2F;public Long getReturnTime() &#123;return returnTime;&#125;&#x2F;** * 设置 * @param returnTime *&#x2F;public void setReturnTime(Long returnTime) &#123;this.returnTime &#x3D; returnTime;&#125;public String toString() &#123;return &quot;BorrowDetail&#123;borrowId &#x3D; &quot; + borrowId +&quot;, userId &#x3D; &quot; + userId +&quot;, bookId &#x3D; &quot; + bookId +&quot;, status &#x3D; &quot; + status +&quot;, borrowTime &#x3D; &quot; + borrowTime +&quot;, returnTime &#x3D; &quot; + returnTime +&quot;&#125;&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-工具类设计-utils"><a href="#5-工具类设计-utils" class="headerlink" title="5. 工具类设计(utils)"></a>5. 工具类设计(utils)</h2><h3 id="5-1-DdUtil"><a href="#5-1-DdUtil" class="headerlink" title="5.1 DdUtil"></a>5.1 DdUtil</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.utils;import java.sql.*;public class DbUtil &#123;&#x2F;&#x2F; 定义数据库连接字符串private String Driver &#x3D; &quot;com.mysql.cj.jdbc.Driver&quot;;&#x2F;&#x2F; 数据库驱动private String Url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybookmanager?serverTimezone&#x3D;UTC&amp;useSSL&#x3D;false&quot;;private String UserName &#x3D; &quot;root&quot;;private String Password &#x3D; &quot;******&quot;;&#x2F;&#x2F; 连接数据库public Connection getConnection()throws Exception&#123;    Class.forName(Driver);Connection con &#x3D; (Connection) DriverManager.getConnection(Url,UserName,Password);return con;&#125;&#x2F;&#x2F; 关闭数据库public void closeCon (Connection con)throws Exception &#123;if(con!&#x3D;null)&#123;con.close();&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-ToolUtil"><a href="#5-2-ToolUtil" class="headerlink" title="5.2 ToolUtil"></a>5.2 ToolUtil</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.utils;import java.text.SimpleDateFormat;import java.util.Date;import javax.servlet.http.HttpSession;import com.hechaodong.bookmanager.model.User;public class ToolUtil &#123;&#x2F;&#x2F;判断一个字符串是否为空，如果不为空则返回false，空字符串或者null返回truepublic static boolean isEmpty(String str)&#123;if(str !&#x3D; null &amp;&amp; !&quot;&quot;.equals(str.trim()))&#123;return false;&#125;return true;&#125;&#x2F;&#x2F;获取当前时间的时间戳，以毫秒为单位public static Long getTime()&#123;long time &#x3D; System.currentTimeMillis();return time;&#125;&#x2F;&#x2F;将给定的时间戳转换为对应的日期时间字符串，格式为&quot;yyyy-MM-dd HH:mm:ss&quot;public static String getDateByTime(Long time)&#123;SimpleDateFormat format &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);String string &#x3D; format.format(new Date(time));return string;&#125;&#x2F;&#x2F;从给定的HttpSession对象中获取保存的当前用户对象(User)public static User getUser(HttpSession session)&#123;User user &#x3D; (User) session.getAttribute(&quot;user&quot;);return user;&#125;&#x2F;&#x2F;将给定的当前用户对象(User)存储到HttpSession对象中，以便在会话期间使用public static void setUser(HttpSession session,User user)&#123;session.setAttribute(&quot;user&quot;, user);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-数据库交互类设计-dao"><a href="#6-数据库交互类设计-dao" class="headerlink" title="6. 数据库交互类设计(dao)"></a>6. 数据库交互类设计(dao)</h2><h3 id="6-1-UserDao"><a href="#6-1-UserDao" class="headerlink" title="6.1 UserDao"></a>6.1 UserDao</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.dao;import java.sql.*;import com.hechaodong.bookmanager.model.User;import com.hechaodong.bookmanager.utils.ToolUtil;import java.sql.ResultSet;public class UserDao &#123;public User login(Connection con, User user)throws Exception &#123;&#x2F;&#x2F; 定义一个User类型的变量，用来记录查询的结果User resultUser &#x3D; null;&#x2F;&#x2F; 定义sql语句String sql &#x3D; &quot;select * from user where username&#x3D;? and password&#x3D;? and role &#x3D; ?&quot;;    PreparedStatement preparedStatement &#x3D; (PreparedStatement) con.prepareStatement(sql);preparedStatement.setString(1,user.getUserName());preparedStatement.setString(2,user.getPassword());preparedStatement.setInt(3,user.getRole());&#x2F;&#x2F; 执行查询操作    ResultSet rs &#x3D; preparedStatement.executeQuery();    if(rs.next())&#123;    resultUser &#x3D; new User();    resultUser.setUserId(rs.getInt(&quot;id&quot;));    resultUser.setUserName(rs.getString(&quot;username&quot;));    resultUser.setSex(rs.getString(&quot;sex&quot;));    resultUser.setPhone(rs.getString(&quot;phone&quot;));    &#125;return resultUser;&#125;&#x2F;&#x2F; 添加用户信息public int addUser(Connection con, User user) throws Exception&#123;&#x2F;&#x2F;查询注册用户名是否存在String sql &#x3D; &quot;select * from user where userName&#x3D;? &quot;;    PreparedStatement pstmt &#x3D; (PreparedStatement) con.prepareStatement(sql);pstmt.setString(1,user.getUserName());    ResultSet rs &#x3D; pstmt.executeQuery();    if(rs.next())&#123;    return 2;    &#125;&#x2F;&#x2F; 执行插入操作    String sql2&#x3D;&quot;insert into user (username,password,role,sex,phone) values (?,?,?,?,?)&quot;;    PreparedStatement pstmt2&#x3D;(PreparedStatement) con.prepareStatement(sql2);pstmt2.setString(1, user.getUserName());pstmt2.setString(2, user.getPassword());pstmt2.setInt(3, user.getRole());pstmt2.setString(4,user.getSex());pstmt2.setString(5,user.getPhone());return pstmt2.executeUpdate();&#125;&#x2F;&#x2F; 查询用户信息public ResultSet list(Connection con,User user)throws Exception&#123;StringBuffer sb&#x3D;new StringBuffer(&quot;select * from user where role &#x3D; 1&quot;);if(!ToolUtil.isEmpty(user.getUserName()))&#123;sb.append(&quot; and username like &#39;%&quot;+user.getUserName()+&quot;%&#39;&quot;);&#125;PreparedStatement pstmt&#x3D;(PreparedStatement) con.prepareStatement(sb.toString());return pstmt.executeQuery();&#125;&#x2F;&#x2F; 更新信息public int update(Connection con,User user)throws Exception&#123;String sql&#x3D;&quot;update user set username&#x3D;?,password&#x3D;?,sex&#x3D;?,phone&#x3D;? where id&#x3D;?&quot;;PreparedStatement pstmt&#x3D;(PreparedStatement) con.prepareStatement(sql);pstmt.setString(1, user.getUserName());pstmt.setString(2, user.getPassword());pstmt.setString(3, user.getSex());pstmt.setString(4, user.getPhone());pstmt.setInt(5, user.getUserId());return pstmt.executeUpdate();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-BookDao"><a href="#6-2-BookDao" class="headerlink" title="6.2 BookDao"></a>6.2 BookDao</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.dao;import java.sql.*;import java.sql.ResultSet;import com.hechaodong.bookmanager.model.Book;import com.hechaodong.bookmanager.utils.ToolUtil;&#x2F;&#x2F; 图书信息的增删改查操作public class BookDao &#123;    &#x2F;&#x2F; 图书添加    public int add(Connection con, Book book) throws Exception &#123;        String sql &#x3D; &quot;insert into book (book_name,type_id,author,publish,price,number,status,remark) values(?,?,?,?,?,?,?,?)&quot;;        PreparedStatement preparedStatement &#x3D; (PreparedStatement) con.prepareStatement(sql);        preparedStatement.setString(1, book.getBookName());&#x2F;&#x2F; 以getBookName()第一个参数添加到sql语句的第一个占位符中        preparedStatement.setInt(2, book.getBookTypeId());        preparedStatement.setString(3, book.getAuthor());        preparedStatement.setString(4, book.getPublish());        preparedStatement.setDouble(5, book.getPrice());        preparedStatement.setInt(6, book.getNumber());        preparedStatement.setInt(7, book.getStatus());        preparedStatement.setString(8, book.getRemark());        return preparedStatement.executeUpdate();    &#125;    &#x2F;&#x2F; 查询图书信息    public ResultSet list(Connection con, Book book) throws Exception &#123;        &#x2F;&#x2F; 创建StringBuffer对象，来拼接sql语句        StringBuffer sb &#x3D; new StringBuffer(&quot;select b.*,bt.type_name from book b,book_type bt where b.type_id&#x3D;bt.id&quot;);        if (!ToolUtil.isEmpty(book.getBookName())) &#123;            sb.append(&quot; and b.book_name like &#39;%&quot; + book.getBookName() + &quot;%&#39;&quot;);        &#125;        if (!ToolUtil.isEmpty(book.getAuthor())) &#123;            sb.append(&quot; and b.author like &#39;%&quot; + book.getAuthor() + &quot;%&#39;&quot;);        &#125;        if (book.getBookTypeId() !&#x3D; null &amp;&amp; book.getBookTypeId() !&#x3D; 0) &#123;            sb.append(&quot; and b.type_id&#x3D;&quot; + book.getBookTypeId());        &#125;        if (book.getStatus() !&#x3D; null) &#123;            sb.append(&quot; and b.status&#x3D;&quot; + book.getStatus());        &#125;        if (book.getBookId() !&#x3D; null) &#123;            sb.append(&quot; and b.id&#x3D;&quot; + book.getBookId());        &#125;        sb.append(&quot; ORDER BY b.status&quot;);        PreparedStatement preparedStatement &#x3D; (PreparedStatement) con.prepareStatement(sb.toString());        return preparedStatement.executeQuery();    &#125;    &#x2F;&#x2F; 查询可借阅的图书信息    public ResultSet listCan(Connection con, Book book) throws Exception &#123;        StringBuffer sb &#x3D; new StringBuffer(&quot;select b.*,bt.type_name from book b,book_type bt where type_id&#x3D;bt.id and b.status &#x3D; 1&quot;);        &#x2F;&#x2F; 字符串的拼接查询        if (!ToolUtil.isEmpty(book.getBookName())) &#123;            sb.append(&quot; and b.book_name like &#39;%&quot; + book.getBookName() + &quot;%&#39;&quot;);        &#125;        if (book.getBookId() !&#x3D; null) &#123;            sb.append(&quot; and b.id&#x3D;&quot; + book.getBookId());        &#125;        PreparedStatement preparedStatement &#x3D; (PreparedStatement) con.prepareStatement(sb.toString());        return preparedStatement.executeQuery();    &#125;    &#x2F;&#x2F; 图书信息删除    public int delete(Connection con, String id) throws Exception &#123;        String sql &#x3D; &quot;delete from book where id&#x3D;?&quot;;        PreparedStatement preparedStatement &#x3D; (PreparedStatement) con.prepareStatement(sql);        preparedStatement.setString(1, id);        return preparedStatement.executeUpdate();    &#125;    &#x2F;&#x2F; 图书信息修改    public int update(Connection con, Book book) throws Exception &#123;        String sql &#x3D; &quot;update book set book_name&#x3D;?,type_id&#x3D;?,author&#x3D;?,publish&#x3D;?,price&#x3D;?,number&#x3D;?,status&#x3D;?,remark&#x3D;? where id&#x3D;?&quot;;        PreparedStatement statement &#x3D; con.prepareStatement(sql);        statement.setString(1, book.getBookName());        statement.setInt(2, book.getBookTypeId());        statement.setString(3, book.getAuthor());        statement.setString(4, book.getPublish());        statement.setDouble(5, book.getPrice());        statement.setInt(6, book.getNumber());        statement.setInt(7, book.getStatus());        statement.setString(8, book.getRemark());        statement.setInt(9, book.getBookId());        return statement.executeUpdate();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-BookTypeDao"><a href="#6-3-BookTypeDao" class="headerlink" title="6.3 BookTypeDao"></a>6.3 BookTypeDao</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.dao;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import com.hechaodong.bookmanager.model.BookType;import com.hechaodong.bookmanager.utils.ToolUtil;public class BookTypeDao &#123;&#x2F;&#x2F; 图书类别添加public int add(Connection con,BookType bookType)throws Exception&#123;&#x2F;&#x2F; 先查询是否有一样的类别名String sql&#x3D;&quot;select * from book_type where type_name &#x3D; ?&quot;;PreparedStatement preparedStatement&#x3D;con.prepareStatement(sql);preparedStatement.setString(1, bookType.getTypeName());ResultSet resultSet &#x3D; preparedStatement.executeQuery();while(resultSet.next())&#123;&#x2F;** 遍历结果集* 如果结果集中有记录，则表示已存在相同名称的图书类型，那么立即返回数字 2，表示添加失败* *&#x2F;return 2;&#125;&#x2F;&#x2F; 完成类别数据的插入操作sql&#x3D;&quot;insert into book_type (type_name,remark) values(?,?)&quot;;PreparedStatement statement&#x3D;con.prepareStatement(sql);statement.setString(1, bookType.getTypeName());statement.setString(2, bookType.getRemark());return statement.executeUpdate();&#125;&#x2F;&#x2F; 查询图书类别集合public ResultSet list(Connection con,BookType bookType)throws Exception&#123;StringBuffer sb&#x3D;new StringBuffer(&quot;select * from book_type&quot;);&#x2F;&#x2F; 判断传入的图书类型对象 bookType 的名称是否为空if(!ToolUtil.isEmpty(bookType.getTypeName()))&#123;sb.append(&quot; and type_name like &#39;%&quot;+bookType.getTypeName()+&quot;%&#39;&quot;);&#125;PreparedStatement preparedStatement&#x3D;con.prepareStatement(sb.toString().replaceFirst(&quot;and&quot;, &quot;where&quot;));return preparedStatement.executeQuery();&#125;&#x2F;&#x2F; 删除图书类别public int delete(Connection con,String id)throws Exception&#123;&#x2F;&#x2F;先查询该类别下是否有书籍String sql&#x3D;&quot;select b.* from book b left join book_type bt on b.type_id &#x3D; bt.id where bt.id &#x3D;? &quot;;PreparedStatement preparedStatement&#x3D;con.prepareStatement(sql);preparedStatement.setString(1, id);ResultSet query &#x3D; preparedStatement.executeQuery();&#x2F;&#x2F; 查询操作int number &#x3D;0;while(query.next())&#123;number++;&#125;if(number &gt; 0)&#123; &#x2F;&#x2F; 表示该类别下存在书籍，那么立即返回数字 3，表示删除失败return 3;&#125;&#x2F;&#x2F;判断类别总数是否大于1sql&#x3D;&quot;select * from book_type&quot;;PreparedStatement pstmt2&#x3D;con.prepareStatement(sql);ResultSet resultSet &#x3D; pstmt2.executeQuery();int count &#x3D; 0;while(resultSet.next())&#123;count++;&#125;if(count&lt;2)&#123; &#x2F;&#x2F; 如果计数器 count 的值小于 2，表示图书类型的总数小于 2，即只有一个类别，那么立即返回数字 2，表示删除失败return 2;&#125;sql&#x3D;&quot;delete from book_type where id&#x3D;?&quot;;PreparedStatement pstmt3&#x3D;con.prepareStatement(sql);pstmt3.setString(1, id);return pstmt3.executeUpdate();&#125;&#x2F;&#x2F; 更新图示类别public int update(Connection con,BookType bookType)throws Exception&#123;String sql&#x3D;&quot;update book_type set type_name&#x3D;?,remark&#x3D;? where id&#x3D;?&quot;;PreparedStatement pstmt&#x3D;con.prepareStatement(sql);pstmt.setString(1, bookType.getTypeName());pstmt.setString(2, bookType.getRemark());pstmt.setInt(3, bookType.getTypeId());return pstmt.executeUpdate();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-BorrowDetailDao"><a href="#6-4-BorrowDetailDao" class="headerlink" title="6.4 BorrowDetailDao"></a>6.4 BorrowDetailDao</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.dao;import java.sql.*;import java.sql.ResultSet;import com.hechaodong.bookmanager.model.BorrowDetail;public class BorrowDetailDao &#123;public ResultSet list(Connection con,BorrowDetail borrowDetail)throws Exception&#123;&#x2F;&#x2F; 创建一个SrtingBuffer,用来拼接sql语句StringBuffer sb&#x3D;new StringBuffer(&quot;SELECT bd.*,u.username,b.book_name from borrowdetail bd,user u,book b where u.id&#x3D;bd.user_id and b.id&#x3D;bd.book_id&quot;);&#x2F;&#x2F;根据查询语句进行sql语句的拼接操作if(borrowDetail.getUserId() !&#x3D; null)&#123;sb.append(&quot; and u.id &#x3D; ?&quot;);&#125;if(borrowDetail.getStatus() !&#x3D; null)&#123;sb.append(&quot; and bd.status &#x3D; ?&quot;);&#125;if(borrowDetail.getBookId() !&#x3D; null)&#123;sb.append(&quot; and bd.book_id &#x3D; ?&quot;);&#125;sb.append(&quot;  order by bd.id&quot;);PreparedStatement prepareStatement&#x3D;(PreparedStatement) con.prepareStatement(sb.toString());if(borrowDetail.getUserId() !&#x3D; null)&#123;prepareStatement.setInt(1, borrowDetail.getUserId());&#125;if(borrowDetail.getStatus() !&#x3D; null &amp;&amp; borrowDetail.getBookId() !&#x3D; null)&#123;prepareStatement.setInt(2, borrowDetail.getStatus());prepareStatement.setInt(3, borrowDetail.getBookId());&#125;&#x2F;&#x2F; 执行sql语句return prepareStatement.executeQuery();&#125;&#x2F;&#x2F; 添加借阅明细信息public int add(Connection con, BorrowDetail borrowDetail) throws Exception &#123;String sql &#x3D; &quot;insert into borrowdetail (user_id,book_id,status,borrow_time) values (?,?,?,?)&quot;;PreparedStatement preparedStatement&#x3D;(PreparedStatement) con.prepareStatement(sql);preparedStatement.setInt(1, borrowDetail.getUserId());preparedStatement.setInt(2, borrowDetail.getBookId());preparedStatement.setInt(3, borrowDetail.getStatus());preparedStatement.setLong(4, borrowDetail.getBorrowTime());return preparedStatement.executeUpdate();&#125;&#x2F;&#x2F; 还书public int returnBook(Connection con,BorrowDetail detail)throws Exception &#123;String sql &#x3D; &quot;update borrowdetail set status &#x3D; ? ,return_time &#x3D; ? where id &#x3D; ?&quot;;PreparedStatement preparedStatement&#x3D;(PreparedStatement) con.prepareStatement(sql);preparedStatement.setInt(1, detail.getStatus());preparedStatement.setLong(2, detail.getReturnTime());preparedStatement.setInt(3, detail.getBorrowId());return preparedStatement.executeUpdate();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-用户登录和注册模块"><a href="#7-用户登录和注册模块" class="headerlink" title="7.  用户登录和注册模块"></a>7.  用户登录和注册模块</h2><h3 id="7-1-用户注册"><a href="#7-1-用户注册" class="headerlink" title="7.1 用户注册"></a>7.1 用户注册</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.awt.*;import java.sql.*;import javax.swing.*;import java.awt.event.FocusEvent;import java.awt.event.FocusListener;import com.hechaodong.bookmanager.dao.UserDao;import com.hechaodong.bookmanager.model.User;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;&#x2F;&#x2F; 用户注册界面&#x2F;&#x2F; 密码校验的正则表达式： ^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,16&#125;$&#x2F;&#x2F; 手机号校验的正则表达式：^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d&#123;8&#125;$public class RegFrm extends JFrame &#123;    private JFrame jf;                          &#x2F;&#x2F;用户注册的窗体组件    private JLabel label;                       &#x2F;&#x2F;展示“用户名”的JLabel    private JTextField textField;               &#x2F;&#x2F;输入用户名所对应的文本框    private JLabel label_1;                     &#x2F;&#x2F; 展示“密码”的JLabel    private JTextField textField_1;             &#x2F;&#x2F;输入密码的文本框    private JLabel label_2;                     &#x2F;&#x2F;展示“手机号”的JLabel    private JTextField textField_2;             &#x2F;&#x2F;输入手机号所对应的文本框    private JLabel label_3;                     &#x2F;&#x2F;展示“性别”的JLabel    private JRadioButton rdbtnNewRadioButton;   &#x2F;&#x2F;性别男    private JRadioButton rdbtnNewRadioButton_1; &#x2F;&#x2F;性别女    private JLabel usernameMes;                 &#x2F;&#x2F;用户名校验结果对应的提示框    private JLabel passwordMes;                 &#x2F;&#x2F;密码校验结果对应的提示框    private JLabel phoneMes;                    &#x2F;&#x2F;手机号校验结果对应的提示框    private JLabel label_4;                     &#x2F;&#x2F;展示“验证码”的JLabel    private JTextField textField_3;             &#x2F;&#x2F;输入验证码所对应的文本框    private ValidCode vcode;                    &#x2F;&#x2F;展示验证码的图片框    private JButton button;                     &#x2F;&#x2F;注册按钮    private JButton button_1;                   &#x2F;&#x2F;前往登录按钮    private JLabel lblNewLabel;                 &#x2F;&#x2F; 背景图片    private JLabel lblNewLabel_1;               &#x2F;&#x2F; 用户注册    &#x2F;&#x2F; 创建UserDao对象    private DbUtil dbUtil &#x3D; new DbUtil();    private UserDao userDao &#x3D; new UserDao();    public RegFrm() &#123;        &#x2F;&#x2F; 初始化窗体        jf &#x3D; new JFrame(&quot;用户注册&quot;);        jf.getContentPane().setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 16));        jf.setBounds(650, 250, 640, 960);        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        jf.getContentPane().setLayout(null);        &#x2F;&#x2F; 初始化展示“用户名”的JLabel        label &#x3D; new JLabel(&quot;用户名：&quot;);        label.setForeground(Color.BLACK);        label.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 24));        label.setBounds(110, 202, 100, 40);        jf.getContentPane().add(label);        &#x2F;&#x2F; 初始化用户名的文本框组件        textField &#x3D; new JTextField();        textField.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        textField.setForeground(Color.BLACK);        textField.setColumns(10);        textField.setBounds(202, 202, 164, 30);        jf.getContentPane().add(textField);        &#x2F;&#x2F; 添加焦点事件监听器，当失去焦点的时候需要对用户的用户名进行校验        textField.addFocusListener(new FocusListener() &#123;            @Override            public void focusGained(FocusEvent e) &#123;            &#125;            @Override            public void focusLost(FocusEvent e) &#123;        &#x2F;&#x2F; 用户名校验                String text &#x3D; textField.getText();                if (ToolUtil.isEmpty(text)) &#123;                    usernameMes.setText(&quot;用户名不能为空&quot;);                    usernameMes.setForeground(Color.RED);                &#125; else &#123;                    usernameMes.setText(&quot;√&quot;);                    usernameMes.setForeground(Color.GREEN);                &#125;            &#125;        &#125;);        &#x2F;&#x2F; 初始化展示“密码”的JLabel        label_1 &#x3D; new JLabel(&quot;密码：&quot;);        label_1.setForeground(Color.BLACK);        label_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 24));        label_1.setBounds(130, 252, 100, 40);        jf.getContentPane().add(label_1);        &#x2F;&#x2F; 初始化密码的文本框组件        textField_1 &#x3D; new JTextField();        textField_1.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 14));        textField_1.setToolTipText(&quot;&quot;);        textField_1.setColumns(10);        textField_1.setBounds(202, 262, 164, 30);        jf.getContentPane().add(textField_1);        &#x2F;&#x2F; 添加焦点事件监听器，当失去焦点的时候需要对用户的密码进行校验        textField_1.addFocusListener(new FocusListener() &#123;            @Override            public void focusLost(FocusEvent e) &#123;                String pwd &#x3D; textField_1.getText();                if (ToolUtil.isEmpty(pwd)) &#123;                    passwordMes.setText(&quot;密码不能为空&quot;);                    passwordMes.setForeground(Color.RED);                &#125; else &#123;                    &#x2F;* 正则表达式                    * 1. ^(?! [0-9]+$)：以任意字符开头，后面不能全部是数字。                    * 2. (?![a-zA-Z]+$)：后面不能全部是字母。                    * 3. [0-9A-Za-z]&#123;6,16&#125;：包含6-16位数字和字母的组合。                    * 4. $：以任意字符结尾。                    * *&#x2F;                    boolean flag &#x3D; pwd.matches(&quot;^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,16&#125;$&quot;);                    if (flag) &#123;                        passwordMes.setText(&quot;√&quot;);                        passwordMes.setForeground(Color.GREEN);                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;密码需为6-16位数字和字母的组合&quot;);                        passwordMes.setText(&quot;&quot;);                    &#125;                &#125;            &#125;            @Override            public void focusGained(FocusEvent e) &#123;            &#125;        &#125;);        &#x2F;&#x2F; 初始化展示“手机号”的JLabel        label_2 &#x3D; new JLabel(&quot;手机号：&quot;);        label_2.setForeground(Color.BLACK);        label_2.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 24));        label_2.setBounds(110, 302, 100, 60);        jf.getContentPane().add(label_2);        &#x2F;&#x2F; 初始化手机号的文本框组件        textField_2 &#x3D; new JTextField();        textField_2.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 14));        textField_2.setColumns(10);        textField_2.setBounds(202, 320, 164, 30);        jf.getContentPane().add(textField_2);        &#x2F;&#x2F; 添加焦点事件监听器，当失去焦点的时候需要对用户的手机号进行校验        textField_2.addFocusListener(new FocusListener() &#123;            @Override            public void focusLost(FocusEvent e) &#123;                String phone &#x3D; textField_2.getText();                if (ToolUtil.isEmpty(phone)) &#123;                    phoneMes.setText(&quot;手机号不能为空&quot;);                    phoneMes.setForeground(Color.RED);                &#125; else &#123;                    &#x2F;*                      1. ^：以任意字符开头。                      2. ((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))：匹配手机号码的前三位，包括130-139、145、147、150-153、155-159、180、185-189等号段。                      3. \d&#123;8&#125;：匹配手机号码后8位数字。                      4. $：以任意字符结尾                     *&#x2F;                    boolean flag &#x3D; phone.matches(&quot;^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d&#123;8&#125;$&quot;);                    if (flag) &#123;                        phoneMes.setText(&quot;√&quot;);                        phoneMes.setForeground(Color.GREEN);                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;请输入正确的手机号格式&quot;);                        phoneMes.setText(&quot;&quot;);                    &#125;                &#125;            &#125;            @Override            public void focusGained(FocusEvent e) &#123;            &#125;        &#125;);        &#x2F;&#x2F; 初始化展示“性别”的JLabel        label_3 &#x3D; new JLabel(&quot;性别：&quot;);        label_3.setForeground(Color.BLACK);        label_3.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 24));        label_3.setBounds(132, 362, 120, 48);        jf.getContentPane().add(label_3);&#x2F;&#x2F; “男”按钮        rdbtnNewRadioButton &#x3D; new JRadioButton(&quot;男&quot;);        rdbtnNewRadioButton.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 16));        rdbtnNewRadioButton.setBounds(202, 377, 58, 23);        jf.getContentPane().add(rdbtnNewRadioButton);&#x2F;&#x2F; “女”按钮        rdbtnNewRadioButton_1 &#x3D; new JRadioButton(&quot;女&quot;);        rdbtnNewRadioButton_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 16));        rdbtnNewRadioButton_1.setBounds(292, 377, 65, 23);        jf.getContentPane().add(rdbtnNewRadioButton_1);        ButtonGroup bg &#x3D; new ButtonGroup();        bg.add(rdbtnNewRadioButton_1);        bg.add(rdbtnNewRadioButton);        &#x2F;&#x2F; 初始化”用户名“校验结果提示的JLabel        usernameMes &#x3D; new JLabel(&quot;&quot;);        usernameMes.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 15));        usernameMes.setBounds(372, 202, 122, 27);        jf.getContentPane().add(usernameMes);        &#x2F;&#x2F; 初始化”密码“校验结果提示的JLabel        passwordMes &#x3D; new JLabel(&quot;&quot;);        passwordMes.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 15));        passwordMes.setBounds(372, 262, 122, 27);        jf.getContentPane().add(passwordMes);        &#x2F;&#x2F; 初始化”手机号“校验结果提示的JLabel        phoneMes &#x3D; new JLabel(&quot;&quot;);        phoneMes.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 15));        phoneMes.setBounds(372, 324, 122, 30);        jf.getContentPane().add(phoneMes);        &#x2F;&#x2F; 展示验证码的图片框        vcode &#x3D; new ValidCode();        vcode.setLocation(362, 422);        jf.getContentPane().add(vcode);        &#x2F;&#x2F; 初始化展示“验证码”的JLabel        label_4 &#x3D; new JLabel(&quot;验证码：&quot;);        label_4.setForeground(Color.BLACK);        label_4.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 24));        label_4.setBounds(110, 420, 100, 40);        jf.getContentPane().add(label_4);        &#x2F;&#x2F; 初始化输入验证码的文本框组件        textField_3 &#x3D; new JTextField();        textField_3.setColumns(18);        textField_3.setBounds(230, 426, 83, 30);        jf.getContentPane().add(textField_3);        &#x2F;&#x2F; 初始化注册按钮        button &#x3D; new JButton(&quot;注册&quot;);        &#x2F;&#x2F; 给注册按钮添加一个动作监听器（校验验证码是否正确）        button.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 获取验证码内容                String code &#x3D; textField_3.getText();                if (ToolUtil.isEmpty(code)) &#123;                    JOptionPane.showMessageDialog(null, &quot;请输入验证码&quot;);                &#125; else &#123;                    if (code.equalsIgnoreCase(vcode.getCode())) &#123;                        RegCheck(e);&#x2F;&#x2F; 验证码校验成功                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;验证码错误，请重新输入&quot;);                    &#125;                &#125;            &#125;        &#125;);        button.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        button.setBounds(120, 620, 120, 48);        jf.getContentPane().add(button);        &#x2F;&#x2F; 初始化前往登录界面的按钮        button_1 &#x3D; new JButton(&quot;前往登录页面&quot;);        &#x2F;&#x2F; 给登录界面的按钮添加一个动作监听器按钮        button_1.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                jf.setVisible(false);                new LoginFrm();            &#125;        &#125;);        button_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        button_1.setBounds(380, 620, 132, 48);        jf.getContentPane().add(button_1);        &#x2F;&#x2F; 初始化”用户注册的“的JLabel        lblNewLabel_1 &#x3D; new JLabel(&quot;用户注册&quot;);        lblNewLabel_1.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 33));        lblNewLabel_1.setForeground(Color.RED); &#x2F;&#x2F; 设置前景色为红色        lblNewLabel_1.setBounds(214, 20, 200, 200);        jf.getContentPane().add(lblNewLabel_1);        &#x2F;&#x2F; 初始化界面注册页面背景图片所需的JLabel        lblNewLabel &#x3D; new JLabel(&quot;&quot;);        lblNewLabel.setForeground(Color.BLACK);        ImageIcon imageIcon &#x3D; new ImageIcon(&quot;lib&#x2F;images&#x2F;1.jpg&quot;);        Image image &#x3D; imageIcon.getImage();        image &#x3D; image.getScaledInstance(640, 960, Image.SCALE_DEFAULT);        imageIcon.setImage(image);        lblNewLabel.setIcon(imageIcon);        lblNewLabel.setBounds(0, 0, 640, 960);        jf.getContentPane().add(lblNewLabel);        &#x2F;&#x2F; 显示页面        jf.setVisible(true);        &#x2F;&#x2F; 是否可以更改jf的大小        jf.setResizable(false);    &#125;    &#x2F;&#x2F; 完成用户注册    public void RegCheck(ActionEvent e) &#123;        &#x2F;&#x2F; 获取相关组件数据        String username &#x3D; textField.getText();        String password &#x3D; textField_1.getText();        String phone &#x3D; textField_2.getText();        String sex &#x3D; &quot;&quot;;        if (rdbtnNewRadioButton.isSelected()) &#123;            sex &#x3D; rdbtnNewRadioButton.getText();        &#125; else &#123;            sex &#x3D; rdbtnNewRadioButton_1.getText();        &#125;        &#x2F;&#x2F; 判断数据是否为空        if (ToolUtil.isEmpty(username) || ToolUtil.isEmpty(password) || ToolUtil.isEmpty(phone)) &#123;            JOptionPane.showMessageDialog(null, &quot;请输入相关信息&quot;);            return;        &#125;        &#x2F;&#x2F; 把数据封装到User对象中        User user &#x3D; new User();        user.setUserName(username);        user.setPassword(password);        user.setSex(sex);        user.setPhone(phone);        user.setRole(1);        &#x2F;&#x2F; 获取一个连接对象        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            int i &#x3D; userDao.addUser(con, user);&#x2F;&#x2F; 使用获取的连接和传递进来的&quot;user&quot;对象进行注册。将注册结果存储在名为&quot;i&quot;的整型变量中            if (i &#x3D;&#x3D; 2) &#123;                JOptionPane.showMessageDialog(null, &quot;该用户名已存在,请重新注册&quot;);            &#125; else if (i &#x3D;&#x3D; 0) &#123;                JOptionPane.showMessageDialog(null, &quot;注册失败&quot;);            &#125; else &#123;                JOptionPane.showMessageDialog(null, &quot;注册成功&quot;);                jf.dispose(); &#x2F;&#x2F; 关闭窗口释放资源                new LoginFrm();&#x2F;&#x2F; 打开登录界面            &#125;        &#125; catch (Exception e1) &#123;            e1.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e1) &#123;                e1.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;            BeautyEyeLNFHelper.launchBeautyEyeLNF();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        new RegFrm(); &#x2F;&#x2F; 注册界面    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-验证码"><a href="#7-2-验证码" class="headerlink" title="7.2 验证码"></a>7.2 验证码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.awt.Color;import java.awt.Dimension;import java.awt.Font;import java.awt.FontMetrics;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.geom.AffineTransform;import java.util.Random; import javax.swing.JComponent;&#x2F;&#x2F; 展示验证码的组件public class ValidCode extends JComponent implements MouseListener &#123; private String code;&#x2F;&#x2F; 验证码的文本信息private int width, height &#x3D; 40;&#x2F;&#x2F; 验证码图片大小private int codeLength &#x3D; 4; &#x2F;&#x2F; 验证码文本信息长度 private Random random &#x3D; new Random();public ValidCode() &#123;width &#x3D; this.codeLength * 16 + (this.codeLength - 1) * 10;setPreferredSize(new Dimension(width, height));setSize(width, height);this.addMouseListener(this);setToolTipText(&quot;点击可以更换验证码&quot;);&#125; public int getCodeLength() &#123;return codeLength;&#125; &#x2F;&#x2F; 设置验证码文字的长度public void setCodeLength(int codeLength) &#123;if(codeLength &lt; 4) &#123;this.codeLength &#x3D; 4;&#125; else &#123;this.codeLength &#x3D; codeLength;&#125;&#125; public String getCode() &#123;return code;&#125; &#x2F;&#x2F; 产生随机的颜色public Color getRandColor(int min, int max) &#123;if (min &gt; 255)min &#x3D; 255;if (max &gt; 255)max &#x3D; 255;int red &#x3D; random.nextInt(max - min) + min;int green &#x3D; random.nextInt(max - min) + min;int blue &#x3D; random.nextInt(max - min) + min;return new Color(red, green, blue);&#125;&#x2F;&#x2F; 设置验证码具体的字母是什么public String generateCode() &#123;char[] codes &#x3D; new char[this.codeLength];for (int i &#x3D; 0, len &#x3D; codes.length; i &lt; len; i++) &#123;if (random.nextBoolean()) &#123;codes[i] &#x3D; (char) (random.nextInt(26) + 65);&#125; else &#123;codes[i] &#x3D; (char) (random.nextInt(26) + 97);&#125;&#125;this.code &#x3D; new String(codes);return this.code;&#125; @Overrideprotected void paintComponent(Graphics g) &#123; &#x2F;&#x2F; Graphics是画笔对象，用来画出验证码super.paintComponent(g);if(this.code &#x3D;&#x3D; null || this.code.length() !&#x3D; this.codeLength) &#123;this.code &#x3D; generateCode();&#125;width &#x3D; this.codeLength * 16 + (this.codeLength - 1) * 10;super.setSize(width, height);super.setPreferredSize(new Dimension(width, height));Font mFont &#x3D; new Font(&quot;Arial&quot;, Font.BOLD | Font.ITALIC, 25);g.setFont(mFont);&#x2F;&#x2F;绘制出验证码的背景的矩形轮廓Graphics2D g2d &#x3D; (Graphics2D) g;g2d.setColor(getRandColor(200, 250));g2d.fillRect(0, 0, width, height);g2d.setColor(getRandColor(180, 200));g2d.drawRect(0, 0, width - 1, height - 1); &#x2F;&#x2F; 画一个矩阵&#x2F;&#x2F;绘制出验证码背景的线int i &#x3D; 0, len &#x3D; 150;for (; i &lt; len; i++) &#123;int x &#x3D; random.nextInt(width - 1);int y &#x3D; random.nextInt(height - 1);int x1 &#x3D; random.nextInt(width - 10) + 10;int y1 &#x3D; random.nextInt(height - 4) + 4;g2d.setColor(getRandColor(180, 200));g2d.drawLine(x, y, x1, y1);  &#x2F;&#x2F; 画线&#125;&#x2F;&#x2F;绘制出验证码的具体字母i &#x3D; 0; len &#x3D; this.codeLength;FontMetrics fm &#x3D; g2d.getFontMetrics();int base &#x3D; (height - fm.getHeight())&#x2F;2 + fm.getAscent();for(;i&lt;len;i++) &#123;int b &#x3D; random.nextBoolean() ? 1 : -1;g2d.rotate(random.nextInt(10)*0.01*b);g2d.setColor(getRandColor(20, 130));g2d.drawString(code.charAt(i)+&quot;&quot;, 16 * i + 10, base);&#x2F;&#x2F; 从二维字符中获取对应的字符将其划到界面中&#125;&#125; &#x2F;&#x2F;下一个验证码public void nextCode() &#123;generateCode();&#x2F;&#x2F; 重新生成一个4位数的验证码repaint();&#x2F;&#x2F; 重新渲染组件&#125; @Overridepublic void mouseClicked(MouseEvent e) &#123;nextCode();&#125; @Overridepublic void mousePressed(MouseEvent e) &#123;&#125; @Overridepublic void mouseReleased(MouseEvent e) &#123;&#125; @Overridepublic void mouseEntered(MouseEvent e) &#123;&#125; @Overridepublic void mouseExited(MouseEvent e) &#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-用户登录"><a href="#7-3-用户登录" class="headerlink" title="7.3 用户登录"></a>7.3 用户登录</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.awt.*;import java.sql.*;import javax.swing.ImageIcon;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JOptionPane;import javax.swing.JPasswordField;import com.hechaodong.bookmanager.dao.UserDao;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import com.hechaodong.bookmanager.model.User;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import javax.swing.JTextField;import javax.swing.JComboBox;import javax.swing.JButton;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;&#x2F;&#x2F; 用户登录界面public class LoginFrm extends JFrame &#123;    public static User currentUser;             &#x2F;&#x2F; 当登录成功后，使用该变量存储登录的用户    private JFrame jf;                          &#x2F;&#x2F; 登录界面的窗体结构    private JTextField userNameText;            &#x2F;&#x2F; 输入用户名的文本框    private JTextField passwordText;            &#x2F;&#x2F; 输入密码的文本框    private JComboBox&lt;String&gt; comboBox;         &#x2F;&#x2F; 用户选项的下拉选择框    private UserDao userDao &#x3D; new UserDao();    private DbUtil dbUtil &#x3D; new DbUtil();    public LoginFrm() &#123;        &#x2F;&#x2F; 初始化窗体组件        jf &#x3D; new JFrame(&quot;图书管理&quot;);        jf.getContentPane().setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        jf.setBounds(650, 250, 640, 960);        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        jf.getContentPane().setLayout(null);        &#x2F;&#x2F; 初始化登录界面的图片        JLabel lblNewLabel &#x3D; new JLabel();        ImageIcon imageIcon &#x3D; new ImageIcon(&quot;lib&#x2F;images&#x2F;2.jpg&quot;);        Image image &#x3D; imageIcon.getImage();        image &#x3D; image.getScaledInstance(280, 168, Image.SCALE_DEFAULT);        imageIcon.setImage(image);        lblNewLabel.setIcon(imageIcon);        lblNewLabel.setBounds(180, 72, 430, 218);        jf.getContentPane().add(lblNewLabel);        &#x2F;&#x2F; 初始化展示“用户名”的JLabel        JLabel label &#x3D; new JLabel(&quot;用户名：&quot;);        label.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 24));        label.setBounds(150, 292, 100, 100);        jf.getContentPane().add(label);        &#x2F;&#x2F; 初始化用户名的文本框组件        userNameText &#x3D; new JTextField();        userNameText.setBounds(250, 322, 142, 40);        jf.getContentPane().add(userNameText);        userNameText.setColumns(10);        &#x2F;&#x2F; 初始化展示“密码”的JLabel        JLabel label_1 &#x3D; new JLabel(&quot;密码：&quot;);        label_1.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 24));        label_1.setBounds(170, 362, 100, 100);        jf.getContentPane().add(label_1);        &#x2F;&#x2F; 初始化密码的文本框组件        passwordText &#x3D; new JPasswordField();        passwordText.setColumns(10);        passwordText.setBounds(250, 392, 142, 40);        jf.getContentPane().add(passwordText);        &#x2F;&#x2F; 初始化展示“权限”的JLabel        JLabel label_2 &#x3D; new JLabel(&quot;权限：&quot;);        label_2.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 24));        label_2.setBounds(172, 442, 80, 80);        jf.getContentPane().add(label_2);        &#x2F;&#x2F; 初始权限的文本框组件        comboBox &#x3D; new JComboBox();        comboBox.setBounds(250, 462, 142, 40);        comboBox.addItem(&quot;用户&quot;);        comboBox.addItem(&quot;管理员&quot;);        jf.getContentPane().add(comboBox); &#x2F;&#x2F; 用户-----管理员        &#x2F;&#x2F; 登录按钮        JButton button &#x3D; new JButton(&quot;登录&quot;);        button.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                checkLogin(e); &#x2F;&#x2F; 检查登录（获取数据比对数据库信息）            &#125;        &#125;);        button.setBounds(150, 650, 120, 48);        jf.getContentPane().add(button);        &#x2F;&#x2F; 注册按钮        JButton button_1 &#x3D; new JButton(&quot;注册&quot;);        button_1.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                regUser(e); &#x2F;&#x2F; 跳转到注册界面            &#125;        &#125;);        button_1.setBounds(350, 650, 120, 48);        jf.getContentPane().add(button_1);        &#x2F;&#x2F; 登录界面背景图        JLabel lblNewLabel_1 &#x3D; new JLabel(&quot;&quot;);        lblNewLabel_1.setIcon(new ImageIcon(&quot;lib&#x2F;images&#x2F;3.jpg&quot;));        lblNewLabel_1.setBounds(0, 0, 640, 940);        jf.getContentPane().add(lblNewLabel_1);        &#x2F;&#x2F; 显示界面，不可以调整界面大小        jf.setVisible(true);        jf.setResizable(false);    &#125;    &#x2F;&#x2F; 跳转到注册页面    public void regUser(ActionEvent e) &#123;        jf.setVisible(false);        new RegFrm();    &#125;    &#x2F;&#x2F; 用户登录的逻辑操作（获取数据并校对数据库数据是否一致）    public void checkLogin(ActionEvent e) &#123;        &#x2F;&#x2F; 获取用户登录信息        String userName &#x3D; userNameText.getText();        String password &#x3D; passwordText.getText();        int index &#x3D; comboBox.getSelectedIndex(); &#x2F;&#x2F; 权限        if (ToolUtil.isEmpty(userName) || ToolUtil.isEmpty(password)) &#123;            JOptionPane.showMessageDialog(null, &quot;用户名和密码不能为空&quot;);            return;        &#125;        &#x2F;&#x2F; 把数据封装到User对象中        User user &#x3D; new User();        user.setUserName(userName);        user.setPassword(password);        if (index &#x3D;&#x3D; 0) &#123;            user.setRole(1);&#x2F;&#x2F; 用户        &#125; else &#123;            user.setRole(2);&#x2F;&#x2F; 管理员        &#125;        &#x2F;&#x2F; 获取一个连接对象        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection(); &#x2F;&#x2F; 获取数据库连接            User login &#x3D; userDao.login(con, user);&#x2F;&#x2F; 使用获取的连接和传递进来的&quot;user&quot;对象进行登录验证            currentUser &#x3D; login;            if (login &#x3D;&#x3D; null) &#123;                JOptionPane.showMessageDialog(null, &quot;登录失败&quot;);            &#125; else &#123;                &#x2F;&#x2F; 权限 1普通 2管理员                if (index &#x3D;&#x3D; 0) &#123;                    jf.dispose(); &#x2F;&#x2F; 释放与当前窗口关联的所有资源                    new UserMenuFrm(); &#x2F;&#x2F; 用户界面                &#125; else &#123;                    jf.dispose();&#x2F;&#x2F; 释放与当前窗口关联的所有资源                    new AdminMenuFrm(); &#x2F;&#x2F; 管理员界面                &#125;            &#125;        &#125; catch (Exception e21) &#123;            e21.printStackTrace();            JOptionPane.showMessageDialog(null, &quot;登录异常&quot;);        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e31) &#123;                e31.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;            BeautyEyeLNFHelper.launchBeautyEyeLNF();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        new LoginFrm();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-图书借还模块"><a href="#8-图书借还模块" class="headerlink" title="8. 图书借还模块"></a>8. 图书借还模块</h2><h3 id="8-1-用户操作界面"><a href="#8-1-用户操作界面" class="headerlink" title="8.1 用户操作界面"></a>8.1 用户操作界面</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.sql.*;import java.awt.Color;import java.awt.Font;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.sql.ResultSet;import java.util.Vector;import javax.swing.JButton;import javax.swing.JComboBox;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTable;import javax.swing.JTextField;import javax.swing.UIManager;import javax.swing.border.TitledBorder;import javax.swing.table.DefaultTableModel;import com.hechaodong.bookmanager.dao.BorrowDetailDao;import com.hechaodong.bookmanager.dao.BookDao;import com.hechaodong.bookmanager.model.BorrowDetail;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import com.hechaodong.bookmanager.model.Book;import javax.swing.ImageIcon;public class UserMenuFrm extends JFrame &#123;    private JFrame jf;                  &#x2F;&#x2F; 主界面的JFrame窗口    private JLabel lblNewLabel_1;       &#x2F;&#x2F; 展示当前登录用户的用户名所需要的JLabel    private JLabel lblNewLabel_2;       &#x2F;&#x2F; 展示顶部“欢迎你”的JLabel    private JTable table;               &#x2F;&#x2F; 借阅信息的表格组件    private DefaultTableModel model;    &#x2F;&#x2F; 借阅信息的表格组件所需要的数据模型对象    private JTextField textField;       &#x2F;&#x2F; 输入换书编号的文本框textField    private JButton btnBackBook;        &#x2F;&#x2F; 换书按钮    private JButton button;             &#x2F;&#x2F; 退出系统按钮    private JPanel panel_2;             &#x2F;&#x2F; 初始化展示图书信息所需要的面板    private JComboBox comboBox;         &#x2F;&#x2F; 搜索字段所需要的下拉选择框    private JTextField textField_1;     &#x2F;&#x2F; 搜索关键字所需要的文本框    private JButton button_1;           &#x2F;&#x2F; 查询按钮    private JTable BookTable;           &#x2F;&#x2F; 展示图书信息所需要的表格组件    private DefaultTableModel BookModel;&#x2F;&#x2F; 展示图书信息所需要的表格组件的数据模型组件    private JTextField textField_2;     &#x2F;&#x2F; 展示借书编号所需要的文本框组件    private JTextField textField_3;     &#x2F;&#x2F; 展示借书书名所需要的文本框组件    private JLabel lblNewLabel_3;       &#x2F;&#x2F; 展示背景图片所需要的JLabel    private DbUtil dbUtil &#x3D; new DbUtil();    private BorrowDetailDao borrowDetailDao &#x3D; new BorrowDetailDao();    private BookDao BookDao &#x3D; new BookDao();    public UserMenuFrm() &#123;        &#x2F;&#x2F; 初始化用户操作界面        jf &#x3D; new JFrame();        jf.setTitle(&quot;用户页面&quot;);        jf.setBounds(650, 250, 691, 896);        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        jf.getContentPane().setLayout(null);        &#x2F;&#x2F; 顶部展示”借阅信息“的JPanel        JPanel panel_1 &#x3D; new JPanel();        panel_1.setBorder(new TitledBorder(UIManager.getBorder(&quot;TitledBorder.border&quot;), &quot;借阅信息&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, new Color(255, 0, 0)));        panel_1.setBounds(23, 48, 651, 239);        &#x2F;&#x2F; 表头栏数据        String[] title &#x3D; &#123;&quot;编号&quot;, &quot;书名&quot;, &quot;状态&quot;, &quot;借书时间&quot;, &quot;还书时间&quot;&#125;;&#x2F;&#x2F; 一维数组        &#x2F;&#x2F; 具体的各栏行记录 先用空的二位数组占位        String[][] dates &#x3D; &#123;&#125;;        &#x2F;&#x2F; 初始化表格组件以及数据模型组件 （然后实例化 上面2个控件对象）        model &#x3D; new DefaultTableModel(dates, title);        table &#x3D; new JTable();        table.setModel(model);        &#x2F;&#x2F; 获取数据库数据放置table中        putDates(new BorrowDetail());        &#x2F;&#x2F; 将表格组件添加到JScrollPane中，并将JScrollPane添加到panel_1中，最后将panel_1添加到JFrame中        panel_1.setLayout(null);        JScrollPane jscrollpane &#x3D; new JScrollPane();        jscrollpane.setBounds(20, 22, 607, 188);        jscrollpane.setViewportView(table);        panel_1.add(jscrollpane);        jf.getContentPane().add(panel_1);        &#x2F;&#x2F; 顶部问候语        lblNewLabel_1 &#x3D; new JLabel(&quot;New label&quot;);        lblNewLabel_1.setForeground(Color.RED);        lblNewLabel_1.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 18));        lblNewLabel_1.setBounds(315, 0, 197, 28);        jf.getContentPane().add(lblNewLabel_1);        lblNewLabel_1.setText(LoginFrm.currentUser.getUserName());        lblNewLabel_2 &#x3D; new JLabel(&quot;欢迎来到知识的海洋 &quot;);        lblNewLabel_2.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 18));        lblNewLabel_2.setBounds(254, 4, 258, 68);        jf.getContentPane().add(lblNewLabel_2);        &#x2F;&#x2F; 还书操作界面的JPanel        JPanel panel &#x3D; new JPanel();        panel.setBorder(new TitledBorder(UIManager.getBorder(&quot;TitledBorder.border&quot;), &quot;还书&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, new Color(255, 0, 0)));        panel.setBounds(23, 294, 651, 70);        jf.getContentPane().add(panel);        panel.setLayout(null);        &#x2F;&#x2F; 展示“编号”的JLabel        JLabel lblNewLabel &#x3D; new JLabel(&quot;编号：&quot;);        lblNewLabel.setBounds(90, 25, 51, 27);        panel.add(lblNewLabel);        lblNewLabel.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 16));        &#x2F;&#x2F; 初始化编号所对应的文本框组件        textField &#x3D; new JTextField();        textField.setBounds(145, 28, 116, 24);        panel.add(textField);        textField.setColumns(10);        &#x2F;&#x2F; 初始化还书按钮        btnBackBook &#x3D; new JButton(&quot;还书&quot;);        btnBackBook.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 15));        btnBackBook.setBounds(299, 25, 85, 31);        panel.add(btnBackBook);        &#x2F;&#x2F; 初始化退出系统按钮        button &#x3D; new JButton(&quot;退出系统&quot;);        button.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 15));        button.setBounds(407, 25, 103, 31);        panel.add(button);        &#x2F;&#x2F; 初始化展示展示图书信息的面板        panel_2 &#x3D; new JPanel();        panel_2.setBorder(new TitledBorder(null, &quot;借阅信息&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));        panel_2.setBounds(23, 374, 651, 346);        jf.getContentPane().add(panel_2);        panel_2.setLayout(null);        &#x2F;&#x2F; 初始化查询关所对应的文本框组件        textField_1 &#x3D; new JTextField();        textField_1.setColumns(10);        textField_1.setBounds(252, 23, 135, 27);        panel_2.add(textField_1);        &#x2F;&#x2F; 初始化查询按钮组件        button_1 &#x3D; new JButton(&quot;查询&quot;);        button_1.addActionListener(new ActionListener() &#123;       &#x2F;&#x2F; 业务查询的代码逻辑            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 获取查询字段                int index &#x3D; comboBox.getSelectedIndex();                if (index &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 书名查询                    String bookName &#x3D; textField_1.getText();                    Book book &#x3D; new Book();                    book.setBookName(bookName);                    putDates(book);                &#125; else &#123;          &#x2F;&#x2F; 作者名查询                    String authoerName &#x3D; textField_1.getText();                    Book book &#x3D; new Book();                    book.setAuthor(authoerName);                    putDates(book);                &#125;            &#125;        &#125;);        &#x2F;&#x2F; 查询按钮        button_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 16));        button_1.setBounds(408, 20, 93, 33);        panel_2.add(button_1);        &#x2F;&#x2F; 初始化查询字段所对应的下拉选择框组件        comboBox &#x3D; new JComboBox();        comboBox.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        comboBox.setBounds(123, 26, 109, 24);        comboBox.addItem(&quot;书籍名称&quot;);        comboBox.addItem(&quot;书籍作者&quot;);        panel_2.add(comboBox);        &#x2F;&#x2F; 展示图书信息所对应的表头数据        String[] BookTitle &#x3D; &#123;&quot;编号&quot;, &quot;书名&quot;, &quot;类型&quot;, &quot;作者&quot;, &quot;描述&quot;&#125;;        &#x2F;&#x2F; 具体的各栏行记录 先用空的二位数组占位        String[][] BookDates &#x3D; &#123;&#125;;        &#x2F;&#x2F; 建立数据模型，实例化上面2个控件对象        BookModel &#x3D; new DefaultTableModel(BookDates, BookTitle);        BookTable &#x3D; new JTable(BookModel);        &#x2F;&#x2F; 获取数据库数据放置table中        putDates(new Book());        &#x2F;&#x2F; 将bookTable添加到JScrollPane中，再将JScrollPane添加到panel_2中，最后将panel_2添加到JFrame中        panel_2.setLayout(null);        JScrollPane jscrollpane1 &#x3D; new JScrollPane();        jscrollpane1.setBounds(22, 74, 607, 250);        jscrollpane1.setViewportView(BookTable);        panel_2.add(jscrollpane1);        jf.getContentPane().add(panel_2);        &#x2F;&#x2F; 创建展示借书的面板        JPanel panel_3 &#x3D; new JPanel();        panel_3.setBorder(new TitledBorder(null, &quot;借书&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));        panel_3.setBounds(23, 730, 645, 87);        jf.getContentPane().add(panel_3);        panel_3.setLayout(null);        &#x2F;&#x2F; 初始化展示编号两个字所需要的JLabel        JLabel label &#x3D; new JLabel(&quot;编号：&quot;);        label.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 15));        label.setBounds(68, 31, 48, 33);        panel_3.add(label);        &#x2F;&#x2F; 初始化展示所借图书编号所需要的文本框组件        textField_2 &#x3D; new JTextField();        textField_2.setEditable(false);        textField_2.setColumns(10);        textField_2.setBounds(126, 34, 135, 27);        panel_3.add(textField_2);        &#x2F;&#x2F; 初始化展示书名两个字所需要的JLabel        JLabel label_1 &#x3D; new JLabel(&quot;书名：&quot;);        label_1.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 15));        label_1.setBounds(281, 31, 48, 33);        panel_3.add(label_1);        &#x2F;&#x2F; 初始化展示所借书名所需要的文本框组件        textField_3 &#x3D; new JTextField();        textField_3.setEditable(false);        textField_3.setColumns(10);        textField_3.setBounds(339, 34, 135, 27);        panel_3.add(textField_3);        &#x2F;&#x2F; 创建借书按钮        JButton button_2 &#x3D; new JButton(&quot;借书&quot;);        button_2.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 获取要借的书所对应的编号及其书名                String bookId &#x3D; textField_2.getText();                String bookName &#x3D; textField_3.getText();                if (ToolUtil.isEmpty(bookId) || ToolUtil.isEmpty(bookName)) &#123;                    JOptionPane.showMessageDialog(null, &quot;请选择相关书籍&quot;);                    return;                &#125;                &#x2F;&#x2F; 把要借的书的相关信息封装成一个BorrowDetail                BorrowDetail borrowDetail &#x3D; new BorrowDetail();                borrowDetail.setUserId(LoginFrm.currentUser.getUserId());                borrowDetail.setBookId(Integer.parseInt(bookId));                borrowDetail.setStatus(1);                borrowDetail.setBorrowTime(ToolUtil.getTime());                &#x2F;&#x2F; 获取连接对象                Connection con &#x3D; null;                try &#123;                    con &#x3D; dbUtil.getConnection();                    ResultSet list &#x3D; borrowDetailDao.list(con, borrowDetail);&#x2F;&#x2F;先查询是否有该书                    while (list.next()) &#123;                        JOptionPane.showMessageDialog(null, &quot;该书已在借,请先还再借&quot;);                        return;                    &#125;                    &#x2F;&#x2F; 保存借阅信息                    int i &#x3D; borrowDetailDao.add(con, borrowDetail);                    &#x2F;&#x2F; 对返回结果进行判断                    if (i &#x3D;&#x3D; 1) &#123;                        JOptionPane.showMessageDialog(null, &quot;借书成功&quot;);                        putDates(new BorrowDetail());                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;借书失败&quot;);                    &#125;                &#125; catch (Exception e1) &#123;                    e1.printStackTrace();                    JOptionPane.showMessageDialog(null, &quot;借书异常&quot;);                &#125; finally &#123;                    try &#123;                        dbUtil.closeCon(con);                    &#125; catch (Exception e1) &#123;                        e1.printStackTrace();                    &#125;                &#125;            &#125;        &#125;);        button_2.setFont(new Font(&quot;Dialog&quot;, Font.BOLD, 16));        button_2.setBounds(495, 31, 80, 33);        panel_3.add(button_2);        &#x2F;&#x2F; 初始化展示背景图片所需要的JLabel        lblNewLabel_3 &#x3D; new JLabel(&quot;&quot;);        lblNewLabel_3.setIcon(new ImageIcon(&quot;lib&#x2F;images&#x2F;7.png&quot;));        lblNewLabel_3.setBounds(0, 0, 684, 864);        jf.getContentPane().add(lblNewLabel_3);        &#x2F;&#x2F; 给借书的表格添加一个鼠标监听器        BookTable.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                tableMousePressed(evt);            &#125;        &#125;);        &#x2F;&#x2F; 给退出系统添加一个动作监听按钮        button.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                JOptionPane.showMessageDialog(null, &quot;欢迎再次使用&quot;);                jf.dispose();            &#125;        &#125;);        btnBackBook.setVisible(false);&#x2F;&#x2F; 关闭窗口        &#x2F;&#x2F; 给还书按钮添加一个动作监听按钮        btnBackBook.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 获取还书信息的编号                String BorrowStr &#x3D; textField.getText();                if (ToolUtil.isEmpty(BorrowStr)) &#123;                    JOptionPane.showMessageDialog(null, &quot;请选择未还的书籍&quot;);                    return;                &#125;                &#x2F;&#x2F; 创建BorrowDetail对象，封装还书所对应的数据                BorrowDetail detail &#x3D; new BorrowDetail();                detail.setBorrowId(Integer.parseInt(BorrowStr));                detail.setStatus(2);                detail.setReturnTime(ToolUtil.getTime());                &#x2F;&#x2F; 获取连接对象                Connection con &#x3D; null;                try &#123;                    con &#x3D; dbUtil.getConnection();                    int i &#x3D; borrowDetailDao.returnBook(con, detail);                    if (i &#x3D;&#x3D; 1) &#123;                        JOptionPane.showMessageDialog(null, &quot;还书成功&quot;);                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;还书失败&quot;);                    &#125;                &#125; catch (Exception e1) &#123;                    e1.printStackTrace();                    JOptionPane.showMessageDialog(null, &quot;还书异常&quot;);                &#125; finally &#123;                    try &#123;                        dbUtil.closeCon(con);                    &#125; catch (Exception e1) &#123;                        e1.printStackTrace();                    &#125;                &#125;                &#x2F;&#x2F; 重新查询借阅信息                putDates(new BorrowDetail());            &#125;        &#125;);        &#x2F;&#x2F; 让jf可以显示，并且可以更改jf的大小        jf.setVisible(true);        jf.setResizable(true);    &#125;    public void tableMousePressed(MouseEvent evt) &#123;        &#x2F;&#x2F; 获取当前用户所选择的数据行，然后将该行的数据在借书面板的相关组件中进行展示        int row &#x3D; BookTable.getSelectedRow();        Object bookId &#x3D; BookTable.getValueAt(row, 0);        Object bookName &#x3D; BookTable.getValueAt(row, 1);        textField_2.setText(bookId.toString());        textField_3.setText(bookName.toString());    &#125;    &#x2F;&#x2F;从数据库获取书籍信息    public void putDates(Book book) &#123;        DefaultTableModel model &#x3D; (DefaultTableModel) BookTable.getModel();        model.setRowCount(0);&#x2F;&#x2F; 将表格的行数设置为0，即清空表格中的所有行数据        &#x2F;&#x2F; 获取连接对象        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            book.setStatus(1);&#x2F;&#x2F; 给book对象设置sataus属性为1 上架            ResultSet list &#x3D; BookDao.list(con, book);&#x2F;&#x2F; 调用BookDao中的方法进行查询            while (list.next()) &#123;                Vector rowData &#x3D; new Vector();                rowData.add(list.getInt(&quot;id&quot;));                rowData.add(list.getString(&quot;book_name&quot;));                rowData.add(list.getString(&quot;type_name&quot;));                rowData.add(list.getString(&quot;author&quot;));                rowData.add(list.getString(&quot;remark&quot;));                model.addRow(rowData);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public void putDates(BorrowDetail borrowDetail) &#123;        DefaultTableModel model &#x3D; (DefaultTableModel) table.getModel();        model.setRowCount(0);        Integer userId &#x3D; LoginFrm.currentUser.getUserId();        Connection con &#x3D; null;        &#x2F;&#x2F; 获取连接对象        try &#123;            con &#x3D; dbUtil.getConnection();            borrowDetail.setUserId(userId);            ResultSet list &#x3D; borrowDetailDao.list(con, borrowDetail);            while (list.next()) &#123;                Vector rowData &#x3D; new Vector();                rowData.add(list.getInt(&quot;id&quot;));                rowData.add(list.getString(&quot;book_name&quot;));                int status &#x3D; list.getInt(&quot;status&quot;);                if (status &#x3D;&#x3D; 1) &#123;                    rowData.add(&quot;在借&quot;);                &#125;                if (status &#x3D;&#x3D; 2) &#123;                    rowData.add(&quot;已还&quot;);                &#125;                rowData.add(ToolUtil.getDateByTime(list.getLong(&quot;borrow_time&quot;)));                if (status &#x3D;&#x3D; 2) &#123;                    rowData.add(ToolUtil.getDateByTime(list.getLong(&quot;return_time&quot;)));                &#125;                model.addRow(rowData);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;        &#x2F;&#x2F; 添加一个鼠标监听器        table.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent me) &#123;                putBack(me);            &#125;        &#125;);    &#125;    protected void putBack(MouseEvent me) &#123;        &#x2F;&#x2F; 获取用户所选的行信息        int row &#x3D; table.getSelectedRow();        Integer borrowId &#x3D; (Integer) table.getValueAt(row, 0);        String status &#x3D; (String) table.getValueAt(row, 2);        textField.setText(borrowId.toString());        if (status.equals(&quot;在借&quot;)) &#123;            this.btnBackBook.setVisible(true);        &#125; else &#123;            this.btnBackBook.setVisible(false);        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;            BeautyEyeLNFHelper.launchBeautyEyeLNF();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        new UserMenuFrm();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-书籍管理模块"><a href="#9-书籍管理模块" class="headerlink" title="9. 书籍管理模块"></a>9. 书籍管理模块</h2><h3 id="9-1-管理员操作界面"><a href="#9-1-管理员操作界面" class="headerlink" title="9.1 管理员操作界面"></a>9.1 管理员操作界面</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.sql.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import javax.swing.JFrame;import com.hechaodong.bookmanager.dao.BookTypeDao;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import com.hechaodong.bookmanager.model.BookType;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import javax.swing.JMenuBar;import javax.swing.JMenu;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.swing.JLabel;import javax.swing.JTextField;import java.awt.Font;import javax.swing.JButton;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import javax.swing.JTextArea;import java.awt.Color;import javax.swing.ImageIcon;public class AdminMenuFrm extends JFrame &#123;private JFrame jf;&#x2F;&#x2F; 主操作界面所对应的窗体private JTextField textField;&#x2F;&#x2F; 输入类别名称所需要的文本框组件private JButton btnNewButton;&#x2F;&#x2F;添加按钮private JTextArea textArea;&#x2F;&#x2F;输入类别详情信息所需要的文本框组件private DbUtil dbUtil&#x3D;new DbUtil();private BookTypeDao bookTypeDao&#x3D;new BookTypeDao();public AdminMenuFrm()&#123;&#x2F;&#x2F; 初始化主界面所对应的窗体组件jf&#x3D;new JFrame(&quot;管理员界面&quot;);jf.setBounds(650, 250, 600, 429);jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);jf.getContentPane().setLayout(null);&#x2F;&#x2F; 初始化展示“类别名称”的 JLabelJLabel label &#x3D; new JLabel();label.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));label.setText(&quot;类别说明：&quot;);label.setBounds(112, 107, 75, 26);jf.getContentPane().add(label);&#x2F;&#x2F; 初始化展示“类别说明”的JLabelJLabel label_1 &#x3D; new JLabel();label_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));label_1.setText(&quot;类别名称：&quot;);label_1.setBounds(112, 38, 75, 26);jf.getContentPane().add(label_1);&#x2F;&#x2F; 初始化输入类别名称所需要的文本框组件textField &#x3D; new JTextField();textField.setBounds(197, 38, 241, 26);jf.getContentPane().add(textField);&#x2F;&#x2F; 初始化添加按钮btnNewButton &#x3D; new JButton(&quot;添加&quot;);btnNewButton.addActionListener(new ActionListener() &#123;public void actionPerformed(ActionEvent e) &#123;&#x2F;&#x2F; 获取类别名称和类别说明数据String typeName &#x3D; textField.getText();String typeRemark &#x3D; textArea.getText();&#x2F;&#x2F; 判断数据if (ToolUtil.isEmpty(typeName) || ToolUtil.isEmpty(typeRemark)) &#123;JOptionPane.showMessageDialog(null, &quot;请输入相关信息&quot;);return;&#125;&#x2F;&#x2F; 把数据封装到BookType对象BookType bookType &#x3D; new BookType();bookType.setTypeName(typeName);bookType.setRemark(typeRemark);&#x2F;&#x2F; 获取连接对象Connection con &#x3D; null;try &#123;&#x2F;&#x2F; 把数据保存到数据库中con &#x3D; dbUtil.getConnection();int i &#x3D; bookTypeDao.add(con, bookType);if (i &#x3D;&#x3D; 1) &#123;JOptionPane.showMessageDialog(null, &quot;添加成功&quot;);reset();&#125;else if(i &#x3D;&#x3D; 2)&#123;JOptionPane.showMessageDialog(null, &quot;添加失败,类别已存在&quot;);&#125; else &#123;JOptionPane.showMessageDialog(null, &quot;添加失败&quot;);&#125;&#125; catch (Exception e1) &#123;e1.printStackTrace();&#125;finally&#123;try &#123;dbUtil.closeCon(con);&#125; catch (Exception e1) &#123;e1.printStackTrace();&#125;&#125;&#125;&#125;);btnNewButton.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));btnNewButton.setBounds(182, 281, 80, 26);jf.getContentPane().add(btnNewButton);&#x2F;&#x2F; 初始化重置按钮JButton button &#x3D; new JButton(&quot;重置&quot;);button.addActionListener(new ActionListener() &#123;public void actionPerformed(ActionEvent e) &#123;reset(); &#x2F;&#x2F; 清空数据&#125;&#125;);button.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));button.setBounds(360, 281, 80, 26);jf.getContentPane().add(button);&#x2F;&#x2F; 初始化类别详细信息所需要的文本域组件textArea &#x3D; new JTextArea();textArea.setColumns(20);textArea.setRows(5);textArea.setBackground(Color.WHITE);textArea.setBounds(197, 109, 241, 132);jf.getContentPane().add(textArea);&#x2F;&#x2F; 初始化展示背景图片所需要的JLabelJLabel lblNewLabel &#x3D; new JLabel(&quot;&quot;);lblNewLabel.setIcon(new ImageIcon(&quot;lib&#x2F;images&#x2F;6.png&quot;));lblNewLabel.setBounds(0, 0, 584, 370);jf.getContentPane().add(lblNewLabel);&#x2F;&#x2F; 创建菜单栏组件JMenuBar menuBar &#x3D; new JMenuBar();jf.setJMenuBar(menuBar);&#x2F;&#x2F; 添加类别管理JMenu mnNewMenu &#x3D; new JMenu(&quot;类别管理&quot;);menuBar.add(mnNewMenu);&#x2F;&#x2F; 添加类别添加菜单项JMenuItem mntmNewMenuItem &#x3D; new JMenuItem(&quot;类别添加&quot;);mnNewMenu.add(mntmNewMenuItem);&#x2F;&#x2F; 添加类别修改菜单项JMenuItem mntmNewMenuItem_1 &#x3D; new JMenuItem(&quot;类别修改&quot;);mntmNewMenuItem_1.addMouseListener(new MouseAdapter() &#123;public void mousePressed(MouseEvent evt) &#123;jf.dispose();new AdminBTypeEdit();&#125;&#125;);mnNewMenu.add(mntmNewMenuItem_1);&#x2F;&#x2F; 添加书籍管理菜单JMenu mnNewMenu_2 &#x3D; new JMenu(&quot;书籍管理&quot;);menuBar.add(mnNewMenu_2);&#x2F;&#x2F; 添加书籍添加菜单JMenuItem mntmNewMenuItem_2 &#x3D; new JMenuItem(&quot;书籍添加&quot;);mntmNewMenuItem_2.addMouseListener(new MouseAdapter() &#123;public void mousePressed(MouseEvent evt) &#123;jf.dispose();new AdminBookAdd();&#125;&#125;);mnNewMenu_2.add(mntmNewMenuItem_2);&#x2F;&#x2F;添加书籍修改菜单JMenuItem mntmNewMenuItem_3 &#x3D; new JMenuItem(&quot;书籍修改&quot;);mntmNewMenuItem_3.addMouseListener(new MouseAdapter() &#123;public void mousePressed(MouseEvent evt) &#123;jf.dispose();new AdminBookEdit();&#125;&#125;);mnNewMenu_2.add(mntmNewMenuItem_3);&#x2F;&#x2F; 添加用户管理菜单JMenu menu1 &#x3D; new JMenu(&quot;用户管理&quot;);menuBar.add(menu1);&#x2F;&#x2F; 添加用户信息菜单JMenuItem mntmNewMenuItem_4 &#x3D; new JMenuItem(&quot;用户信息&quot;);mntmNewMenuItem_4.addMouseListener(new MouseAdapter() &#123;public void mousePressed(MouseEvent evt) &#123;jf.dispose();new AdminUserInfo();&#125;&#125;);menu1.add(mntmNewMenuItem_4);&#x2F;&#x2F; 添加借阅信息菜单JMenuItem mntmNewMenuItem_5 &#x3D; new JMenuItem(&quot;借阅信息&quot;);mntmNewMenuItem_5.addMouseListener(new MouseAdapter() &#123;public void mousePressed(MouseEvent evt) &#123;jf.dispose();new AdminBorrowInfo();&#125;&#125;);menu1.add(mntmNewMenuItem_5);&#x2F;&#x2F; 添加退出系统菜单JMenu mnNewMenu_1 &#x3D; new JMenu(&quot;退出系统&quot;);mnNewMenu_1.addMouseListener(new MouseAdapter() &#123;public void mousePressed(MouseEvent evt) &#123;JOptionPane.showMessageDialog(null, &quot;欢迎再次使用&quot;);jf.dispose();&#125;&#125;);menuBar.add(mnNewMenu_1);&#x2F;&#x2F; 让jf显示，并且可以更改jf大小jf.setVisible(true);jf.setResizable(true);&#125;&#x2F;&#x2F; 清空类别数据public void reset() &#123;textField.setText(&quot;&quot;);textArea.setText(&quot;&quot;);&#125;public static void main(String[] args) &#123;try &#123;BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;BeautyEyeLNFHelper.launchBeautyEyeLNF();&#125; catch (Exception e) &#123;e.printStackTrace();&#125;new AdminMenuFrm();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-2-图书的添加"><a href="#9-2-图书的添加" class="headerlink" title="9.2 图书的添加"></a>9.2 图书的添加</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.sql.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import javax.swing.JFrame;import com.hechaodong.bookmanager.dao.BookTypeDao;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import com.hechaodong.bookmanager.dao.BookDao;import com.hechaodong.bookmanager.model.Book;import com.hechaodong.bookmanager.model.BookType;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import javax.swing.JMenuBar;import javax.swing.JMenu;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.border.TitledBorder;import java.awt.Color;import javax.swing.JLabel;import java.awt.Font;import javax.swing.JTextField;import javax.swing.JButton;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import java.math.BigDecimal;import java.sql.ResultSet;import javax.swing.JComboBox;import javax.swing.ImageIcon;public class AdminBookAdd extends JFrame &#123;    private JFrame jf;    private JTextField textField;    private JTextField textField_1;    private JTextField textField_2;    private JTextField textField_3;    private JTextField textField_4;    private JTextField textField_6;    private JComboBox comboBox;    BookDao bookDao &#x3D; new BookDao();    DbUtil dbUtil &#x3D; new DbUtil();    BookTypeDao bookTypeDao &#x3D; new BookTypeDao();    public AdminBookAdd() &#123;        &#x2F;&#x2F; 初始化书籍添加界面        jf &#x3D; new JFrame(&quot;书籍添加&quot;);        jf.setBounds(650, 250, 600, 378);        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        jf.getContentPane().setLayout(null);        &#x2F;&#x2F; 顶部展示“书籍添加”的JLabel        JPanel panel &#x3D; new JPanel();        panel.setBorder(new TitledBorder(null, &quot;书籍添加&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));        panel.setBounds(23, 21, 540, 275);        jf.getContentPane().add(panel);        panel.setLayout(null);        &#x2F;&#x2F; 初始化展示“书名”的JLabel        JLabel lblNewLabel &#x3D; new JLabel(&quot;书名：&quot;);        lblNewLabel.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        lblNewLabel.setBounds(58, 31, 45, 27);        panel.add(lblNewLabel);        &#x2F;&#x2F; 初始化输入书名的文本框组件        textField &#x3D; new JTextField();        textField.setBounds(101, 31, 129, 27);        panel.add(textField);        textField.setColumns(10);        &#x2F;&#x2F; 初始化展示“作者”的JLabel        JLabel label &#x3D; new JLabel(&quot;作者：&quot;);        label.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label.setBounds(294, 31, 45, 27);        panel.add(label);        &#x2F;&#x2F; 初始化输入作者的文本框组件        textField_1 &#x3D; new JTextField();        textField_1.setColumns(10);        textField_1.setBounds(338, 31, 128, 27);        panel.add(textField_1);        &#x2F;&#x2F; 初始化展示“出版社”的JLabel        JLabel label_1 &#x3D; new JLabel(&quot;出版社：&quot;);        label_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_1.setBounds(43, 79, 60, 27);        panel.add(label_1);        &#x2F;&#x2F; 初始化输入出版社的文本框组件        textField_2 &#x3D; new JTextField();        textField_2.setColumns(10);        textField_2.setBounds(101, 79, 129, 27);        panel.add(textField_2);        &#x2F;&#x2F; 初始化展示“库存”的JLabel        JLabel label_2 &#x3D; new JLabel(&quot;库存：&quot;);        label_2.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_2.setBounds(58, 125, 45, 27);        panel.add(label_2);        &#x2F;&#x2F; 初始化输入库存的文本框组件        textField_3 &#x3D; new JTextField();        textField_3.setColumns(10);        textField_3.setBounds(101, 125, 129, 27);        panel.add(textField_3);        &#x2F;&#x2F; 初始化展示“价格”的JLabel        JLabel label_3 &#x3D; new JLabel(&quot;价格：&quot;);        label_3.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_3.setBounds(294, 79, 45, 27);        panel.add(label_3);        &#x2F;&#x2F; 初始化输入价格的文本框组件        textField_4 &#x3D; new JTextField();        textField_4.setColumns(10);        textField_4.setBounds(337, 79, 129, 27);        panel.add(textField_4);        &#x2F;&#x2F; 初始化展示“类别”的JLabel        JLabel label_4 &#x3D; new JLabel(&quot;类别：&quot;);        label_4.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_4.setBounds(294, 125, 45, 27);        panel.add(label_4);        &#x2F;&#x2F; 初始化展示“描述”的JLabel        JLabel label_5 &#x3D; new JLabel(&quot;描述：&quot;);        label_5.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_5.setBounds(58, 170, 45, 27);        panel.add(label_5);        &#x2F;&#x2F; 初始化输入描述的文本框组件        textField_6 &#x3D; new JTextField();        textField_6.setColumns(10);        textField_6.setBounds(101, 173, 365, 27);        panel.add(textField_6);        &#x2F;&#x2F; 添加按钮        JButton btnNewButton &#x3D; new JButton(&quot;添加&quot;);        &#x2F;&#x2F; 给添加按钮添加一个动作监听器        btnNewButton.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                String bookName &#x3D; textField.getText();                String author &#x3D; textField_1.getText();                String publish &#x3D; textField_2.getText();                String priceStr &#x3D; textField_4.getText();                String numberStr &#x3D; textField_3.getText();                String remark &#x3D; textField_6.getText();                if (ToolUtil.isEmpty(bookName) || ToolUtil.isEmpty(author)                        || ToolUtil.isEmpty(publish) || ToolUtil.isEmpty(priceStr)                        || ToolUtil.isEmpty(numberStr) || ToolUtil.isEmpty(remark)) &#123;                    JOptionPane.showMessageDialog(null, &quot;请输入相关内容&quot;);                    return;                &#125;                BookType selectedItem &#x3D; (BookType) comboBox.getSelectedItem();                Integer typeId &#x3D; selectedItem.getTypeId();                int number;                double price;                try &#123;                    number &#x3D; Integer.parseInt(numberStr);                    price &#x3D; new BigDecimal(priceStr).setScale(2, BigDecimal.ROUND_DOWN)                            .doubleValue();                &#125; catch (Exception e1) &#123;                    JOptionPane.showMessageDialog(null, &quot;参数错误&quot;);                    return;                &#125;                &#x2F;&#x2F; 封装数据                Book book &#x3D; new Book();                book.setBookName(bookName);                book.setAuthor(author);                book.setBookTypeId(typeId);                book.setNumber(number);                book.setPrice(price);                book.setPublish(publish);                book.setRemark(remark);                book.setStatus(1);                Connection con &#x3D; null;                try &#123;                    con &#x3D; dbUtil.getConnection();                    int i &#x3D; bookDao.add(con, book);                    if (i &#x3D;&#x3D; 1) &#123;                        JOptionPane.showMessageDialog(null, &quot;添加成功&quot;);                        reset();                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;添加失败&quot;);                    &#125;                &#125; catch (Exception e1) &#123;                    e1.printStackTrace();                    JOptionPane.showMessageDialog(null, &quot;添加异常&quot;);                &#125;            &#125;        &#125;);        btnNewButton.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        btnNewButton.setBounds(124, 227, 77, 27);        panel.add(btnNewButton);        &#x2F;&#x2F; 重置按钮        JButton button &#x3D; new JButton(&quot;重置&quot;);        button.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                reset();            &#125;        &#125;);        button.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        button.setBounds(329, 229, 77, 27);        panel.add(button);        &#x2F;&#x2F; 类别 文本下拉框        comboBox &#x3D; new JComboBox();        comboBox.setBounds(338, 126, 128, 26);        panel.add(comboBox);        &#x2F;&#x2F; 背景图片        JLabel lblNewLabel_1 &#x3D; new JLabel(&quot;&quot;);        lblNewLabel_1.setIcon(new ImageIcon(&quot;lib&#x2F;images&#x2F;4.png&quot;));        lblNewLabel_1.setBounds(0, -4, 584, 323);        jf.getContentPane().add(lblNewLabel_1);        getBookType();        &#x2F;&#x2F; 初始化菜单栏        JMenuBar menuBar &#x3D; new JMenuBar();        jf.setJMenuBar(menuBar);        JMenu mnNewMenu &#x3D; new JMenu(&quot;类别管理&quot;);        menuBar.add(mnNewMenu);        JMenuItem mntmNewMenuItem &#x3D; new JMenuItem(&quot;类别添加&quot;);        mntmNewMenuItem.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminMenuFrm();            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem);        JMenuItem mntmNewMenuItem_1 &#x3D; new JMenuItem(&quot;类别修改&quot;);        mntmNewMenuItem_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBTypeEdit();            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem_1);        JMenu mnNewMenu_2 &#x3D; new JMenu(&quot;书籍管理&quot;);        menuBar.add(mnNewMenu_2);        JMenuItem mntmNewMenuItem_2 &#x3D; new JMenuItem(&quot;书籍添加&quot;);        mnNewMenu_2.add(mntmNewMenuItem_2);        JMenuItem mntmNewMenuItem_3 &#x3D; new JMenuItem(&quot;书籍修改&quot;);        mntmNewMenuItem_3.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBookEdit();            &#125;        &#125;);        mnNewMenu_2.add(mntmNewMenuItem_3);        JMenu menu1 &#x3D; new JMenu(&quot;用户管理&quot;);        menuBar.add(menu1);        JMenuItem mntmNewMenuItem_4 &#x3D; new JMenuItem(&quot;用户信息&quot;);        mntmNewMenuItem_4.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminUserInfo();            &#125;        &#125;);        menu1.add(mntmNewMenuItem_4);        JMenuItem mntmNewMenuItem_5 &#x3D; new JMenuItem(&quot;借阅信息&quot;);        mntmNewMenuItem_5.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBorrowInfo();            &#125;        &#125;);        menu1.add(mntmNewMenuItem_5);        JMenu mnNewMenu_1 &#x3D; new JMenu(&quot;退出系统&quot;);        mnNewMenu_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                JOptionPane.showMessageDialog(null, &quot;欢迎再次使用&quot;);                jf.dispose();            &#125;        &#125;);        menuBar.add(mnNewMenu_1);        jf.setVisible(true);        jf.setResizable(true);    &#125;    &#x2F;&#x2F; 清空数据    public void reset() &#123;        textField.setText(&quot;&quot;);        textField_1.setText(&quot;&quot;);        textField_2.setText(&quot;&quot;);        textField_3.setText(&quot;&quot;);        textField_4.setText(&quot;&quot;);        textField_6.setText(&quot;&quot;);    &#125;    public void getBookType() &#123;        &#x2F;&#x2F; 获取连接对象        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            ResultSet list &#x3D; bookTypeDao.list(con, new BookType());            while (list.next()) &#123;                BookType bookType &#x3D; new BookType();                bookType.setTypeId(list.getInt(&quot;id&quot;));                bookType.setTypeName(list.getString(&quot;type_name&quot;));                comboBox.addItem(bookType);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;            org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper.launchBeautyEyeLNF();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        new AdminBookAdd();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-3-图书信息的修改"><a href="#9-3-图书信息的修改" class="headerlink" title="9.3 图书信息的修改"></a>9.3 图书信息的修改</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.sql.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import javax.swing.JFrame;import com.hechaodong.bookmanager.dao.BookTypeDao;import com.hechaodong.bookmanager.model.BookType;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import com.hechaodong.bookmanager.dao.BookDao;import com.hechaodong.bookmanager.model.Book;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import javax.swing.JMenuBar;import javax.swing.JMenu;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTable;import javax.swing.border.TitledBorder;import javax.swing.table.DefaultTableModel;import java.awt.Color;import javax.swing.JLabel;import javax.swing.JComboBox;import java.awt.Font;import java.math.BigDecimal;import java.sql.ResultSet;import java.util.Vector;import javax.swing.JTextField;import javax.swing.JButton;import javax.swing.UIManager;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import javax.swing.ImageIcon;public class AdminBookEdit extends JFrame &#123;    private JFrame jf;    private JTextField textField;    private JTable table;    private DefaultTableModel model;    private JTextField textField_1;    private JTextField textField_2;    private JTextField textField_3;    private JTextField textField_4;    private JTextField textField_5;    private JTextField textField_6;    private JTextField textField_7;    private JComboBox comboBox;    private JComboBox comboBox_1;    private JComboBox comboBox_2;    private DbUtil dbUtil &#x3D; new DbUtil();    private BookDao bookDao &#x3D; new BookDao();    private BookTypeDao bookTypeDao &#x3D; new BookTypeDao();    public AdminBookEdit() &#123;        &#x2F;&#x2F; 初始化书籍修改界面        jf &#x3D; new JFrame(&quot;书籍修改&quot;);        jf.setBounds(650, 250, 600, 672);        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        &#x2F;&#x2F; 初始化菜单栏        JMenuBar menuBar &#x3D; new JMenuBar();        jf.setJMenuBar(menuBar);        &#x2F;&#x2F; 类别管理        JMenu mnNewMenu &#x3D; new JMenu(&quot;类别管理&quot;);        menuBar.add(mnNewMenu);        JMenuItem mntmNewMenuItem &#x3D; new JMenuItem(&quot;类别添加&quot;);        mntmNewMenuItem.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminMenuFrm();            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem);        JMenuItem mntmNewMenuItem_1 &#x3D; new JMenuItem(&quot;类别修改&quot;);        mntmNewMenuItem_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBTypeEdit();            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem_1);        &#x2F;&#x2F; 书籍管理        JMenu mnNewMenu_2 &#x3D; new JMenu(&quot;书籍管理&quot;);        menuBar.add(mnNewMenu_2);        JMenuItem mntmNewMenuItem_2 &#x3D; new JMenuItem(&quot;书籍添加&quot;);        mntmNewMenuItem_2.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBookAdd();            &#125;        &#125;);        mnNewMenu_2.add(mntmNewMenuItem_2);        JMenuItem mntmNewMenuItem_3 &#x3D; new JMenuItem(&quot;书籍修改&quot;);        mnNewMenu_2.add(mntmNewMenuItem_3);        &#x2F;&#x2F; 用户管理        JMenu menu1 &#x3D; new JMenu(&quot;用户管理&quot;);        menuBar.add(menu1);        JMenuItem mntmNewMenuItem_4 &#x3D; new JMenuItem(&quot;用户信息&quot;);        mntmNewMenuItem_4.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminUserInfo();            &#125;        &#125;);        menu1.add(mntmNewMenuItem_4);        JMenuItem mntmNewMenuItem_5 &#x3D; new JMenuItem(&quot;借阅信息&quot;);        mntmNewMenuItem_5.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBorrowInfo();            &#125;        &#125;);        menu1.add(mntmNewMenuItem_5);        &#x2F;&#x2F; 退出系统        JMenu mnNewMenu_1 &#x3D; new JMenu(&quot;退出系统&quot;);        mnNewMenu_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                JOptionPane.showMessageDialog(null, &quot;欢迎再次使用&quot;);                jf.dispose();            &#125;        &#125;);        menuBar.add(mnNewMenu_1);        jf.getContentPane().setLayout(null);        &#x2F;&#x2F; 顶部展示“书目查询”的JLabel        JPanel panel &#x3D; new JPanel();        panel.setBorder(new TitledBorder(null, &quot;书目查询&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));        panel.setBounds(20, 10, 541, 78);        jf.getContentPane().add(panel);        panel.setLayout(null);        &#x2F;&#x2F; 下拉框选项        comboBox &#x3D; new JComboBox();        comboBox.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        comboBox.setBounds(55, 28, 109, 24);        comboBox.addItem(&quot;书籍名称&quot;);        comboBox.addItem(&quot;书籍作者&quot;);        panel.add(comboBox);        &#x2F;&#x2F; 初始化查询所对应的文本框        textField &#x3D; new JTextField();        textField.setBounds(185, 28, 146, 24);        panel.add(textField);        textField.setColumns(10);        &#x2F;&#x2F; 查询按钮        JButton btnNewButton &#x3D; new JButton(&quot;查询&quot;);        btnNewButton.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                int index &#x3D; comboBox.getSelectedIndex();                if (index &#x3D;&#x3D; 0) &#123;                    String bookName &#x3D; textField.getText();                    Book book &#x3D; new Book();                    book.setBookName(bookName);                    putDates(book);                &#125; else &#123;                    String authoerName &#x3D; textField.getText();                    Book book &#x3D; new Book();                    book.setAuthor(authoerName);                    putDates(book);                &#125;            &#125;        &#125;);        btnNewButton.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        btnNewButton.setBounds(352, 28, 81, 25);        panel.add(btnNewButton);        &#x2F;&#x2F; 中部展示“书籍信息”的JLabel        JPanel panel_1 &#x3D; new JPanel();        panel_1.setLayout(null);        panel_1.setBorder(new TitledBorder(UIManager.getBorder(&quot;TitledBorder.border&quot;), &quot;书籍信息&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, new Color(255, 0, 0)));        panel_1.setBounds(20, 105, 541, 195);        &#x2F;&#x2F; 表头栏数据  一位数组        String[] title &#x3D; &#123;&quot;编号&quot;, &quot;书名&quot;, &quot;类别&quot;, &quot;作者&quot;, &quot;价格&quot;, &quot;库存&quot;, &quot;状态&quot;&#125;;        &#x2F;&#x2F; 具体的各栏行记录 先用空的二位数组占位        String[][] dates &#x3D; &#123;&#125;;        &#x2F;&#x2F; 创建数据模型，实例化上面2个控件对象        model &#x3D; new DefaultTableModel(dates, title);        table &#x3D; new JTable(model);        &#x2F;&#x2F; 获取数据库数据放置table中        putDates(new Book());        panel_1.setLayout(null);        JScrollPane jscrollpane &#x3D; new JScrollPane();        jscrollpane.setBounds(20, 22, 496, 154);        jscrollpane.setViewportView(table);        panel_1.add(jscrollpane);        jf.getContentPane().add(panel_1);        &#x2F;&#x2F; 给表格添加一个鼠标监听器        table.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                tableMousePressed(evt);            &#125;        &#125;);        &#x2F;&#x2F; 创建一个Panel对象        JPanel panel_2 &#x3D; new JPanel();        panel_2.setBounds(20, 310, 541, 292);        jf.getContentPane().add(panel_2);        panel_2.setLayout(null);        &#x2F;&#x2F; 初始化展示“编号”的JLabel        JLabel label &#x3D; new JLabel(&quot;编号：&quot;);        label.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label.setBounds(58, 10, 45, 27);        panel_2.add(label);        &#x2F;&#x2F; 初始化输入编号的文本框组件        textField_1 &#x3D; new JTextField();        textField_1.setColumns(10);        textField_1.setBounds(101, 10, 129, 27);        panel_2.add(textField_1);        &#x2F;&#x2F; 初始化展示“书名”的JLabel        JLabel label_1 &#x3D; new JLabel(&quot;书名：&quot;);        label_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_1.setBounds(294, 10, 45, 27);        panel_2.add(label_1);        &#x2F;&#x2F; 初始化输入书名的文本框组件        textField_2 &#x3D; new JTextField();        textField_2.setColumns(10);        textField_2.setBounds(338, 10, 128, 27);        panel_2.add(textField_2);        &#x2F;&#x2F; 初始化展示“作者”的JLabel        JLabel label_2 &#x3D; new JLabel(&quot;作者：&quot;);        label_2.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_2.setBounds(58, 58, 45, 27);        panel_2.add(label_2);        &#x2F;&#x2F; 初始化输入作者的文本框组件        textField_3 &#x3D; new JTextField();        textField_3.setColumns(10);        textField_3.setBounds(101, 58, 129, 27);        panel_2.add(textField_3);        &#x2F;&#x2F; 价格 JLabel        JLabel label_3 &#x3D; new JLabel(&quot;价格：&quot;);        label_3.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_3.setBounds(58, 104, 45, 27);        panel_2.add(label_3);        textField_4 &#x3D; new JTextField();        textField_4.setColumns(10);        textField_4.setBounds(101, 104, 129, 27);        panel_2.add(textField_4);        &#x2F;&#x2F; 出版 JLabel        JLabel label_4 &#x3D; new JLabel(&quot;出版：&quot;);        label_4.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_4.setBounds(294, 58, 45, 27);        panel_2.add(label_4);        textField_5 &#x3D; new JTextField();        textField_5.setColumns(10);        textField_5.setBounds(337, 58, 129, 27);        panel_2.add(textField_5);        &#x2F;&#x2F; 类别 JLabel        JLabel label_5 &#x3D; new JLabel(&quot;类别：&quot;);        label_5.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_5.setBounds(58, 189, 45, 27);        panel_2.add(label_5);        &#x2F;&#x2F; “类别”下拉选择框        comboBox_1 &#x3D; new JComboBox();        comboBox_1.setBounds(102, 190, 128, 26);        &#x2F;&#x2F;获取类别        getBookType();        panel_2.add(comboBox_1);        &#x2F;&#x2F; 库存 JLabel        JLabel label_6 &#x3D; new JLabel(&quot;库存：&quot;);        label_6.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_6.setBounds(294, 104, 45, 27);        panel_2.add(label_6);        textField_6 &#x3D; new JTextField();        textField_6.setColumns(10);        textField_6.setBounds(337, 104, 129, 27);        panel_2.add(textField_6);        &#x2F;&#x2F; 描述 JLabel        JLabel label_7 &#x3D; new JLabel(&quot;描述：&quot;);        label_7.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_7.setBounds(58, 152, 45, 27);        panel_2.add(label_7);        textField_7 &#x3D; new JTextField();        textField_7.setColumns(10);        textField_7.setBounds(101, 152, 365, 27);        panel_2.add(textField_7);        &#x2F;&#x2F; 状态 JLabel        JLabel label_8 &#x3D; new JLabel(&quot;状态：&quot;);        label_8.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_8.setBounds(294, 190, 45, 27);        panel_2.add(label_8);        comboBox_2 &#x3D; new JComboBox();        comboBox_2.setBounds(338, 191, 128, 26);        comboBox_2.addItem(&quot;上架&quot;);        comboBox_2.addItem(&quot;下架&quot;);        panel_2.add(comboBox_2);&#x2F;&#x2F; 修改按钮        JButton btnNewButton_1 &#x3D; new JButton(&quot;修改&quot;);        btnNewButton_1.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 获取文本框组件中的相关数据                String bookName &#x3D; textField_2.getText();                String author &#x3D; textField_3.getText();                String priceStr &#x3D; textField_4.getText();                String publish &#x3D; textField_5.getText();                String numberStr &#x3D; textField_6.getText();                String remark &#x3D; textField_7.getText();                String bookId &#x3D; textField_1.getText();                &#x2F;&#x2F; 对数据进行校验                if (ToolUtil.isEmpty(bookId) || ToolUtil.isEmpty(bookName)                        || ToolUtil.isEmpty(author) || ToolUtil.isEmpty(publish)                        || ToolUtil.isEmpty(priceStr)                        || ToolUtil.isEmpty(numberStr) || ToolUtil.isEmpty(remark)) &#123;                    JOptionPane.showMessageDialog(null, &quot;请输入相关内容&quot;);                    return;                &#125;                &#x2F;&#x2F; 获取图书的类别数据                BookType bookType &#x3D; (BookType) comboBox_1.getSelectedItem();                Integer typeId &#x3D; bookType.getTypeId();                int index &#x3D; comboBox_2.getSelectedIndex();                &#x2F;&#x2F; 对库存数据价格数据进行处理                int number;                double price;                try &#123;                    number &#x3D; Integer.parseInt(numberStr);                    price &#x3D; new BigDecimal(priceStr).setScale(2, BigDecimal.ROUND_DOWN).doubleValue();                &#125; catch (Exception e1) &#123;                    JOptionPane.showMessageDialog(null, &quot;参数错误&quot;);                    return;                &#125;                &#x2F;&#x2F; 创建Book对象进行数据封装                Book book &#x3D; new Book();                book.setBookId(Integer.parseInt(bookId));                book.setBookName(bookName);                book.setAuthor(author);                book.setBookTypeId(typeId);                book.setNumber(number);                book.setPrice(price);                book.setPublish(publish);                book.setRemark(remark);                book.setStatus(1);                &#x2F;&#x2F; 判断上架下架状态                if (index &#x3D;&#x3D; 0) &#123;                    book.setStatus(1);                &#125; else if (index &#x3D;&#x3D; 1) &#123;                    book.setStatus(2);                &#125;                &#x2F;&#x2F; 获取连接对象                Connection con &#x3D; null;                try &#123;                    con &#x3D; dbUtil.getConnection();                    int i &#x3D; bookDao.update(con, book);                    &#x2F;&#x2F; 判断                    if (i &#x3D;&#x3D; 1) &#123;                        JOptionPane.showMessageDialog(null, &quot;修改成功&quot;);                        putDates(new Book()); &#x2F;&#x2F;+++++++                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;修改失败&quot;);                    &#125;                &#125; catch (Exception e1) &#123;                    e1.printStackTrace();                    JOptionPane.showMessageDialog(null, &quot;修改异常&quot;);                &#125; finally &#123;                    try &#123;                        dbUtil.closeCon(con);                    &#125; catch (Exception e1) &#123;                        e1.printStackTrace();                    &#125;                &#125;                putDates(new Book());            &#125;        &#125;);        &#x2F;&#x2F; 修改按钮        btnNewButton_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        btnNewButton_1.setBounds(304, 235, 93, 35);        panel_2.add(btnNewButton_1);        &#x2F;&#x2F; 背景图片        JLabel lblNewLabel &#x3D; new JLabel(&quot;&quot;);        lblNewLabel.setIcon(new ImageIcon(&quot;lib&#x2F;images&#x2F;5.png&quot;));        lblNewLabel.setBounds(0, 0, 584, 613);        jf.getContentPane().add(lblNewLabel);        jf.setVisible(true);        jf.setResizable(true);    &#125;    &#x2F;&#x2F; 获取图书类型    public void getBookType() &#123;        &#x2F;&#x2F; 获取连接对象        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            ResultSet list &#x3D; bookTypeDao.list(con, new BookType());            while (list.next()) &#123;                BookType bookType &#x3D; new BookType();                bookType.setTypeId(list.getInt(&quot;id&quot;));                bookType.setTypeName(list.getString(&quot;type_name&quot;));                System.out.println(bookType);                &#x2F;*                 * 添加图书中类别设置                 * *&#x2F;                comboBox_1.addItem(bookType);&#x2F;&#x2F;                comboBox_1.addItem(String.valueOf(bookType.getTypeName()));            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    &#x2F;&#x2F;点击表格获取数据    public void tableMousePressed(MouseEvent evt) &#123;        int row &#x3D; table.getSelectedRow();        Integer bookId &#x3D; (Integer) table.getValueAt(row, 0);        Book book &#x3D; new Book();        book.setBookId(bookId);        &#x2F;&#x2F; 获取连接对象        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            ResultSet list &#x3D; bookDao.list(con, book);            if (list.next()) &#123;                textField_1.setText(list.getString(&quot;id&quot;));                textField_2.setText(list.getString(&quot;book_name&quot;));                textField_3.setText(list.getString(&quot;author&quot;));                textField_5.setText(list.getString(&quot;publish&quot;));                textField_4.setText(list.getString(&quot;price&quot;));                textField_6.setText(list.getString(&quot;number&quot;));                textField_7.setText(list.getString(&quot;remark&quot;));                int status &#x3D; list.getInt(&quot;status&quot;);                if (status &#x3D;&#x3D; 1) &#123;                    comboBox_2.setSelectedIndex(0);                &#125; else &#123;                    comboBox_2.setSelectedIndex(1);                &#125;                int typeId &#x3D; list.getInt(&quot;type_id&quot;);                int count &#x3D; comboBox_1.getItemCount();                for (int i &#x3D; 0; i &lt; count; i++) &#123;                    BookType bookType &#x3D; (BookType) comboBox_1.getItemAt(i);                    if (bookType.getTypeId() &#x3D;&#x3D; typeId) &#123;                        comboBox_1.setSelectedIndex(i);                    &#125;                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    &#x2F;&#x2F; 从数据库中获取数据    private void putDates(Book book) &#123;        DefaultTableModel model &#x3D; (DefaultTableModel) table.getModel();        model.setRowCount(0);        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            ResultSet resultSet &#x3D; bookDao.list(con, book);            while (resultSet.next()) &#123;                Vector rowData &#x3D; new Vector();                rowData.add(resultSet.getInt(&quot;id&quot;));                rowData.add(resultSet.getString(&quot;book_name&quot;));                rowData.add(resultSet.getString(&quot;type_name&quot;));                rowData.add(resultSet.getString(&quot;author&quot;));                rowData.add(resultSet.getDouble(&quot;price&quot;));                rowData.add(resultSet.getInt(&quot;number&quot;));                if (resultSet.getInt(&quot;status&quot;) &#x3D;&#x3D; 1) &#123;                    rowData.add(&quot;上架&quot;);                &#125; else &#123;                    rowData.add(&quot;下架&quot;);                &#125;                model.addRow(rowData);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;            BeautyEyeLNFHelper.launchBeautyEyeLNF();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        new AdminBookEdit();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-4-图书类型的修改"><a href="#9-4-图书类型的修改" class="headerlink" title="9.4 图书类型的修改"></a>9.4 图书类型的修改</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.sql.*;import java.awt.Color;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.sql.ResultSet;import java.util.Vector;import javax.swing.JFrame;import com.hechaodong.bookmanager.dao.BookTypeDao;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import com.hechaodong.bookmanager.model.BookType;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import javax.swing.JMenuBar;import javax.swing.JMenu;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTable;import javax.swing.UIManager;import javax.swing.border.TitledBorder;import javax.swing.table.DefaultTableModel;import javax.swing.JLabel;import java.awt.Font;import javax.swing.JTextField;import javax.swing.JButton;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import javax.swing.ImageIcon;public class AdminBTypeEdit extends JFrame &#123;    private JFrame jf;    private JTable table;    private DefaultTableModel model;    private JTextField textField;    private JTextField textField_1;    private JTextField textField_2;    private DbUtil dbUtil &#x3D; new DbUtil();    private BookTypeDao bookTypeDao &#x3D; new BookTypeDao();    public AdminBTypeEdit() &#123;        &#x2F;&#x2F; 初始化类别修改界面        jf &#x3D; new JFrame(&quot;类别修改&quot;);        jf.setBounds(650, 250, 611, 472);        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        jf.getContentPane().setLayout(null);        JMenuBar menuBar &#x3D; new JMenuBar();        jf.setJMenuBar(menuBar);        JMenu mnNewMenu &#x3D; new JMenu(&quot;类别管理&quot;);        menuBar.add(mnNewMenu);        JMenuItem mntmNewMenuItem &#x3D; new JMenuItem(&quot;类别添加&quot;);        mntmNewMenuItem.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminMenuFrm();            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem);        JMenuItem mntmNewMenuItem_1 &#x3D; new JMenuItem(&quot;类别修改&quot;);        mnNewMenu.add(mntmNewMenuItem_1);        JMenu mnNewMenu_2 &#x3D; new JMenu(&quot;书籍管理&quot;);        menuBar.add(mnNewMenu_2);        JMenuItem mntmNewMenuItem_2 &#x3D; new JMenuItem(&quot;书籍添加&quot;);        mntmNewMenuItem_2.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBookAdd();            &#125;        &#125;);        mnNewMenu_2.add(mntmNewMenuItem_2);        JMenuItem mntmNewMenuItem_3 &#x3D; new JMenuItem(&quot;书籍修改&quot;);        mntmNewMenuItem_3.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBookEdit();            &#125;        &#125;);        mnNewMenu_2.add(mntmNewMenuItem_3);        JMenu menu1 &#x3D; new JMenu(&quot;用户管理&quot;);        menuBar.add(menu1);        JMenuItem mntmNewMenuItem_4 &#x3D; new JMenuItem(&quot;用户信息&quot;);        mntmNewMenuItem_4.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminUserInfo();            &#125;        &#125;);        menu1.add(mntmNewMenuItem_4);        JMenuItem mntmNewMenuItem_5 &#x3D; new JMenuItem(&quot;借阅信息&quot;);        mntmNewMenuItem_5.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBorrowInfo();            &#125;        &#125;);        menu1.add(mntmNewMenuItem_5);        JMenu mnNewMenu_1 &#x3D; new JMenu(&quot;退出系统&quot;);        mnNewMenu_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                JOptionPane.showMessageDialog(null, &quot;欢迎再次使用&quot;);                jf.dispose();            &#125;        &#125;);        menuBar.add(mnNewMenu_1);        &#x2F;&#x2F; 顶部展示“类别信息”的JLabel        JPanel panel_1 &#x3D; new JPanel();        panel_1.setBorder(new TitledBorder(UIManager.getBorder(&quot;TitledBorder.border&quot;), &quot;类别信息&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, new Color(255, 0, 0)));        panel_1.setBounds(20, 10, 554, 208);        &#x2F;&#x2F; 表头栏数据        String[] title &#x3D; &#123;&quot;编号&quot;, &quot;类别名称&quot;, &quot;类别描述&quot;&#125;;        &#x2F;&#x2F;具体的各栏行记录 先用空的二位数组占位        String[][] dates &#x3D; &#123;&#125;;        &#x2F;&#x2F; 创建数据模型，实例化上面2个控件对象        model &#x3D; new DefaultTableModel(dates, title);        table &#x3D; new JTable(model);        &#x2F;&#x2F;获取数据库数据放置table中        putDates();        panel_1.setLayout(null);        JScrollPane jscrollpane &#x3D; new JScrollPane();        jscrollpane.setBounds(20, 22, 517, 163);        jscrollpane.setViewportView(table);        panel_1.add(jscrollpane);        jf.getContentPane().add(panel_1);        &#x2F;&#x2F; 底部展示“类别编辑”的JLabel        JPanel panel &#x3D; new JPanel();        panel.setBorder(new TitledBorder(null, &quot;类别编辑&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));        panel.setBounds(20, 228, 554, 168);        jf.getContentPane().add(panel);        panel.setLayout(null);        table.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                typeTableMousePressed(evt);            &#125;        &#125;);        &#x2F;&#x2F; 编号 JLabel        JLabel lblNewLabel &#x3D; new JLabel(&quot;编号：&quot;);        lblNewLabel.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        lblNewLabel.setBounds(73, 26, 45, 28);        panel.add(lblNewLabel);        &#x2F;&#x2F; 编号 文本框        textField &#x3D; new JTextField();        textField.setBounds(116, 30, 92, 24);        panel.add(textField);        textField.setColumns(10);        &#x2F;&#x2F; 类别名称 JLabel        JLabel label &#x3D; new JLabel(&quot;类别名称：&quot;);        label.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label.setBounds(238, 26, 75, 28);        panel.add(label);        &#x2F;&#x2F; 类别名称 文本框        textField_1 &#x3D; new JTextField();        textField_1.setColumns(10);        textField_1.setBounds(314, 30, 122, 24);        panel.add(textField_1);        &#x2F;&#x2F; 描述 JLabel        JLabel label_1 &#x3D; new JLabel(&quot;描述：&quot;);        label_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        label_1.setBounds(73, 65, 45, 28);        panel.add(label_1);        &#x2F;&#x2F; 描述 文本框        textField_2 &#x3D; new JTextField();        textField_2.setColumns(10);        textField_2.setBounds(116, 69, 320, 24);        panel.add(textField_2);        &#x2F;&#x2F; 修改按钮        JButton btnNewButton &#x3D; new JButton(&quot;修改&quot;);        &#x2F;&#x2F; 给修改按钮添加一个事件监听器        btnNewButton.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 获取信息                String typeId &#x3D; textField.getText();                String typeName &#x3D; textField_1.getText();                String typeRemark &#x3D; textField_2.getText();                if (ToolUtil.isEmpty(typeName) || ToolUtil.isEmpty(typeRemark)) &#123;                    JOptionPane.showMessageDialog(null, &quot;请输入相关信息&quot;);                    return;                &#125;                &#x2F;&#x2F; 封装数据BookType                BookType bookType &#x3D; new BookType();                bookType.setTypeId(Integer.parseInt(typeId));                bookType.setTypeName(typeName);                bookType.setRemark(typeRemark);                &#x2F;&#x2F; 获取连接对象                Connection con &#x3D; null;                try &#123;                    con &#x3D; dbUtil.getConnection();                    int i &#x3D; bookTypeDao.update(con, bookType);                    if (i &#x3D;&#x3D; 1) &#123;                        JOptionPane.showMessageDialog(null, &quot;修改成功&quot;);                        putDates();                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;修改失败&quot;);                    &#125;                &#125; catch (Exception e1) &#123;                    e1.printStackTrace();                    JOptionPane.showMessageDialog(null, &quot;修改异常&quot;);                &#125; finally &#123;                    try &#123;                        dbUtil.closeCon(con);                    &#125; catch (Exception e1) &#123;                        e1.printStackTrace();                    &#125;                &#125;            &#125;        &#125;);        btnNewButton.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        btnNewButton.setBounds(128, 117, 93, 28);        panel.add(btnNewButton);        &#x2F;&#x2F; 删除按钮        JButton button &#x3D; new JButton(&quot;删除&quot;);        &#x2F;&#x2F; 给删除按钮添加事件监听器        button.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                &#x2F;&#x2F; 获取数据                String typeId &#x3D; textField.getText();                if (ToolUtil.isEmpty(typeId)) &#123;                    JOptionPane.showMessageDialog(null, &quot;请选择相关信息&quot;);                    return;                &#125;                &#x2F;&#x2F; 获取连接对象                Connection con &#x3D; null;                try &#123;                    con &#x3D; dbUtil.getConnection();                    int i &#x3D; bookTypeDao.delete(con, typeId);                    if (i &#x3D;&#x3D; 1) &#123;                        JOptionPane.showMessageDialog(null, &quot;删除成功&quot;);                        putDates();                    &#125; else if (i &#x3D;&#x3D; 2) &#123;                        JOptionPane.showMessageDialog(null, &quot;删除失败-类别最少保留一个&quot;);                    &#125; else if (i &#x3D;&#x3D; 3) &#123;                        JOptionPane.showMessageDialog(null, &quot;删除失败-该类别下有书籍&quot;);                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;删除失败&quot;);                    &#125;                &#125; catch (Exception e1) &#123;                    e1.printStackTrace();                    JOptionPane.showMessageDialog(null, &quot;删除异常&quot;);                &#125; finally &#123;                    try &#123;                        dbUtil.closeCon(con);                    &#125; catch (Exception e1) &#123;                        e1.printStackTrace();                    &#125;                &#125;            &#125;        &#125;);        button.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        button.setBounds(314, 117, 93, 28);        panel.add(button);        &#x2F;&#x2F; 背景图片        JLabel lblNewLabel_1 &#x3D; new JLabel(&quot;&quot;);        lblNewLabel_1.setIcon(new ImageIcon(&quot;lib&#x2F;images&#x2F;5.png&quot;));        lblNewLabel_1.setBounds(0, 0, 595, 413);        jf.getContentPane().add(lblNewLabel_1);        &#x2F;&#x2F; 显示        jf.setVisible(true);        jf.setResizable(false);    &#125;    &#x2F;&#x2F; 点击表格获取信息    protected void typeTableMousePressed(MouseEvent evt) &#123;        int row &#x3D; table.getSelectedRow();        textField.setText(table.getValueAt(row, 0).toString());        textField_1.setText(table.getValueAt(row, 1).toString());        textField_2.setText(table.getValueAt(row, 2).toString());    &#125;    &#x2F;&#x2F; 将图书类型信息显示在表格中    public void putDates() &#123;        DefaultTableModel model &#x3D; (DefaultTableModel) table.getModel();        model.setRowCount(0);        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            ResultSet list &#x3D; bookTypeDao.list(con, new BookType());            while (list.next()) &#123; &#x2F;&#x2F; 遍历&quot;list&quot;对象中的每一行数据，将其转换为一个Vector对象                Vector rowData &#x3D; new Vector();                rowData.add(list.getInt(&quot;id&quot;));                rowData.add(list.getString(&quot;type_name&quot;));                rowData.add(list.getString(&quot;remark&quot;));                model.addRow(rowData);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;            BeautyEyeLNFHelper.launchBeautyEyeLNF();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        new AdminBTypeEdit();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-用户管理模块"><a href="#10-用户管理模块" class="headerlink" title="10. 用户管理模块"></a>10. 用户管理模块</h2><h3 id="10-1-用户信息"><a href="#10-1-用户信息" class="headerlink" title="10.1 用户信息"></a>10.1 用户信息</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.sql.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import javax.swing.JFrame;import com.hechaodong.bookmanager.dao.UserDao;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import com.hechaodong.bookmanager.model.User;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import javax.swing.JMenuBar;import javax.swing.JMenu;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTable;import javax.swing.UIManager;import javax.swing.border.TitledBorder;import javax.swing.table.DefaultTableModel;import java.awt.Color;import javax.swing.JLabel;import java.awt.Font;import java.sql.ResultSet;import java.util.Vector;import javax.swing.JTextField;import javax.swing.JButton;import java.awt.event.ActionListener;import java.awt.event.ActionEvent;import javax.swing.ImageIcon;&#x2F;&#x2F; 用户信息public class AdminUserInfo extends JFrame &#123;    private JFrame jf;    private JTextField textField;    private JTable table;    private DefaultTableModel model;    private JTextField textField_1;    private JTextField textField_2;    private JTextField textField_3;    private JTextField textField_4;    private JTextField textField_5;    private DbUtil dbUtil &#x3D; new DbUtil();    private UserDao userDao &#x3D; new UserDao();    public AdminUserInfo() &#123;        &#x2F;&#x2F; 初始化用户信息界面        jf &#x3D; new JFrame(&quot;用户信息&quot;);        jf.setBounds(650, 250, 600, 516);        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        jf.getContentPane().setLayout(null);        &#x2F;&#x2F; 创建一个菜单栏        JMenuBar menuBar &#x3D; new JMenuBar();        jf.setJMenuBar(menuBar);        JMenu mnNewMenu &#x3D; new JMenu(&quot;类别管理&quot;);        menuBar.add(mnNewMenu);        JMenuItem mntmNewMenuItem &#x3D; new JMenuItem(&quot;类别添加&quot;);        mntmNewMenuItem.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminMenuFrm();&#x2F;&#x2F; 类别添加（默认主界面）            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem);        JMenuItem mntmNewMenuItem_1 &#x3D; new JMenuItem(&quot;类别修改&quot;);        mntmNewMenuItem_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBTypeEdit();&#x2F;&#x2F; 类别修改            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem_1);        JMenu mnNewMenu_2 &#x3D; new JMenu(&quot;书籍管理&quot;);        menuBar.add(mnNewMenu_2);        JMenuItem mntmNewMenuItem_2 &#x3D; new JMenuItem(&quot;书籍添加&quot;);        mntmNewMenuItem_2.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBookAdd();&#x2F;&#x2F; 书籍添加            &#125;        &#125;);        mnNewMenu_2.add(mntmNewMenuItem_2);        JMenuItem mntmNewMenuItem_3 &#x3D; new JMenuItem(&quot;书籍修改&quot;);        mntmNewMenuItem_3.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBookEdit();&#x2F;&#x2F; 书籍修改            &#125;        &#125;);        mnNewMenu_2.add(mntmNewMenuItem_3);        JMenu menu1 &#x3D; new JMenu(&quot;用户管理&quot;);        menuBar.add(menu1);        JMenuItem mntmNewMenuItem_4 &#x3D; new JMenuItem(&quot;用户信息&quot;);        menu1.add(mntmNewMenuItem_4);        JMenuItem mntmNewMenuItem_5 &#x3D; new JMenuItem(&quot;借阅信息&quot;);        mntmNewMenuItem_5.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBorrowInfo();&#x2F;&#x2F; 借阅信息            &#125;        &#125;);        menu1.add(mntmNewMenuItem_5);        JMenu mnNewMenu_1 &#x3D; new JMenu(&quot;退出系统&quot;);        mnNewMenu_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                JOptionPane.showMessageDialog(null, &quot;欢迎再次使用&quot;);                jf.dispose();            &#125;        &#125;);        menuBar.add(mnNewMenu_1);        &#x2F;&#x2F; 顶部展示“借阅信息”的JLabel        JPanel panel &#x3D; new JPanel();        panel.setBorder(new TitledBorder(null, &quot;借阅信息&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));        panel.setBounds(20, 10, 540, 74);        jf.getContentPane().add(panel);        panel.setLayout(null);        &#x2F;&#x2F; 初始化展示“用户名”的JLabel        JLabel lblNewLabel &#x3D; new JLabel(&quot;用户名：&quot;);        lblNewLabel.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        lblNewLabel.setBounds(57, 22, 60, 30);        panel.add(lblNewLabel);        &#x2F;&#x2F; 初始化用户名所对应的文本框组件        textField &#x3D; new JTextField();        textField.setBounds(127, 27, 155, 25);        panel.add(textField);        textField.setColumns(10);        &#x2F;&#x2F; 查询按钮        JButton btnNewButton &#x3D; new JButton(&quot;查询&quot;);        btnNewButton.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;                String userName &#x3D; textField.getText();&#x2F;&#x2F; 获取查询信息                User user &#x3D; new User();                user.setUserName(userName);                putDates(user);            &#125;        &#125;);        btnNewButton.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 14));        btnNewButton.setBounds(316, 26, 93, 23);        panel.add(btnNewButton);        &#x2F;&#x2F; 中部展示”用户信息“的JLabel        JPanel panel_1 &#x3D; new JPanel();        panel_1.setLayout(null);        panel_1.setBorder(new TitledBorder(UIManager.getBorder(&quot;TitledBorder.border&quot;), &quot;用户信息&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, new Color(255, 0, 0)));        panel_1.setBounds(20, 94, 541, 195);        &#x2F;&#x2F; 表头栏数据        String[] title &#x3D; &#123;&quot;编号&quot;, &quot;用户名&quot;, &quot;密码&quot;, &quot;性别&quot;, &quot;电话&quot;&#125;;        &#x2F;&#x2F; 具体的各栏行记录 先用空的二位数组占位        String[][] dates &#x3D; &#123;&#125;;        &#x2F;&#x2F;创建数据模型，实例化上面2个控件对象        model &#x3D; new DefaultTableModel(dates, title);        table &#x3D; new JTable(model);        &#x2F;&#x2F;获取数据库数据放置table中        putDates(new User());&#x2F;&#x2F; 创建JScrollPanel对象        panel_1.setLayout(null);        JScrollPane jscrollpane &#x3D; new JScrollPane();        jscrollpane.setBounds(20, 22, 496, 154);        jscrollpane.setViewportView(table);        panel_1.add(jscrollpane);        jf.getContentPane().add(panel_1);&#x2F;&#x2F; 底部展示“用户编辑”的JLabel        JPanel panel_2 &#x3D; new JPanel();        panel_2.setBorder(new TitledBorder(null, &quot;用户编辑&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, Color.RED));        panel_2.setBounds(20, 302, 540, 137);        jf.getContentPane().add(panel_2);        panel_2.setLayout(null);&#x2F;&#x2F; 编号 JLabel        JLabel lblNewLabel_1 &#x3D; new JLabel(&quot;编号：&quot;);        lblNewLabel_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        lblNewLabel_1.setBounds(49, 30, 48, 34);        panel_2.add(lblNewLabel_1);&#x2F;&#x2F; 编号 文本框        textField_1 &#x3D; new JTextField();        textField_1.setEditable(false);        textField_1.setBounds(103, 37, 66, 21);        panel_2.add(textField_1);        textField_1.setColumns(10);&#x2F;&#x2F; 用户名 JLabel        JLabel label &#x3D; new JLabel(&quot;用户名：&quot;);        label.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        label.setBounds(187, 30, 66, 34);        panel_2.add(label);&#x2F;&#x2F; 用户名 文本框        textField_2 &#x3D; new JTextField();        textField_2.setColumns(10);        textField_2.setBounds(259, 37, 93, 21);        panel_2.add(textField_2);&#x2F;&#x2F; 密码 JLabel        JLabel label_1 &#x3D; new JLabel(&quot;密码：&quot;);        label_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        label_1.setBounds(383, 30, 48, 34);        panel_2.add(label_1);&#x2F;&#x2F; 密码 文本框        textField_3 &#x3D; new JTextField();        textField_3.setColumns(10);        textField_3.setBounds(437, 37, 93, 21);        panel_2.add(textField_3);&#x2F;&#x2F; 修改按钮        JButton btnNewButton_1 &#x3D; new JButton(&quot;修改&quot;);&#x2F;&#x2F; 给修改按钮添加一个事件监听器        btnNewButton_1.addActionListener(new ActionListener() &#123;            public void actionPerformed(ActionEvent e) &#123;&#x2F;&#x2F; 获取数据                String userId &#x3D; textField_1.getText();                String userName &#x3D; textField_2.getText();                String password &#x3D; textField_3.getText();                String sex &#x3D; textField_4.getText();                String phone &#x3D; textField_5.getText();                if (ToolUtil.isEmpty(userName)                        || ToolUtil.isEmpty(password)                        || ToolUtil.isEmpty(sex) || ToolUtil.isEmpty(phone)) &#123;                    JOptionPane.showMessageDialog(null, &quot;请输入相关信息&quot;);                    return;                &#125;&#x2F;&#x2F; 把数据封装到User中                User user &#x3D; new User();                user.setUserId(Integer.parseInt(userId));                user.setUserName(userName);                user.setPassword(password);                user.setSex(sex);                user.setPhone(phone);&#x2F;&#x2F; 获取连接对象                Connection con &#x3D; null;                try &#123;                    con &#x3D; dbUtil.getConnection();                    int i &#x3D; userDao.update(con, user);                    if (i &#x3D;&#x3D; 1) &#123;                        JOptionPane.showMessageDialog(null, &quot;修改成功&quot;);                        putDates(new User());                    &#125; else &#123;                        JOptionPane.showMessageDialog(null, &quot;修改失败&quot;);                    &#125;                &#125; catch (Exception e1) &#123;                    e1.printStackTrace();                    JOptionPane.showMessageDialog(null, &quot;修改异常&quot;);                &#125; finally &#123;                    try &#123;                        dbUtil.closeCon(con);                    &#125; catch (Exception e1) &#123;                        e1.printStackTrace();                    &#125;                &#125;            &#125;        &#125;);        btnNewButton_1.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        btnNewButton_1.setBounds(422, 74, 87, 34);        panel_2.add(btnNewButton_1);&#x2F;&#x2F; 性别 JLabel        JLabel label_2 &#x3D; new JLabel(&quot;性别：&quot;);        label_2.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        label_2.setBounds(49, 74, 48, 34);        panel_2.add(label_2);&#x2F;&#x2F; 性别 文本框        textField_4 &#x3D; new JTextField();        textField_4.setColumns(10);        textField_4.setBounds(103, 81, 66, 21);        panel_2.add(textField_4);&#x2F;&#x2F; 手机号 JLabel        JLabel label_3 &#x3D; new JLabel(&quot;手机号：&quot;);        label_3.setFont(new Font(&quot;幼圆&quot;, Font.BOLD, 15));        label_3.setBounds(187, 74, 66, 34);        panel_2.add(label_3);&#x2F;&#x2F; 手机号 文本框        textField_5 &#x3D; new JTextField();        textField_5.setColumns(10);        textField_5.setBounds(259, 81, 93, 21);        panel_2.add(textField_5);&#x2F;&#x2F; 背景图片        JLabel lblNewLabel_2 &#x3D; new JLabel(&quot;&quot;);        lblNewLabel_2.setIcon(new ImageIcon(&quot;lib&#x2F;images&#x2F;5.png&quot;));        lblNewLabel_2.setBounds(0, 0, 584, 457);        jf.getContentPane().add(lblNewLabel_2);        table.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                tableMousePressed(evt);            &#125;        &#125;);&#x2F;&#x2F; 显示，不改变界面大小        jf.setVisible(true);        jf.setResizable(false);    &#125;    public void tableMousePressed(MouseEvent evt) &#123;        int row &#x3D; table.getSelectedRow();        textField_1.setText(table.getValueAt(row, 0).toString());        textField_2.setText(table.getValueAt(row, 1).toString());        textField_3.setText(table.getValueAt(row, 2).toString());        textField_4.setText(table.getValueAt(row, 3).toString());        textField_5.setText(table.getValueAt(row, 4).toString());    &#125;    public void putDates(User user) &#123;        DefaultTableModel model &#x3D; (DefaultTableModel) table.getModel();        model.setRowCount(0);&#x2F;&#x2F; 获取连接对象        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            ResultSet list &#x3D; userDao.list(con, user);            while (list.next()) &#123;                Vector rowData &#x3D; new Vector();                rowData.add(list.getInt(&quot;id&quot;));                rowData.add(list.getString(&quot;username&quot;));                rowData.add(list.getString(&quot;password&quot;));                rowData.add(list.getString(&quot;sex&quot;));                rowData.add(list.getString(&quot;phone&quot;));                model.addRow(rowData);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;            BeautyEyeLNFHelper.launchBeautyEyeLNF();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        new AdminUserInfo();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-2-借阅信息"><a href="#10-2-借阅信息" class="headerlink" title="10.2 借阅信息"></a>10.2 借阅信息</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hechaodong.bookmanager.jframe;import java.sql.*;import java.awt.Color;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.sql.ResultSet;import java.util.Vector;import javax.swing.JFrame;import com.hechaodong.bookmanager.dao.BorrowDetailDao;import com.hechaodong.bookmanager.model.BorrowDetail;import com.hechaodong.bookmanager.utils.DbUtil;import com.hechaodong.bookmanager.utils.ToolUtil;import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;import javax.swing.JMenuBar;import javax.swing.JMenu;import javax.swing.JMenuItem;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTable;import javax.swing.UIManager;import javax.swing.border.TitledBorder;import javax.swing.table.DefaultTableModel;import javax.swing.JLabel;import javax.swing.ImageIcon;public class AdminBorrowInfo extends JFrame &#123;    private JFrame jf;    private JTable table;    private DefaultTableModel model;    private DbUtil dbUtil &#x3D; new DbUtil();    private BorrowDetailDao borrowDetailDao &#x3D; new BorrowDetailDao();    public AdminBorrowInfo() &#123;        &#x2F;&#x2F; 初始化借阅信息界面        jf &#x3D; new JFrame(&quot;借阅信息&quot;);        jf.setBounds(650, 250, 610, 441);        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        jf.getContentPane().setLayout(null);        &#x2F;&#x2F; 创建菜单栏        JMenuBar menuBar &#x3D; new JMenuBar();        jf.setJMenuBar(menuBar);        JMenu mnNewMenu &#x3D; new JMenu(&quot;类别管理&quot;);        menuBar.add(mnNewMenu);        JMenuItem mntmNewMenuItem &#x3D; new JMenuItem(&quot;类别添加&quot;);        mntmNewMenuItem.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminMenuFrm();            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem);        JMenuItem mntmNewMenuItem_1 &#x3D; new JMenuItem(&quot;类别修改&quot;);        mntmNewMenuItem_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBTypeEdit();            &#125;        &#125;);        mnNewMenu.add(mntmNewMenuItem_1);        JMenu mnNewMenu_2 &#x3D; new JMenu(&quot;书籍管理&quot;);        menuBar.add(mnNewMenu_2);        JMenuItem mntmNewMenuItem_2 &#x3D; new JMenuItem(&quot;书籍添加&quot;);        mntmNewMenuItem_2.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBookAdd();            &#125;        &#125;);        mnNewMenu_2.add(mntmNewMenuItem_2);        JMenuItem mntmNewMenuItem_3 &#x3D; new JMenuItem(&quot;书籍修改&quot;);        mntmNewMenuItem_3.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminBookEdit();            &#125;        &#125;);        mnNewMenu_2.add(mntmNewMenuItem_3);        JMenu menu1 &#x3D; new JMenu(&quot;用户管理&quot;);        menuBar.add(menu1);        JMenuItem mntmNewMenuItem_4 &#x3D; new JMenuItem(&quot;用户信息&quot;);        mntmNewMenuItem_4.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                jf.dispose();                new AdminUserInfo();            &#125;        &#125;);        menu1.add(mntmNewMenuItem_4);        JMenuItem mntmNewMenuItem_5 &#x3D; new JMenuItem(&quot;借阅信息&quot;);        menu1.add(mntmNewMenuItem_5);        JMenu mnNewMenu_1 &#x3D; new JMenu(&quot;退出系统&quot;);        mnNewMenu_1.addMouseListener(new MouseAdapter() &#123;            public void mousePressed(MouseEvent evt) &#123;                JOptionPane.showMessageDialog(null, &quot;欢迎再次使用&quot;);                jf.dispose();            &#125;        &#125;);        menuBar.add(mnNewMenu_1);        &#x2F;&#x2F; 顶部“借阅信息”的JLabel        JPanel panel_1 &#x3D; new JPanel();        panel_1.setBorder(new TitledBorder(UIManager.getBorder(&quot;TitledBorder.border&quot;), &quot;借阅信息&quot;, TitledBorder.LEADING, TitledBorder.TOP, null, new Color(255, 0, 0)));        panel_1.setBounds(10, 10, 574, 350);        &#x2F;&#x2F; 表头栏数据        String[] title &#x3D; &#123;&quot;借书人&quot;, &quot;书名&quot;, &quot;状态&quot;, &quot;借书时间&quot;, &quot;还书时间&quot;&#125;;        &#x2F;&#x2F; 具体的各栏行记录 先用空的二位数组占位        String[][] dates &#x3D; &#123;&#125;;        &#x2F;&#x2F; 创建数据模型，实例化上面2个控件对象*&#x2F;        model &#x3D; new DefaultTableModel(dates, title);        table &#x3D; new JTable(model);        &#x2F;&#x2F;获取数据库数据放置table中        putDates(new BorrowDetail());        &#x2F;&#x2F; 借阅信息表格        panel_1.setLayout(null);        JScrollPane jscrollpane &#x3D; new JScrollPane();        jscrollpane.setBounds(20, 22, 538, 314);        jscrollpane.setViewportView(table);        panel_1.add(jscrollpane);        jf.getContentPane().add(panel_1);        &#x2F;&#x2F; 背景图片        JLabel lblNewLabel &#x3D; new JLabel(&quot;&quot;);        lblNewLabel.setIcon(new ImageIcon(&quot;lib&#x2F;images&#x2F;6.png&quot;));        lblNewLabel.setBounds(0, 0, 584, 379);        jf.getContentPane().add(lblNewLabel);        &#x2F;&#x2F; 显示        jf.setVisible(true);        jf.setResizable(true);    &#125;    &#x2F;&#x2F;    private void putDates(BorrowDetail borrowDetail) &#123;        DefaultTableModel model &#x3D; (DefaultTableModel) table.getModel();        model.setRowCount(0);        &#x2F;&#x2F; 获取连接对象        Connection con &#x3D; null;        try &#123;            con &#x3D; dbUtil.getConnection();            ResultSet list &#x3D; borrowDetailDao.list(con, borrowDetail);            while (list.next()) &#123;                Vector rowData &#x3D; new Vector();                rowData.add(list.getString(&quot;username&quot;));                rowData.add(list.getString(&quot;book_name&quot;));                int status &#x3D; list.getInt(&quot;status&quot;);                if (status &#x3D;&#x3D; 1) &#123;                    rowData.add(&quot;在借&quot;);                &#125; else &#123;                    rowData.add(&quot;已还&quot;);                &#125;                rowData.add(ToolUtil.getDateByTime(list.getLong(&quot;borrow_time&quot;)));                if (status &#x3D;&#x3D; 2) &#123;                    rowData.add(ToolUtil.getDateByTime(list.getLong(&quot;return_time&quot;)));                &#125;                model.addRow(rowData);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                dbUtil.closeCon(con);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            BeautyEyeLNFHelper.frameBorderStyle &#x3D; BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;            BeautyEyeLNFHelper.launchBeautyEyeLNF();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        new AdminBorrowInfo();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/06/04/reflect/"/>
      <url>/2023/06/04/reflect/</url>
      
        <content type="html"><![CDATA[<h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><h2 id="1-什么是反射"><a href="#1-什么是反射" class="headerlink" title="1. 什么是反射"></a>1. 什么是反射</h2><p>在Java中，反射是指能够在运行时获取类的信息并操作类或对象的能力。通过反射，可以获取类的名称、属性、方法等信息，也可以动态地创建对象、调用方法等。Java中的反射机制提供了很多灵活性和可扩展性，但也需要注意反射操作可能会影响程序的性能和安全性。</p><img src="/2023/06/04/reflect/1.png" class=""><p><strong>通过反射可以获取class(字节码文件)，构造方法，成员变量和成员方法</strong></p><img src="/2023/06/04/reflect/2.png" class=""><h2 id="2-获取"><a href="#2-获取" class="headerlink" title="2. 获取"></a>2. 获取</h2><h3 id="2-1-获取Class对象"><a href="#2-1-获取Class对象" class="headerlink" title="2.1 获取Class对象"></a>2.1 获取Class对象</h3><ol><li>通过全类名 Class.forName(“全类名”)获取</li><li>通过类名.class获取</li><li>通过对象.getClass() 获取</li></ol><img src="/2023/06/04/reflect/3.png" class=""><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty;public class MyReflect01 &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        &#x2F;*         * 获取Class对象的三种方式         *   1.Class.forName(&quot;全类名&quot;);         *   2.类名.class         *   3.对象.getClass();         * *&#x2F;        &#x2F;&#x2F; 1.第一种方式 Class.forName(&quot;全类名&quot;);        &#x2F;&#x2F; 全类名字：包名 + 类名        Class clazz &#x3D; Class.forName(&quot;com.reflect.sty.Student&quot;);        System.out.println(clazz);        System.out.println(&quot;--------------------------------------------&quot;);        &#x2F;&#x2F; 2.第二种方式 类名.class        &#x2F;&#x2F; 一般当作参数进行传递        Class&lt;Student&gt; clazz2 &#x3D; Student.class;        System.out.println(clazz2);        System.out.println(&quot;--------------------------------------------&quot;);        &#x2F;&#x2F; 3.第三种方式 对象.getClass();        &#x2F;&#x2F; 当我们有对象时，才能进行使用        Student student &#x3D; new Student();        Class&lt;? extends Student&gt; clazz3 &#x3D; student.getClass();        System.out.println(clazz3);        System.out.println(&quot;--------------------------------------------&quot;);        System.out.println(clazz &#x3D;&#x3D; clazz2 &amp;&amp; clazz &#x3D;&#x3D; clazz3);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-获取构造方法"><a href="#2-2-获取构造方法" class="headerlink" title="2.2 获取构造方法"></a>2.2 获取构造方法</h3><p><strong>Class中用于获取构造方法的方法</strong></p><ol><li>Constructor&lt;?&gt; [] getConstructors():返回所有公共构造方法对象的数组</li><li>Constructor&lt;?&gt; [] getDeclaredConstructors():返回所有构造方法对象的数组</li><li>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes):返回单个公共构造方法对象</li><li>Constructor<T>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes):返回单个构造方法对象</li></ol><p><strong>Constructor类中用于创建对象的方法</strong></p><ol><li>T newlnstance(Object… initargs):根据指定的构造方法创建对象</li><li>setAccessible(boolean flag):设置为true,表示取消访问检查</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.test02;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Parameter;public class MyReflect &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;             &#x2F;&#x2F; 1.获取class字节码文件对象        Class clazz &#x3D; Class.forName(&quot;com.reflect.sty.test02.Student&quot;);        &#x2F;&#x2F; 2.获取构造方法        &#x2F;&#x2F; 2.1 返回公共构造方法对象的数组 &#x2F;*       Constructor[] cons &#x3D; clazz.getConstructors();        for (Constructor con : cons) &#123;            System.out.println(con);        &#125;*&#x2F;        &#x2F;&#x2F; 2.2 返回所有构造方法对象的数组&#x2F;*        Constructor[] cons2 &#x3D; clazz.getDeclaredConstructors();        for (Constructor con : cons2) &#123;            System.out.println(con);        &#125;*&#x2F;        &#x2F;&#x2F; 2.3 返回单个构造方法的对象（Declared --&gt; 权限符：可以返回public，也可以返回private）&#x2F;*        Constructor con1 &#x3D; clazz.getDeclaredConstructor();        System.out.println(con1);        Constructor con2 &#x3D; clazz.getConstructor(String.class);        System.out.println(con2);        Constructor con3 &#x3D; clazz.getDeclaredConstructor(int.class);        System.out.println(con3);*&#x2F;        Constructor con4 &#x3D; clazz.getDeclaredConstructor(String.class, int.class);        System.out.println(con4);        System.out.println(&quot;---------&quot;);        &#x2F;&#x2F; 返回权限修饰符        &#x2F;&#x2F;  public：1  private：2  protected：4&#x2F;*        int modifiers &#x3D; con4.getModifiers();        System.out.println(modifiers);*&#x2F;        &#x2F;&#x2F; idea可以使用 Ctrl+ P 可以求出方法的参数的类型&#x2F;*        Parameter[] parameters &#x3D; con4.getParameters();        for (Parameter parameter : parameters) &#123;            System.out.println(parameter);        &#125;*&#x2F;        &#x2F;&#x2F; 暴力反射：表示临时取消权限校验        con4.setAccessible(true);        Student stu &#x3D; (Student) con4.newInstance(&quot;香辣小猪&quot;, 123);        System.out.println(stu);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.test02;public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name) &#123;        this.name &#x3D; name;    &#125;    protected Student(int age) &#123;        this.age &#x3D; age;    &#125;    public Student(String name, int age) &#123;        this.name &#x3D; name;        this.age &#x3D; age;    &#125;    &#x2F;**     * 获取     * @return name     *&#x2F;    public String getName() &#123;        return name;    &#125;    &#x2F;**     * 设置     * @param name     *&#x2F;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    &#x2F;**     * 获取     * @return age     *&#x2F;    public int getAge() &#123;        return age;    &#125;    &#x2F;**     * 设置     * @param age     *&#x2F;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    public String toString() &#123;        return &quot;Student&#123;name &#x3D; &quot; + name + &quot;, age &#x3D; &quot; + age + &quot;&#125;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-获取成员变量"><a href="#2-3-获取成员变量" class="headerlink" title="2.3 获取成员变量"></a>2.3 获取成员变量</h3><p><strong>Class类中用于获取成员变量的方法</strong></p><ol><li>Field[] getFields():返回所有公共成员变量对象的数组</li><li>Field[ ] getDeclaredFields():返回所有成员变量对象的数组</li><li>Field getField(String name):返回单个公共成员变量对象</li><li>Field getDeclaredField(String name):返回单个成员变量对象</li></ol><p><strong>Field类中用于创建对象的方法</strong></p><ol><li>void set(Object obj, Object value):赋值</li><li>Object get(Object obj)获取值</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.test03;import java.lang.reflect.Field;public class MyReflect &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;        &#x2F;&#x2F; 1.获取class字节码文件的对象        Class clazz &#x3D; Class.forName(&quot;com.reflect.sty.test03.Student&quot;);        &#x2F;&#x2F; 2.获取所有成员变量 &#x2F;*       Field[] fields &#x3D; clazz.getDeclaredFields();        for (Field field : fields) &#123;            System.out.println(field);        &#125;*&#x2F;        &#x2F;&#x2F; 获取当个成员变量        Field name &#x3D; clazz.getDeclaredField(&quot;name&quot;);        System.out.println(name);        &#x2F;&#x2F; 3.获取权限修饰符        int modifiers &#x3D; name.getModifiers();        System.out.println(modifiers);        &#x2F;&#x2F; 4.获取成员变量的名字        String n &#x3D; name.getName();        System.out.println(n);        &#x2F;&#x2F; 5.获取成员变量的数据类型        Class&lt;?&gt; type &#x3D; name.getType();        System.out.println(type);        System.out.println(&quot;-------------------------&quot;);                &#x2F;&#x2F; 6.获取成员变量记录的值        Student student &#x3D; new Student(&quot;spicypig&quot;, 23, &quot;男&quot;);        System.out.println(student);        name.setAccessible(true);        Object value &#x3D; name.get(student);        System.out.println(value);        &#x2F;&#x2F; 修改对象里面记录的值        name.set(student, &quot;香辣小猪&quot;);        System.out.println(student);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.test03;public class Student &#123;    private String name;    private int age;    public String gender;    public Student() &#123;    &#125;    public Student(String name, int age, String gender) &#123;        this.name &#x3D; name;        this.age &#x3D; age;        this.gender &#x3D; gender;    &#125;    &#x2F;**     * 获取     * @return name     *&#x2F;    public String getName() &#123;        return name;    &#125;    &#x2F;**     * 设置     * @param name     *&#x2F;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    &#x2F;**     * 获取     * @return age     *&#x2F;    public int getAge() &#123;        return age;    &#125;    &#x2F;**     * 设置     * @param age     *&#x2F;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    &#x2F;**     * 获取     * @return gender     *&#x2F;    public String getGender() &#123;        return gender;    &#125;    &#x2F;**     * 设置     * @param gender     *&#x2F;    public void setGender(String gender) &#123;        this.gender &#x3D; gender;    &#125;    public String toString() &#123;        return &quot;Student&#123;name &#x3D; &quot; + name + &quot;, age &#x3D; &quot; + age + &quot;, gender &#x3D; &quot; + gender + &quot;&#125;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-获取成员方法"><a href="#2-4-获取成员方法" class="headerlink" title="2.4 获取成员方法"></a>2.4 获取成员方法</h3><p><strong>Class类中用于获取成员方法的方法</strong></p><ol><li>Method[ ] getMethods():返回所有公共成员方法对象的数组，包括继承的</li><li>Method[] getDeclaredMethods():返回所有成员方法对象的数组，不包括继承的</li><li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes):返回单个公共成员方法对象</li><li>Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes):返回单个成员方法对象</li></ol><p><strong>Method类中用于创建对象的方法</strong></p><ol><li>Object invoke(Object obj, Object… args):运行方法参数一:用obj对象调用该方法<br>参数二:调用方法的传递的参数（如果没有就不写)返回值:方法的返回值（如果没有就不写)</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.test04;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Parameter;public class MyReflect &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        &#x2F;&#x2F; 1. 获取class字节码文件对象        Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.reflect.sty.test04.Student&quot;);        &#x2F;&#x2F; 2.获取所有对象的方法（getMethods 包含父类中所有的公共方法）&#x2F;*        Method[] methods &#x3D; clazz.getMethods();        for (Method method : methods) &#123;            System.out.println(method);        &#125;*&#x2F;        &#x2F;&#x2F; 获取所有对象的方法（不能获取父类，当时可以获取本类中私有的方法）        Method[] methods &#x3D; clazz.getDeclaredMethods();        for (Method method : methods) &#123;            System.out.println(method);        &#125;        &#x2F;&#x2F; 3.获取指定的单一方法        Method m &#x3D; clazz.getDeclaredMethod(&quot;eat&quot;, String.class);        System.out.println(m);        &#x2F;&#x2F; 4.获取方法的修饰符        int modifiers &#x3D; m.getModifiers();        System.out.println(modifiers);        &#x2F;&#x2F; 5.获取方法的名字        String name &#x3D; m.getName();        System.out.println(name);        &#x2F;&#x2F; 6.获取方法形参        Parameter[] parameters &#x3D; m.getParameters();        for (Parameter parameter : parameters) &#123;            System.out.println(parameter);        &#125;        &#x2F;&#x2F; 7.获取方法抛出的异常        Class[] exceptionTypes &#x3D; m.getExceptionTypes();        for (Class exceptionType : exceptionTypes) &#123;            System.out.println(exceptionType);        &#125;        &#x2F;&#x2F; 8.运行获取的方法（得到方法的返回值）&#x2F;*        Method类中用于创建对象的方法          Object invoke(Object obj, Object... args)的运行方法：          参数一：用obj对象调用方法          参数二：调用发的传递的参数（没有不写）          返回值：方法返回值（没有不写）                *&#x2F;        Student student &#x3D; new Student();        m.setAccessible(true);        &#x2F;&#x2F; 参数一（s）:表示方法的调用者        &#x2F;&#x2F; 参数二（“汉堡包”）:表示在调用方法的时候传递的实际参数        String res &#x3D; (String) m.invoke(student, &quot;汉堡包&quot;);        System.out.println(res);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.test04;import java.io.IOException;public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name &#x3D; name;        this.age &#x3D; age;    &#125;    &#x2F;**     * 获取     * @return name     *&#x2F;    public String getName() &#123;        return name;    &#125;    &#x2F;**     * 设置     * @param name     *&#x2F;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    &#x2F;**     * 获取     * @return age     *&#x2F;    public int getAge() &#123;        return age;    &#125;    &#x2F;**     * 设置     * @param age     *&#x2F;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    public void sleep() &#123;        System.out.println(&quot;睡觉&quot;);    &#125;    private String eat(String s) throws IOException, NullPointerException, ClassCastException &#123;        System.out.println(&quot;吃&quot; + s);        return &quot;奥利给&quot;;    &#125;    private void eat(String s, int a) &#123;        System.out.println(&quot;吃&quot; + s);    &#125;    public String toString() &#123;        return &quot;Student&#123;name &#x3D; &quot; + name + &quot;, age &#x3D; &quot; + age + &quot;&#125;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-反射的作用"><a href="#3-反射的作用" class="headerlink" title="3. 反射的作用"></a>3. 反射的作用</h2><ol><li><p>获取一个类里面所有的信息，获取到了之后，再执行其他的业务逻辑。</p></li><li><p>结合配置文件，动态的创建对象并调用方。</p></li><li><p>动态地获取类的信息：可以在运行时获取类的名称、属性、方法等信息，而不需要在编译时就确定。</p></li><li><p>动态地创建对象：可以根据类的名称动态地创建对象，而不需要在编译时就确定。</p></li><li><p>动态地调用方法：可以在运行时根据方法名和参数列表动态地调用方法，而不需要在编译时就确定。</p></li><li><p>实现通用框架：通过反射机制，可以编写通用的框架，使得框架可以处理各种类型的对象。</p></li><li><p>实现动态代理：通过反射机制，可以实现动态代理，使得代理对象可以在运行时动态地生成。</p></li></ol><h2 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h2><h3 id="4-1-练习一"><a href="#4-1-练习一" class="headerlink" title="4.1 练习一"></a>4.1 练习一</h3><p><strong>对于任意一个对象，都可以把对象所有的字段名和值，保存到文件中去</strong></p><img src="/2023/06/04/reflect/4.png" class=""><h4 id="MyReflect"><a href="#MyReflect" class="headerlink" title="MyReflect"></a>MyReflect</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.zlx01;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.lang.reflect.Field;public class MyReflect &#123;    public static void main(String[] args) throws IllegalAccessException, IOException &#123;        &#x2F;*        要求：对于任意一个对象，都可以吧对象所有的字段名和值，保存到文件中去        *&#x2F;        Student student &#x3D; new Student(&quot;Tom&quot;, 23, &#39;女&#39;, 186.7, &quot;学习&quot;);        Teacher teacher &#x3D; new Teacher(&quot;波妞&quot;, 10000);        saveObject(student);    &#125;        &#x2F;&#x2F; 把对象里面所有的成员变量和值保存到本地文件中        public static void saveObject(Object obj) throws IllegalAccessException, IOException &#123;            &#x2F;&#x2F; 1.获取字节码文件的对象            Class clazz &#x3D; obj.getClass();            &#x2F;&#x2F; 2. 创建IO流            BufferedWriter bw &#x3D; new BufferedWriter(new FileWriter(&quot;src&#x2F;com&#x2F;student.txt&quot;));            &#x2F;&#x2F; 2.获取所有的成员变量            Field[] fields &#x3D; clazz.getDeclaredFields();            for (Field field : fields) &#123;                &#x2F;&#x2F;  临时校验                field.setAccessible(true);                &#x2F;&#x2F; 获取成员变量的名字                String name &#x3D; field.getName();                &#x2F;&#x2F; 获取成员变量的值                Object value &#x3D; field.get(obj);                &#x2F;&#x2F; 写出数据                bw.write(name + &quot;&#x3D;&quot; + value);                bw.newLine();            &#125;            System.out.println(&quot;写入成功&quot;);            bw.close();        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Student"><a href="#Student" class="headerlink" title="Student"></a>Student</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.zlx01;public class Student &#123;    private String name;    private int age;    private char gender;    private double height;    private String hobby;    public Student() &#123;    &#125;    public Student(String name, int age, char gender, double height, String hobby) &#123;        this.name &#x3D; name;        this.age &#x3D; age;        this.gender &#x3D; gender;        this.height &#x3D; height;        this.hobby &#x3D; hobby;    &#125;    &#x2F;**     * 获取     * @return name     *&#x2F;    public String getName() &#123;        return name;    &#125;    &#x2F;**     * 设置     * @param name     *&#x2F;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    &#x2F;**     * 获取     * @return age     *&#x2F;    public int getAge() &#123;        return age;    &#125;    &#x2F;**     * 设置     * @param age     *&#x2F;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    &#x2F;**     * 获取     * @return gender     *&#x2F;    public char getGender() &#123;        return gender;    &#125;    &#x2F;**     * 设置     * @param gender     *&#x2F;    public void setGender(char gender) &#123;        this.gender &#x3D; gender;    &#125;    &#x2F;**     * 获取     * @return height     *&#x2F;    public double getHeight() &#123;        return height;    &#125;    &#x2F;**     * 设置     * @param height     *&#x2F;    public void setHeight(double height) &#123;        this.height &#x3D; height;    &#125;    &#x2F;**     * 获取     * @return hobby     *&#x2F;    public String getHobby() &#123;        return hobby;    &#125;    &#x2F;**     * 设置     * @param hobby     *&#x2F;    public void setHobby(String hobby) &#123;        this.hobby &#x3D; hobby;    &#125;    public String toString() &#123;        return &quot;Student&#123;name &#x3D; &quot; + name + &quot;, age &#x3D; &quot; + age + &quot;, gender &#x3D; &quot; + gender + &quot;, height &#x3D; &quot; + height + &quot;, hobby &#x3D; &quot; + hobby + &quot;&#125;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Teacher"><a href="#Teacher" class="headerlink" title="Teacher"></a>Teacher</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.zlx01;public class Teacher &#123;    private String name;    private double salary;    public Teacher() &#123;    &#125;    public Teacher(String name, double salary) &#123;        this.name &#x3D; name;        this.salary &#x3D; salary;    &#125;    &#x2F;**     * 获取     * @return name     *&#x2F;    public String getName() &#123;        return name;    &#125;    &#x2F;**     * 设置     * @param name     *&#x2F;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    &#x2F;**     * 获取     * @return salary     *&#x2F;    public double getSalary() &#123;        return salary;    &#125;    &#x2F;**     * 设置     * @param salary     *&#x2F;    public void setSalary(double salary) &#123;        this.salary &#x3D; salary;    &#125;    public String toString() &#123;        return &quot;Teacher&#123;name &#x3D; &quot; + name + &quot;, salary &#x3D; &quot; + salary + &quot;&#125;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-练习二"><a href="#4-2-练习二" class="headerlink" title="4.2 练习二"></a>4.2 练习二</h3><p><strong>反射可以更配置文件结合的方式，动态的创建对象，并调用方法</strong></p><h4 id="MyReflect-1"><a href="#MyReflect-1" class="headerlink" title="MyReflect"></a>MyReflect</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.zlx02;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;public class MyReflect &#123;    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;        &#x2F;*        要求：发射可以配置文件结合的方式，动态的创建对象，并且调用方法        *&#x2F;        &#x2F;&#x2F; 1.读取配置文件中的信息        Properties p &#x3D; new Properties();        FileInputStream fis &#x3D; new FileInputStream(&quot;src&#x2F;com&#x2F;prop.properties&quot;);        System.out.println(p);        p.load(fis);        fis.close();        System.out.println(p);        &#x2F;&#x2F; 2.获取全类名和方法名        String className &#x3D; (String) p.get(&quot;classname&quot;);        String methodName &#x3D; (String) p.get(&quot;method&quot;);        System.out.println(className);        System.out.println(methodName);        &#x2F;&#x2F; 3.利用反射创建对象并运行方法        Class clazz &#x3D; Class.forName(className);        &#x2F;&#x2F; 获取构造方法        Constructor con &#x3D; clazz.getDeclaredConstructor();        Object o &#x3D; con.newInstance();        System.out.println(o);        &#x2F;&#x2F; 获取成员方法并且运行        Method method &#x3D; clazz.getDeclaredMethod(methodName);        method.setAccessible(true);        method.invoke(o);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Student-1"><a href="#Student-1" class="headerlink" title="Student"></a>Student</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.zlx02;public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name &#x3D; name;        this.age &#x3D; age;    &#125;    public void study() &#123;        System.out.println(&quot;学生正在学习！&quot;);    &#125;    &#x2F;**     * 获取     * @return name     *&#x2F;    public String getName() &#123;        return name;    &#125;    &#x2F;**     * 设置     * @param name     *&#x2F;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    &#x2F;**     * 获取     * @return age     *&#x2F;    public int getAge() &#123;        return age;    &#125;    &#x2F;**     * 设置     * @param age     *&#x2F;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    public String toString() &#123;        return &quot;Student&#123;name &#x3D; &quot; + name + &quot;, age &#x3D; &quot; + age + &quot;&#125;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Teacher-1"><a href="#Teacher-1" class="headerlink" title="Teacher"></a>Teacher</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.reflect.sty.zlx02;public class Teacher &#123;    private String name;    private double salary;    public Teacher() &#123;    &#125;    public Teacher(String name, double salary) &#123;        this.name &#x3D; name;        this.salary &#x3D; salary;    &#125;    public void teach() &#123;        System.out.println(&quot;老师正在教书！&quot;);    &#125;    &#x2F;**     * 获取     * @return name     *&#x2F;    public String getName() &#123;        return name;    &#125;    &#x2F;**     * 设置     * @param name     *&#x2F;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    &#x2F;**     * 获取     * @return salary     *&#x2F;    public double getSalary() &#123;        return salary;    &#125;    &#x2F;**     * 设置     * @param salary     *&#x2F;    public void setSalary(double salary) &#123;        this.salary &#x3D; salary;    &#125;    public String toString() &#123;        return &quot;Teacher&#123;name &#x3D; &quot; + name + &quot;, salary &#x3D; &quot; + salary + &quot;&#125;&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">classname=com.reflect.sty.zlx02.Teachermethod=teach<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-动态代理"><a href="#5-动态代理" class="headerlink" title="5. 动态代理"></a>5. 动态代理</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2023/05/25/network-program/"/>
      <url>/2023/05/25/network-program/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="1-常见的网络架构"><a href="#1-常见的网络架构" class="headerlink" title="1.常见的网络架构"></a>1.常见的网络架构</h2><h3 id="1-1-客户端-服务器（Client-Server）"><a href="#1-1-客户端-服务器（Client-Server）" class="headerlink" title="1.1 客户端&#x2F;服务器（Client&#x2F;Server）"></a>1.1 客户端&#x2F;服务器（Client&#x2F;Server）</h3><p>用户在本地需要下载并且安装客户端程序，在远程有一个服务器端程序。例如：QQ，Stream…</p><p><strong>特征：</strong></p><ul><li><p>画面精美，用户体验好</p></li><li><p>需要开发客户端和服务端</p></li><li><p>用户需要下载和更新客户端</p></li><li><p>适合开发互联网应用，可以随时随地访问</p></li></ul><h3 id="1-2-浏览器-服务器（Browser-Server）"><a href="#1-2-浏览器-服务器（Browser-Server）" class="headerlink" title="1.2 浏览器&#x2F;服务器（Browser&#x2F;Server）"></a>1.2 浏览器&#x2F;服务器（Browser&#x2F;Server）</h3><p>只需要有一个浏览器，用户通过不同的网址，客户访问不同的服务器。例如：淘宝，百度</p><p><strong>特征：</strong></p><ul><li><p>不需要开发客户端，只需要开发服务端</p></li><li><p>用户不需要下载，打开浏览器就能用</p></li><li><p>如果应用过大，数据过多的话，用户体验会受影响</p></li><li><p>适合开发办公类及其大型游戏，稳定，体验好</p></li></ul><img src="/2023/05/25/network-program/1.png" class=""><h2 id="2-网络编程三要素"><a href="#2-网络编程三要素" class="headerlink" title="2. 网络编程三要素"></a>2. 网络编程三要素</h2><h3 id="2-1-IP地址"><a href="#2-1-IP地址" class="headerlink" title="2.1 IP地址"></a>2.1 IP地址</h3><p>设备在网络中的地址，识别该设备的唯一标识</p><h4 id="2-1-1-IPV4"><a href="#2-1-1-IPV4" class="headerlink" title="2.1.1  IPV4"></a>2.1.1  IPV4</h4><p>采用32位地址长度，分成4组，共有个IP地址，IPV4共有2^32个IP地址（约有43亿）。</p><img src="/2023/05/25/network-program/2.png" class=""><p><strong>IPV4的地址分类形式</strong></p><ul><li>公网地址(万维网使用)和私有地址(局域网使用)。</li><li>192.168.开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用，以此节省IP</li></ul><h4 id="2-1-2-IPV6"><a href="#2-1-2-IPV6" class="headerlink" title="2.1.2  IPV6"></a>2.1.2  IPV6</h4><p>采用128位地址长度，分成8组，可以给地球上的每一粒沙子分配一个IP地址。</p><img src="/2023/05/25/network-program/3.png" class=""><h4 id="2-1-3-常用的CMD命令"><a href="#2-1-3-常用的CMD命令" class="headerlink" title="2.1.3 常用的CMD命令"></a>2.1.3 常用的CMD命令</h4><ul><li><p>ipconfig：查看本机IP地址</p></li><li><p>ping：检查网络是否连通</p></li></ul><img src="/2023/05/25/network-program/4.png" class=""><blockquote><p>特殊IP地址：127.0.0.1 &lt;&#x3D;&#x3D;&gt; localhost (本机IP地址)</p></blockquote><h4 id="2-1-4-获取IP地址的方法"><a href="#2-1-4-获取IP地址的方法" class="headerlink" title="2.1.4  获取IP地址的方法"></a>2.1.4  获取IP地址的方法</h4><ul><li><code>static InetAddress getByName(String host)</code>确定主机名的IP地址，主机名可以是机器名称，也可以是IP地址</li><li><code>String getHostName() </code>获取IP地址的主机名</li><li><code>String getHostAddress()</code>返回文本显示中的IP地址字符串</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.a01;import java.net.InetAddress;import java.net.UnknownHostException;public class Test &#123;    public static void main(String[] args) throws UnknownHostException &#123;        &#x2F;*        * static InetAddress getByName(String host) 确定主机名的IP地址，主机名可以是机器名称，也可以是IP地址        * String getHostName()                      获取IP地址的主机名        * String getHostAddress()                   返回文本显示中的IP地址字符串        * *&#x2F;        &#x2F;&#x2F; 1.获取InetAddress的对象        InetAddress address &#x3D; InetAddress.getByName(&quot;Spicy-pig&quot;);        System.out.println(address);        &#x2F;&#x2F; 2.获取IP地址的主机名        String name &#x3D; address.getHostName();        System.out.println(name);&#x2F;&#x2F; Spicy-pig        &#x2F;&#x2F; 3.返回文本显示中的IP地址字符串        String ip &#x3D; address.getHostAddress();        System.out.println(ip);&#x2F;&#x2F; 10.30.185.145    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-端口号"><a href="#2-2-端口号" class="headerlink" title="2.2 端口号"></a>2.2 端口号</h3><p>应用程序在设备中的唯一标识。</p><p>端口号:由两个字节表示的整数，取值范围:0—65535。</p><p>其中0—1023之间的端口号用于一些知名的网络服务或者应用。我们自己使用1024以上的端口号就可以了。</p><img src="/2023/05/25/network-program/5.png" class=""><h3 id="2-3-协议"><a href="#2-3-协议" class="headerlink" title="2.3 协议"></a>2.3 协议</h3><p>数据在网络中传输的规则，常见的协议有UDP，TCP，HTTP，HTTPS，FTP。</p><img src="/2023/05/25/network-program/6.png" class=""><h4 id="2-3-1-UDP协议"><a href="#2-3-1-UDP协议" class="headerlink" title="2.3.1 UDP协议"></a>2.3.1 UDP协议</h4><ul><li>用户数据报协议(User Datagram Protocol)</li><li>UDP是面向无连接通信协议。</li><li>速度快，有大小限制一次最多发送64K，数据不安全，易丢失数据。</li></ul><h4 id="2-3-2-TCP协议"><a href="#2-3-2-TCP协议" class="headerlink" title="2.3.2 TCP协议"></a>2.3.2 TCP协议</h4><ul><li>传输控制协议TCP(Transmission Control Protocol)</li><li>TCP协议是面向连接的通信协议。</li><li>速度慢，没有大小限制，数据安全。</li></ul><h4 id="2-3-3-数据的收发步骤"><a href="#2-3-3-数据的收发步骤" class="headerlink" title="2.3.3 数据的收发步骤"></a>2.3.3 数据的收发步骤</h4><p><strong>接收数据的一般步骤：</strong></p><ul><li>创建发送端DatagramSocket的对象</li><li>打包数据</li><li>发送数据</li><li>释放资源</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.a02;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class Receive &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F; 接受数据        &#x2F;&#x2F; 1. 创建DatagramSocket对象（快递公司）        &#x2F;&#x2F; 细节：        &#x2F;&#x2F;      再接收的时候一定要绑定端口        &#x2F;&#x2F;      绑定的端口一定要和发送的端口一样        DatagramSocket ds &#x3D; new DatagramSocket(10086);        &#x2F;&#x2F; 2.接收数据包        byte[] bytes &#x3D; new byte[1024];        DatagramPacket dp &#x3D; new DatagramPacket(bytes, bytes.length);        &#x2F;&#x2F; 该方法是阻塞的        &#x2F;&#x2F; 程序执行到这里时，如果下面的receive语句没有执行的话就会发生阻塞        System.out.println(&quot;请求已发送！&quot;);        ds.receive(dp);        System.out.println(&quot;已收到回复！&quot;);        &#x2F;&#x2F; 3.解析数据包        byte[] data &#x3D; dp.getData();        int len &#x3D; dp.getLength();        InetAddress address &#x3D; dp.getAddress();        int port &#x3D; dp.getPort();        System.out.println(&quot;接收到的数据为：&quot; + new String(data, 0, len));        System.out.println(&quot;该数据是从 &quot; + address + &quot; 这台电脑的 &quot; + port + &quot; 这个端口发出的&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>发送数据的一般步骤：</strong></p><ul><li>创建接收端DatagramSocket的对象</li><li>接收打包好的数据</li><li>解析数据包</li><li>释放资源</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.a02;import java.io.IOException;import java.net.*;public class Send &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F; 发送数据        &#x2F;&#x2F; 1.创建DatagramSocket对象(快递公司)        &#x2F;&#x2F;   细节:        &#x2F;&#x2F; 绑定端口，以后我们就是通过这个端口往外发送        &#x2F;&#x2F; 空参:所有可用的端口中随机一个进行使用        &#x2F;&#x2F; 有参:指定端口号进行绑定        DatagramSocket ds &#x3D; new DatagramSocket();        &#x2F;&#x2F; 2.打包数据        String str &#x3D; &quot;Hello， 你好啊！&quot;;        byte[] bytes &#x3D; str.getBytes();        InetAddress address &#x3D; InetAddress.getByName(&quot;127.0.0.1&quot;);        int port &#x3D; 10086;        DatagramPacket dp &#x3D; new DatagramPacket(bytes, bytes.length, address, port);        &#x2F;&#x2F; 3.发送数据        ds.send(dp);        &#x2F;&#x2F; 4.释放资源        ds.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-UDP通信程序"><a href="#3-UDP通信程序" class="headerlink" title="3. UDP通信程序"></a>3. UDP通信程序</h2><h3 id="3-1-UDP发送数据"><a href="#3-1-UDP发送数据" class="headerlink" title="3.1 UDP发送数据"></a>3.1 UDP发送数据</h3><ul><li>找到快递公司（创建发送端的DatagramSocket对象）</li><li>打包快递（打包数据DatagramPacket）</li><li>快递公司发送包裹（发送数据）</li><li>付钱走人（释放资源）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.a03udp;import java.io.IOException;import java.net.*;import java.util.Scanner;public class Send &#123;    public static void main(String[] args) throws IOException &#123;         &#x2F;*            按照下面的要求实现程序                UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束                UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收        *&#x2F;        &#x2F;&#x2F;1.创建对象DatagramSocket的对象        DatagramSocket ds &#x3D; new DatagramSocket();        &#x2F;&#x2F;2.打包数据        Scanner sc &#x3D; new Scanner(System.in);        while (true) &#123;            System.out.println(&quot;请输入您要说的话：&quot;);            String str &#x3D; sc.nextLine();            if(&quot;886&quot;.equals(str))&#123;                break;            &#125;            byte[] bytes &#x3D; str.getBytes();            InetAddress address &#x3D; InetAddress.getByName(&quot;127.0.0.1&quot;);            int port &#x3D; 10086;            DatagramPacket dp &#x3D; new DatagramPacket(bytes,bytes.length,address,port);            &#x2F;&#x2F;3.发送数据            ds.send(dp);        &#125;        &#x2F;&#x2F;4.释放资源        ds.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-UDP接收数据"><a href="#3-2-UDP接收数据" class="headerlink" title="3.2 UDP接收数据"></a>3.2 UDP接收数据</h3><ul><li>找快递公司（创建接收端的DatagramSocket对象）</li><li>取快递（接收打包好的数据）</li><li>拆分快递（解析数据包）</li><li>签收走人（释放资源）</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.a03udp;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;public class Receive &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F; 接收数据        &#x2F;*         * 需求：         *      UDP发送数据：数据来源于键盘录入，直到数据为886是结束聊天         *      UDP接收数据：因为接收端不知道发送端是什么时候停止发送，故采用死循环接受         * *&#x2F;        &#x2F;&#x2F; 1.创建DatagramSocket的对象（快递公司）        DatagramSocket ds &#x3D; new DatagramSocket(10086);        &#x2F;&#x2F; 2.接收数据包        byte[] bytes &#x3D; new byte[1024];        DatagramPacket dp &#x3D; new DatagramPacket(bytes, bytes.length);        while (true) &#123;            ds.receive(dp);            &#x2F;&#x2F; 3.解析数据包            byte[] data &#x3D; dp.getData();            int len &#x3D; dp.getLength();            String ip &#x3D; dp.getAddress().getHostAddress();            String name &#x3D; dp.getAddress().getHostName();            &#x2F;&#x2F; 4.打印数据包            System.out.println(&quot;ip为&quot; + ip + &quot;, 主机名为&quot; + name + &quot;的电脑，发送了数据：&quot; + new String(data, 0, len));        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-TCP通信程序"><a href="#4-TCP通信程序" class="headerlink" title="4. TCP通信程序"></a>4. TCP通信程序</h2><img src="/2023/05/25/network-program/9.png" class=""><h3 id="4-1-TCP发送数据"><a href="#4-1-TCP发送数据" class="headerlink" title="4.1 TCP发送数据"></a>4.1 TCP发送数据</h3><ul><li>创建客户端的Socket对象与指定服务器连接<ul><li>Socket ( String host, int port )</li></ul></li><li>获取输出流，写数据 <ul><li>OutputStream getOutputStream( )</li></ul></li><li>释放资源<ul><li>close( ) (无返回值)</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.a04tcp;import java.io.IOException;import java.io.OutputStream;import java.net.Socket;public class Client &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F; TCP协议，发送数据        &#x2F;&#x2F; 1.创建Socket对象        &#x2F;&#x2F; 细节:在创建对象的同时会连接服务端        &#x2F;&#x2F;      如果连接不上，代码会报错        Socket socket &#x3D; new Socket(&quot;127.0.0.1&quot;, 10000);        &#x2F;&#x2F; 2.可以从连接通道中获取输出流        OutputStream os &#x3D; socket.getOutputStream();        &#x2F;&#x2F; 写出数据        os.write(&quot;泰裤辣&quot;.getBytes());        &#x2F;&#x2F; 3.释放资源        os.close();        socket.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-TCP接收数据"><a href="#4-2-TCP接收数据" class="headerlink" title="4.2 TCP接收数据"></a>4.2 TCP接收数据</h3><ul><li>创建服务端的Socket对象ServerSocket<ul><li>ServerSocket  ( int port )</li></ul></li><li>监听客户端连接，返回一个Socket对象<ul><li>Socket accept ( )</li></ul></li><li>获取输入流，读数据，并把数据显示在控制台<ul><li>InputStream( ) getInputStream( )</li></ul></li><li>释放资源<ul><li>close( ) (无返回值)</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.a04tcp;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class Server &#123;    public static void main(String[] args) throws IOException &#123;        &#x2F;&#x2F; TCP协议，接收数据        &#x2F;&#x2F; 1.创建对象SocketServer        ServerSocket ss &#x3D; new ServerSocket(10000);        &#x2F;&#x2F; 2.监听客户端的连接        Socket socket &#x3D; ss.accept();        &#x2F;&#x2F; 3.从连接通道中获取输出流读取数据&#x2F;*      InputStream is &#x3D; socket.getInputStream();        InputStreamReader isr &#x3D; new InputStreamReader(is);        BufferedReader br &#x3D; new BufferedReader(isr);        *&#x2F;        BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));        int b;        while((b &#x3D; br.read()) !&#x3D; -1)&#123;            System.out.print((char) b);        &#125;        &#x2F;&#x2F; 4.释放资源        socket.close();        ss.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程编程</title>
      <link href="/2023/05/25/multithreading-program/"/>
      <url>/2023/05/25/multithreading-program/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="1-线程和进程"><a href="#1-线程和进程" class="headerlink" title="1. 线程和进程"></a>1. 线程和进程</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p><h3 id="1-2-进程"><a href="#1-2-进程" class="headerlink" title="1.2 进程"></a>1.2 进程</h3><p>进程是程序的基本执行实体。</p><h2 id="2-并发和并行"><a href="#2-并发和并行" class="headerlink" title="2. 并发和并行"></a>2. 并发和并行</h2><h3 id="2-1-并发"><a href="#2-1-并发" class="headerlink" title="2.1 并发"></a>2.1 并发</h3><p>在同一时刻，有多个指令在单个CPU上<strong>交替</strong>执行。</p><h3 id="2-2-并行"><a href="#2-2-并行" class="headerlink" title="2.2 并行"></a>2.2 并行</h3><p>在同一时刻，有多个指令在单个CPU上<strong>同时</strong>执行。</p><h2 id="3-多线程的实现方式"><a href="#3-多线程的实现方式" class="headerlink" title="3. 多线程的实现方式"></a>3. 多线程的实现方式</h2><p><strong>多线程的三种实现方式对比：</strong></p><img src="/2023/05/25/multithreading-program/1.png" class=""><p><strong>常见的成员方法：</strong></p><img src="/2023/05/25/multithreading-program/2.png" class=""><h3 id="3-1-继承Thread类的方式实现"><a href="#3-1-继承Thread类的方式实现" class="headerlink" title="3.1 继承Thread类的方式实现"></a>3.1 继承Thread类的方式实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.Test1;public class ThreadDemo1 &#123;    public static void main(String[] args) &#123;        &#x2F;*        * 多线程的第一种启动方法        * 1. 自己定义一个类继承Thread        * 2. 重写run方法        * 3. 创建子类的对象并且启动线程        *        * *&#x2F;        MyThread t1 &#x3D; new MyThread();        MyThread t2 &#x3D; new MyThread();        t1.setName(&quot;线程1&quot;);        t2.setName(&quot;线程2&quot;);        &#x2F;&#x2F; 开启线程        t1.start();        t2.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.Test1;public class MyThread extends Thread &#123;    @Override    public void run() &#123; &#x2F;&#x2F; 书写线程执行的代码        for (int i &#x3D; 1; i &lt;&#x3D; 30; i++) &#123;            System.out.println(getName() + &quot;第&quot; + i + &quot;次执行&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-实现Runnable接口的方式实现"><a href="#3-2-实现Runnable接口的方式实现" class="headerlink" title="3.2 实现Runnable接口的方式实现"></a>3.2 实现Runnable接口的方式实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.Test1;public class ThreadDeom2 &#123;    public static void main(String[] args) &#123;        &#x2F;*         * 多线程的第二种启动方法         * 1. 自己定义一个类实现Runnable接口         * 2. 重写run方法         * 3. 创建自己的类的对象         * 4. 创建一个Thread对象并开启线程         *         * *&#x2F;        &#x2F;&#x2F; 创建自己的类（MyRun类）的对象        MyRun mr &#x3D; new MyRun();        &#x2F;&#x2F; 创建线程对象        Thread t1 &#x3D; new Thread(mr);        Thread t2 &#x3D; new Thread(mr);        &#x2F;&#x2F; 给线程设置名字        t1.setName(&quot;线程1&quot;);        t2.setName(&quot;线程2&quot;);        &#x2F;&#x2F; 开启线程        t1.start();        t2.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.Test1;public class MyRun implements Runnable &#123;    @Override    public void run() &#123;        for (int i &#x3D; 0; i &lt; 20; i++) &#123;            &#x2F;* Thread t &#x3D; new Thread.currentThread();             System.out.println(t.getName() + &quot;执行了&quot;);*&#x2F;            System.out.println(Thread.currentThread().getName() + &quot;执行了&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-利用Callable接口和Future接口方式实现"><a href="#3-3-利用Callable接口和Future接口方式实现" class="headerlink" title="3.3 利用Callable接口和Future接口方式实现"></a>3.3 利用Callable接口和Future接口方式实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.Test1;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class ThreadDemo3 &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        &#x2F;*        *  多线程的第三种实现方式：        *       特点：可以获取到多线程运行后的结果        *        *  1. 创建一个类MyCallable实现Callable接口        *  2. 重写call方法（返回值表示多线程运行的结果）        *  3. 创建MyCallable的对象（表示多线程要执行的任务）        *  4. 创建FutureTask的对象（作用是管理多线程运行的结果）        *  5. 创建Thread类的对象，并启动（表示多线程）        * *&#x2F;        &#x2F;&#x2F; 创建MyCallable的对象（表示多线程要执行的任务）        MyCallable mc &#x3D; new MyCallable();        &#x2F;&#x2F; 创建FuturTask的对象（作用管理多线程运行的结果）        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(mc);        &#x2F;&#x2F; 创建线程对象        Thread t1 &#x3D; new Thread(ft);        &#x2F;&#x2F; 启动线程        t1.start();        &#x2F;&#x2F; 获取多线程运行的结果        Integer result &#x3D; ft.get();        System.out.println(result);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.Test1;import java.util.concurrent.Callable;public class MyCallable implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        &#x2F;&#x2F; 求1~100之间的和        int sum &#x3D; 0;        for (int i &#x3D; 1; i &lt;&#x3D; 100; i++) &#123;            sum +&#x3D; i;        &#125;        return sum;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-线程的生命周期"><a href="#3-4-线程的生命周期" class="headerlink" title="3.4 线程的生命周期"></a>3.4 线程的生命周期</h3><img src="/2023/05/25/multithreading-program/3.png" class=""><h2 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h2><h3 id="4-1-Lock锁"><a href="#4-1-Lock锁" class="headerlink" title="4.1 Lock锁"></a>4.1 Lock锁</h3><p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作Lock中提供了获得锁和释放锁的方法</p><ul><li>void lock( ): 获得锁</li><li>void unlock( ): 释放锁</li></ul><p>Lock是接口不能直接实例化,这里采用它的实现类ReentrantLock来实例化ReentrantLock的构造方法</p><ul><li>ReentrantLock( ): 创建一个ReentrantLock的实例</li></ul><p><strong>Thread方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.aa1;public class ThreadDemo &#123;    public static void main(String[] args) &#123;       &#x2F;*           需求：                某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票       *&#x2F;        &#x2F;&#x2F;创建线程对象        MyThread t1 &#x3D; new MyThread();        MyThread t2 &#x3D; new MyThread();        MyThread t3 &#x3D; new MyThread();        &#x2F;&#x2F;起名字        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        &#x2F;&#x2F;开启线程        t1.start();        t2.start();        t3.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.aa1;public class MyThread extends Thread &#123;    &#x2F;&#x2F;表示这个类所有的对象，都共享ticket数据    static int ticket &#x3D; 0;&#x2F;&#x2F;0 ~ 99    @Override    public void run() &#123;            while (true) &#123;                synchronized (MyThread.class) &#123;                &#x2F;&#x2F;同步代码块                if (ticket &lt; 100) &#123;                    try &#123;                        Thread.sleep(10);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    ticket++;                    System.out.println(getName() + &quot;正在卖第&quot; + ticket + &quot;张票！！！&quot;);                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Runnable方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.aa2;public class ThreadDemo &#123;    public static void main(String[] args) &#123;       &#x2F;*           需求：                某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票                利用同步方法完成                技巧：同步代码块       *&#x2F;        MyRunnable mr &#x3D; new MyRunnable();        Thread t1 &#x3D; new Thread(mr);        Thread t2 &#x3D; new Thread(mr);        Thread t3 &#x3D; new Thread(mr);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.aa2;public class MyRunnable implements Runnable &#123;    int ticket &#x3D; 0;    @Override    public void run() &#123;        &#x2F;&#x2F;1.循环        while (true) &#123;            &#x2F;&#x2F;2.同步代码块（同步方法）            if (method()) break;        &#125;    &#125;    &#x2F;&#x2F;this    private synchronized boolean method() &#123;        &#x2F;&#x2F;3.判断共享数据是否到了末尾，如果到了末尾        if (ticket &#x3D;&#x3D; 100) &#123;            return true;        &#125; else &#123;            &#x2F;&#x2F;4.判断共享数据是否到了末尾，如果没有到末尾            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            ticket++;            System.out.println(Thread.currentThread().getName() + &quot;在卖第&quot; + ticket + &quot;张票！！！&quot;);        &#125;        return false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Callable方法：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.aa3;public class ThreadDemo &#123;    public static void main(String[] args) &#123;       &#x2F;*           需求：                某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票                用JDK5的lock实现       *&#x2F;        MyThread t1 &#x3D; new MyThread();        MyThread t2 &#x3D; new MyThread();        MyThread t3 &#x3D; new MyThread();        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.aa3;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyThread extends Thread&#123;    static int ticket &#x3D; 0;    static Lock lock &#x3D; new ReentrantLock();    @Override    public void run() &#123;        &#x2F;&#x2F;1.循环        while(true)&#123;            &#x2F;&#x2F;2.同步代码块            &#x2F;&#x2F;synchronized (MyThread.class)&#123;            lock.lock(); &#x2F;&#x2F;2 &#x2F;&#x2F;3            try &#123;                &#x2F;&#x2F;3.判断                if(ticket &#x3D;&#x3D; 100)&#123;                    break;                    &#x2F;&#x2F;4.判断                &#125;else&#123;                    Thread.sleep(10);                    ticket++;                    System.out.println(getName() + &quot;在卖第&quot; + ticket + &quot;张票！！！&quot;);                &#125;                &#x2F;&#x2F;  &#125;            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                lock.unlock();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-死锁"><a href="#4-1-死锁" class="headerlink" title="4.1 死锁"></a>4.1 死锁</h3><img src="/2023/05/25/multithreading-program/5.png" class=""><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.aa4;public class ThreadDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;  死锁        MyThread t1 &#x3D; new MyThread();        MyThread t2 &#x3D; new MyThread();        t1.setName(&quot;线程A&quot;);        t2.setName(&quot;线程B&quot;);        t1.start();        t2.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.aa4;public class MyThread extends Thread &#123;    static Object objA &#x3D; new Object();    static Object objB &#x3D; new Object();    @Override    public void run() &#123;        &#x2F;&#x2F;1.循环        while (true) &#123;            if (&quot;线程A&quot;.equals(getName())) &#123;                synchronized (objA) &#123;                    System.out.println(&quot;线程A拿到了A锁，准备拿B锁&quot;);&#x2F;&#x2F;A                    synchronized (objB) &#123;                        System.out.println(&quot;线程A拿到了B锁，顺利执行完一轮&quot;);                    &#125;                &#125;            &#125; else if (&quot;线程B&quot;.equals(getName())) &#123;                if (&quot;线程B&quot;.equals(getName())) &#123;                    synchronized (objB) &#123;                        System.out.println(&quot;线程B拿到了B锁，准备拿A锁&quot;);&#x2F;&#x2F;B                        synchronized (objA) &#123;                            System.out.println(&quot;线程B拿到了A锁，顺利执行完一轮&quot;);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-生产者和消费者"><a href="#5-生产者和消费者" class="headerlink" title="5. 生产者和消费者"></a>5. 生产者和消费者</h2><img src="/2023/05/25/multithreading-program/4.png" class=""><h3 id="5-1-常见的成员方法"><a href="#5-1-常见的成员方法" class="headerlink" title="5.1 常见的成员方法"></a>5.1 常见的成员方法</h3><img src="/2023/05/25/multithreading-program/6.png" class=""><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.wait_and_notify;&#x2F;&#x2F; 消费者public class Foodie extends Thread &#123;    public Foodie() &#123;    &#125;    &#x2F;*     * 1. 循环     * 2. 同步代码块     * 3. 判断共享数据是否到了末尾（到了末尾）     * 4. 判断共享数据是否到了末尾（没有到末尾，执行核心代码）     * *&#x2F;    @Override    public void run() &#123;        while (true) &#123;            synchronized (Desk.lock) &#123;                if (Desk.count &#x3D;&#x3D; 0) &#123;                    break;                &#125; else &#123;                    &#x2F;&#x2F; 先判断桌子上是否有面条                    if (Desk.foodflag &#x3D;&#x3D; 0) &#123;                        &#x2F;&#x2F; 如果没有，就等待                        try &#123;                            Desk.lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125; else &#123;                        &#x2F;&#x2F; 将面条的数量 -1                        Desk.count--;                        &#x2F;&#x2F; 如果有，就开吃                        System.out.println(&quot;吃货开吃面条，还剩&quot; + Desk.count + &quot;碗面条&quot;);                        &#x2F;&#x2F; 吃完之后唤醒厨师继续做                        Desk.lock.notifyAll();                        &#x2F;&#x2F; 修改桌子的状态                        Desk.foodflag &#x3D; 0;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.wait_and_notify;&#x2F;&#x2F; 桌子public class Desk &#123;    &#x2F;*    * 作用：控制生产者和消费者的执行    *    * *&#x2F;    &#x2F;&#x2F; 是否有面条， 0表示没有面条， 1表示有面条    public static int foodflag &#x3D; 0;    &#x2F;&#x2F; 面条的总个数    public static int count &#x3D; 10;        &#x2F;&#x2F; 锁的对象    public static Object lock &#x3D; new Object();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.wait_and_notify;&#x2F;&#x2F; 厨师public class Cook extends Thread &#123;    public Cook() &#123;    &#125;    &#x2F;*     * 1. 循环     * 2. 同步代码块     * 3. 判断共享数据是否到了末尾（到了末尾）     * 4. 判断共享数据是否到了末尾（没有到末尾，执行核心代码）     * *&#x2F;    @Override    public void run() &#123;        while (true) &#123;            synchronized (Desk.lock) &#123;                if (Desk.count &#x3D;&#x3D; 0) &#123;                    break;                &#125; else &#123;                    &#x2F;&#x2F; 先判断桌子上是否有面条                    if (Desk.foodflag &#x3D;&#x3D; 1) &#123;                        &#x2F;&#x2F; 如果有面条，就等待                        try &#123;                            Desk.lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125; else &#123;                        &#x2F;&#x2F; 如果没有面条就做面条                        System.out.println(&quot;厨师做了一碗面条！&quot;);                        &#x2F;&#x2F; 修改桌子上的事物状态                        Desk.foodflag &#x3D; 1;                        &#x2F;&#x2F; 唤醒吃货吃面条                        Desk.lock.notifyAll();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.wait_and_notify;&#x2F;&#x2F; 主方法public class ThreadDemo &#123;    public static void main(String[] args) &#123;        &#x2F;*        * 需求：完成生产者和消费者（等待唤醒机制）的代码        *      实现线程轮流交替执行的效果        * *&#x2F;        &#x2F;&#x2F; 创建线程的对象        Cook c &#x3D; new Cook();        Foodie f &#x3D; new Foodie();        &#x2F;&#x2F; 给线程设置名字        c.setName(&quot;厨师&quot;);        f.setName(&quot;吃货&quot;);        &#x2F;&#x2F; 开启线程        c.start();        f.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="5-2-等待唤醒机制"><a href="#5-2-等待唤醒机制" class="headerlink" title="5.2 等待唤醒机制"></a>5.2 等待唤醒机制</h3><img src="/2023/05/25/multithreading-program/7.png" class=""><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.zs_queue;import java.util.concurrent.ArrayBlockingQueue;public class ThreadDemo &#123;    public static void main(String[] args) &#123;        &#x2F;*         * 需求：利用阻塞队列完成生产者和消费者（等待唤醒机制）的代码         *      细节：生产者和消费者必须使用同一个阻塞队列         * *&#x2F;        &#x2F;&#x2F; 1. 创建阻塞队列的对象        ArrayBlockingQueue&lt;String&gt; queue &#x3D; new ArrayBlockingQueue&lt;&gt;(1);        &#x2F;&#x2F; 2. 创建线程的对象，并把阻塞队列传递过去        Cook c &#x3D; new Cook(queue);        Foodie f &#x3D; new Foodie(queue);        &#x2F;&#x2F; 3.开启线程        c.start();        f.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.zs_queue;import java.util.concurrent.ArrayBlockingQueue;public class Foodie extends Thread&#123;    ArrayBlockingQueue&lt;String&gt; queue;    public Foodie(ArrayBlockingQueue&lt;String&gt; queue) &#123;        this.queue &#x3D; queue;    &#125;    @Override    public void run() &#123;        while(true) &#123;            &#x2F;&#x2F; 吃货不断从阻塞队列中获取面条            try &#123;                String food &#x3D; queue.take();                System.out.println(&quot;吃货得到了一碗&quot; + food);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.study.zs_queue;import java.util.concurrent.ArrayBlockingQueue;public class Cook extends Thread&#123;    ArrayBlockingQueue&lt;String&gt; queue;    public Cook(ArrayBlockingQueue&lt;String&gt; queue) &#123;        this.queue &#x3D; queue;    &#125;    @Override    public void run() &#123;        while(true)&#123;            &#x2F;&#x2F; 不断把面条放入阻塞队列中            try &#123;                queue.put(&quot;面条&quot;);                System.out.println(&quot;厨师做好了一碗面条！&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2023/05/25/multithreading-program/8.png" class=""><h2 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6. 线程池"></a>6. 线程池</h2><h3 id="6-1-核心原理"><a href="#6-1-核心原理" class="headerlink" title="6.1 核心原理"></a>6.1 核心原理</h3><ul><li>创建一个池子，池子中是空的。</li><li>提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可。</li><li>但是如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待</li></ul><h3 id="6-2-线程池代码实现"><a href="#6-2-线程池代码实现" class="headerlink" title="6.2 线程池代码实现"></a>6.2 线程池代码实现</h3><ol><li>创建线程池</li><li>提交任务</li><li>所有的任务全部执行完毕，关闭线程池</li></ol><p><strong>线程池的实现方法：</strong></p><p><code>public static ExecutorService newFixedThreadPool(int nThreads) </code> 创建有上限的线程池</p><h3 id="6-3-自定义线程池"><a href="#6-3-自定义线程池" class="headerlink" title="6.3 自定义线程池"></a>6.3 自定义线程池</h3><img src="/2023/05/25/multithreading-program/9.png" class="">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2023/05/23/Bit/"/>
      <url>/2023/05/23/Bit/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算（二进制运算）"><a href="#位运算（二进制运算）" class="headerlink" title="位运算（二进制运算）"></a>位运算（二进制运算）</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-原码，反码，补码"><a href="#1-1-原码，反码，补码" class="headerlink" title="1.1 原码，反码，补码"></a>1.1 原码，反码，补码</h3><h4 id="1-1-1-原码"><a href="#1-1-1-原码" class="headerlink" title="1.1.1 原码"></a>1.1.1 原码</h4><p>将一个整数转换成二进制形式，就是其原码。例如a &#x3D; 6; a 的原码就是<code>0000 0000 0000 0110</code>；更改 a 的值a &#x3D; -18; 此时 a 的原码就是<code>1000 0000 0001 0010</code>。<strong>注意</strong><code>二进制最高位中1代表负数，0代表正数。</code></p><h4 id="1-1-2-反码"><a href="#1-1-2-反码" class="headerlink" title="1.1.2 反码"></a>1.1.2 反码</h4><p>对于正数，它的反码就是其原码（原码和反码相同）；<strong>正数的反码是它本身，负数的反码是将原码中除<code>符号位</code>以外的所有位（数值位）取反</strong>，也就是 0 变成 1，1 变成 0。例如a &#x3D; 6; a 的原码和反码都是<code>0000 0000 0000 0110</code>；更改 a 的值a &#x3D; -18; 此时 a 的反码是<code>1111 1111 1110 1101</code>。</p><h4 id="1-1-3-补码"><a href="#1-1-3-补码" class="headerlink" title="1.1.3 补码"></a>1.1.3 补码</h4><p>对于正数，它的补码就是其原码（<em><strong>正数的原码、反码、补码都相同</strong></em>）；<strong>负数的补码是其反码加 1</strong>。例如a &#x3D; 6; a 的原码、反码、补码都是<code>0000 0000 0000 0110</code>；更改 a 的值a &#x3D; -18; a 的反码是<code>1111 1111 1110 1101</code>，此时 a 的补码是<code>1111 1111 1110 1110</code>。</p><img src="/2023/05/23/Bit/1.png" class=""><h3 id="2-逻辑符号"><a href="#2-逻辑符号" class="headerlink" title="2. 逻辑符号"></a>2. 逻辑符号</h3><blockquote><p>在C++中，8位二进制对应的char类型，范围为-128~127</p></blockquote><p>在 m位二进制数中，为方便起见，通常称<strong>最低位为第0位，从右到左依此类推，最高位为第m-1位。</strong>本书默认使用这种表示方法来指明二进制数以及整数在二进制表示下的位数。</p><table><thead><tr><th></th><th>与</th><th>或</th><th>非</th><th>异或</th></tr></thead><tbody><tr><td>语句</td><td>and</td><td>or</td><td>not</td><td>xor</td></tr><tr><td>符号</td><td>&amp;</td><td>|</td><td>~</td><td>^</td></tr></tbody></table><p>位运算是指直接对整数在二进制形式下进行操作的运算。它包括了按位与运算、按位或运算、按位异或运算、左移运算和右移运算等。以下是位运算的一些知识点总结：</p><ol><li><p>按位与运算（&amp;）：对两个数的每一位进行与操作，只有两个数的对应位都为 1 的时候，结果的对应位才为 1。例如，3 &amp; 5 的结果为 1。（3的二进制为<code>0011</code>, 5的二进制为<code>0101</code> 3 &amp; 5 &#x3D; 1 即<code>0011 &amp; 0101 = 0001</code>）</p></li><li><p>按位或运算（|）：对两个数的每一位进行或操作，只有两个数的对应位其中一个为 1 的时候，结果的对应位就为 1。例如，3 | 5 的结果为 7。（3的二进制为<code>0011</code>, 5的二进制为<code>0101</code> 3 | 5 &#x3D; 7 即<code>0011 | 0101 = 0111</code>）</p></li><li><p>按位异或运算（^）：对两个数的每一位进行异或操作，两个数的对应位相同为0，不同为1。例如，3 ^ 5 的结果为 6。（3的二进制为<code>0011</code>, 5的二进制为<code>0101</code> 3 ^ 5 &#x3D; 6 即<code>0011 ^ 0101 = 0110</code>）</p></li><li><p>左移运算（&lt;&lt;）：把一个数的二进制码向左移动指定的位数，左移时低位补 0。例如，3 &lt;&lt; 2 的结果是 12，即 1100。（3的二进制为<code>0011</code>,  3 &lt;&lt; 2 &#x3D; 12 即<code>0011 &lt;&lt; 2 = 1100</code>）</p></li><li><p>右移运算（&gt;&gt;）：把一个数的二进制码向右移动指定的位数，右移时高位补 0 或 1（取决于该数原来的符号位），右移一位相当于除以 2。例如，3 &gt;&gt; 1 的结果是 1，即 01。（3的二进制为<code>0011</code> ，3 &gt;&gt; 1 &#x3D; 1 即<code>0011 &gt;&gt; 1 = 0001</code>）</p></li><li><p>位取反运算（~）：对一个数的每一位按位取反（0 变为 1，1 变为 0）。例如，3取反的结果是 -4。（3的二进制为<code>0011</code>, 4的二进制为<code>0100</code> ~3 &#x3D; -4 即<code>0011 = 1100</code>）</p></li><li><p>lowbit 函数：lowbit(n) 表示 n 在二进制下的最后一个 1 所代表的数值。lowbit(6) 的结果为 2，即<code>lowbit(0110) = 10 =&gt; 2</code>。</p></li></ol><h2 id="3-Lowbit算法"><a href="#3-Lowbit算法" class="headerlink" title="3. Lowbit算法"></a>3. Lowbit算法</h2><h3 id="3-1-Lowbit算法思想："><a href="#3-1-Lowbit算法思想：" class="headerlink" title="3.1 Lowbit算法思想："></a>3.1 Lowbit算法思想：</h3><img src="/2023/05/23/Bit/2.png" class=""><h3 id="3-2-算法描述"><a href="#3-2-算法描述" class="headerlink" title="3.2 算法描述:"></a>3.2 算法描述:</h3><ul><li><p>例如，求<strong>a &#x3D; 6</strong>的 <strong>二进制为 0 1 1 0</strong></p></li><li><p>lowbit(6) &#x3D; <code>0 1 1 0</code>中最后一位1的值</p></li><li><p>即：输出为 0 1 <code>1</code> 0中最后一位1的值为<code>2</code></p></li></ul><h3 id="3-3-代码模板："><a href="#3-3-代码模板：" class="headerlink" title="3.3 代码模板："></a>3.3 代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 返回n的最后一位1的值int lowbit(int n)&#123;&#x2F;&#x2F; n &amp; -n 等价于 n &amp; (~n + 1)    return n &amp; -n;    &#x2F;&#x2F;return n &amp; (~n + 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-移位运算"><a href="#4-移位运算" class="headerlink" title="4. 移位运算"></a>4. 移位运算</h2><blockquote><p><strong>求n的第k位数字: n &gt;&gt; k &amp; 1</strong></p></blockquote><h3 id="4-1-左移"><a href="#4-1-左移" class="headerlink" title="4.1 左移"></a>4.1 左移</h3><p>在二进制表示下把数字同时向左移动，低位以0填充，高位越界后舍弃。</p><p><strong>既1 &lt;&lt; n &#x3D; $2^n$, n &lt;&lt; 1 &#x3D; 2n</strong></p><h3 id="4-2-算数右移"><a href="#4-2-算数右移" class="headerlink" title="4.2 算数右移"></a>4.2 算数右移</h3><p>在二进制补码表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃。</p><p><strong>既n &gt;&gt; 1 &#x3D; $\lfloor n&#x2F;2.0 \rfloor$</strong></p><h3 id="4-3-逻辑右移"><a href="#4-3-逻辑右移" class="headerlink" title="4.3 逻辑右移"></a>4.3 逻辑右移</h3><p>在二进制补码表示下把数字同时向右移动，高位以0填充，低位越界后舍弃。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度</title>
      <link href="/2023/05/23/High-precision/"/>
      <url>/2023/05/23/High-precision/</url>
      
        <content type="html"><![CDATA[<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1. 高精度加法"></a>1. 高精度加法</h2><blockquote><p>💡 ( A + B ）( len(A) , len（B） &lt;&#x3D; $10^6$)</p></blockquote><h3 id="1-1-算法思想："><a href="#1-1-算法思想：" class="headerlink" title="1.1 算法思想："></a>1.1 算法思想：</h3><p>两个大的数**A + B ( len &lt;&#x3D; $10^6$)<strong>在计算时候，可以使用高精度加法，通过数组的形式存储数位，首先让数组</strong>a[ 0 ]**存储各位，数组的最后一位存储最高位以便于相加进位。</p><img src="/2023/05/23/High-precision/1.png" class=""><h3 id="1-2-算法描述："><a href="#1-2-算法描述：" class="headerlink" title="1.2 算法描述："></a>1.2 算法描述：</h3><ul><li>对于两个高精度的整数 A 和 B 应该是 <strong>String类型</strong>的。</li><li>为了便于相加进位，将数的个位存在 **A[ 0 ]**的位置，数的最高位存在数组的最后一位。</li><li>定义进位 <strong>int t  &#x3D; 0;</strong> 使得 <strong>t &#x3D; A[ i ] + B[ i ] + t ，</strong>输出的数为 <strong>t % 10</strong> ，然后进位 <strong>t</strong> 的值为 <strong>t &#x2F; 10</strong></li><li>将各个位的数和进位相加，push_back依次存到到数组的最后一位。</li><li>按照反位输出。先输出最高位，再输出…..到个位。</li></ul><h3 id="1-3-代码模板："><a href="#1-3-代码模板：" class="headerlink" title="1.3 代码模板："></a>1.3 代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if (A.size() &lt; B.size()) return add(B, A);    vector&lt;int&gt; C;    int t &#x3D; 0;    for (int i &#x3D; 0; i &lt; A.size(); i ++ )    &#123;        t +&#x3D; A[i];        if (i &lt; B.size()) t +&#x3D; B[i];        C.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    if (t) C.push_back(t);    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2. 高精度减法"></a>2. 高精度减法</h2><blockquote><p>💡 ( A - B ）( len(A) , len（B） &lt;&#x3D; $10^6$)</p></blockquote><h3 id="2-1-算法思想："><a href="#2-1-算法思想：" class="headerlink" title="2.1 算法思想："></a>2.1 算法思想：</h3><p>两个大的数**A - B ( len &lt;&#x3D; $10^6$)<strong>在计算时候，可以使用高精度减法，通过数组的形式存储数位，（同高精度加法一样，反位存储数列）首先让数组</strong>a[ 0 ]**存储各位，数组的最后一位存储最高位以便于相加进位。</p><img src="/2023/05/23/High-precision/2.png" class=""><img src="/2023/05/23/High-precision/3.png" class=""><h3 id="2-2-算法描述："><a href="#2-2-算法描述：" class="headerlink" title="2.2 算法描述："></a>2.2 算法描述：</h3><ul><li>对于两个高精度的整数 A 和 B 应该是 <strong>String类型</strong>的。</li><li>为了便于相减借位后结果的长度变短，将数的个位存在 **A[ 0 ]**的位置，数的最高位存在数组的最后一位。</li><li>定义进位 <strong>int t  &#x3D; 0;</strong> 使得 <strong>t &#x3D;  A[ i ] - B[ i ] - t （ t &gt;&#x3D; 0）或t &#x3D;  A[ i ] - B[ i ] + 10 - t （ t &lt;0），**输出的数为**( ( t + 10 ) % 10)，**因为当 **t &gt;&#x3D; 0</strong> 时，得到的数仍为 <strong>t</strong> ，当 <strong>t &lt; 0</strong> 时，得到的值为 <strong>t</strong> 借位后相减的值</li><li>将各个位的数和进位相减，push_back依次存到数组的最后一位。</li><li>按照反位输出。先输出最高位，再输出…..到个位。</li></ul><h3 id="2-3-代码模板："><a href="#2-3-代码模板：" class="headerlink" title="2.3 代码模板："></a>2.3 代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; C &#x3D; A - B, 满足A &gt;&#x3D; B, A &gt;&#x3D; 0, B &gt;&#x3D; 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i ++ )    &#123;        t &#x3D; A[i] - t;        if (i &lt; B.size()) t -&#x3D; B[i];        C.push_back((t + 10) % 10);        if (t &lt; 0) t &#x3D; 1;        else t &#x3D; 0;    &#125;    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-高精度乘低精度"><a href="#3-高精度乘低精度" class="headerlink" title="3. 高精度乘低精度"></a>3. 高精度乘低精度</h2><blockquote><p>💡 ( A *  b ）( len(A)  &lt;&#x3D; $10^6$ ,  b &lt;&#x3D; 10000 )</p></blockquote><h3 id="3-1算法的思想："><a href="#3-1算法的思想：" class="headerlink" title="3.1算法的思想："></a>3.1算法的思想：</h3><p>一个大整数 <strong>A</strong>  和一个小整数 <strong>b</strong> 相乘，<strong>A</strong> 的每一位数 <strong>A [ i ]*<em>乘以 **b** 得到的数加上进位 **t** ，然后*</em>%10**就是该位的结果（既</strong>（ C [ i ] &#x3D; A [ i ] * b）%10）**, **t [ i ] &#x3D; ( A [ i ] * b )  &#x2F; 10**，得到的每一位**C [ i ]**就是相乘得到的结果。</p><img src="/2023/05/23/High-precision/4.png" class=""><h3 id="3-2-算法描述："><a href="#3-2-算法描述：" class="headerlink" title="3.2 算法描述："></a>3.2 算法描述：</h3><ul><li>一个大整数 A 是String类型乘以一个小整数 b （b &lt;&#x3D;10000 ）</li><li>倒叙存入数组每一位数</li><li>结果的每一位数 <strong>C [ i ] &#x3D; A [ i ] * b）%10</strong></li><li>每一个数的进位 <strong>t [ i ] &#x3D; ( A [ i ] * b )  &#x2F; 10</strong></li><li>倒叙输出</li></ul><h3 id="3-3-代码模板："><a href="#3-3-代码模板：" class="headerlink" title="3.3 代码模板："></a>3.3 代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;    int t &#x3D; 0;    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )    &#123;        if (i &lt; A.size()) t +&#x3D; A[i] * b;        C.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-高精度除法"><a href="#4-高精度除法" class="headerlink" title="4. 高精度除法"></a>4. 高精度除法</h2><blockquote><p>💡 ( A  &#x2F;  b ）( len(A)  &lt;&#x3D; $10^6$ ,  b &lt;&#x3D; 10000 )</p></blockquote><h3 id="4-1-算法的思想："><a href="#4-1-算法的思想：" class="headerlink" title="4.1 算法的思想："></a>4.1 算法的思想：</h3><p>一个大整数 <strong>A</strong> 除以一个小整数 <strong>b</strong> ,得到商和余数，余数为 <strong>r &#x3D; r * 10 + A[i</strong>] ;每一位的商为<strong>C.push_back &#x3D;（ r &#x2F; b）</strong>, 然后再使  <strong>r &#x3D;  r % b</strong> 这里可以正序存储法，但是考虑到一个运算中包含了加减乘除，所以使用倒叙存储也是可以的，最后只需要使用<strong>reverse（）</strong>函数反转一下就OK。</p><img src="/2023/05/23/High-precision/5.png" class=""><h3 id="4-2-算法描述："><a href="#4-2-算法描述：" class="headerlink" title="4.2 算法描述："></a>4.2 算法描述：</h3><ul><li>一个大整数 A 是String类型乘以一个小整数 b （b &lt;&#x3D;10000 ）</li><li>倒叙存入数组每一位数（也可以正序存，为了考虑混合运算中包含加减乘除，所以使用倒叙）</li><li>先算余数，再算商。</li><li>每一个数的余数  <strong>r &#x3D; r * 10 + A[i</strong>]</li><li>结果的每一位数 <strong>C [ i ] &#x3D; r &#x2F; b</strong></li><li>倒叙输出</li></ul><h3 id="4-3-代码模板："><a href="#4-3-代码模板：" class="headerlink" title="4.3 代码模板："></a>4.3 代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r &#x3D; 0;    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )    &#123;        r &#x3D; r * 10 + A[i];        C.push_back(r &#x2F; b);        r %&#x3D; b;    &#125;    reverse(C.begin(), C.end());    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法</title>
      <link href="/2023/05/16/Python-grammer/"/>
      <url>/2023/05/16/Python-grammer/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础语法"><a href="#Python基础语法" class="headerlink" title="Python基础语法"></a>Python基础语法</h1><h2 id="1-标识符，关键字和保留字"><a href="#1-标识符，关键字和保留字" class="headerlink" title="1. 标识符，关键字和保留字"></a>1. 标识符，关键字和保留字</h2><h3 id="1-1-标识符"><a href="#1-1-标识符" class="headerlink" title="1.1 标识符"></a>1.1 标识符</h3><p>在 Python 中，标识符是用来给变量、函数、类等命名的。Python 中的标识符需遵循以下规则:</p><ol><li>标识符由字母、数字和下划线组成。</li><li>标识符第一个字符必须是字母或下划线。</li><li>标识符不能是 Python 的关键字（如：if、else、while 等）。</li><li>标识符对大小写敏感，例如：age 和 Age 是两个不同的标识符。</li></ol><p>例如，以下是有效的标识符：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">my_name_namename_1value2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下是无效的标识符：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">1name # 以数字开头if # 是Python的关键字my-name # 中间有横线<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-关键字"><a href="#1-2-关键字" class="headerlink" title="1.2 关键字"></a>1.2 关键字</h3><table><thead><tr><th>False</th><th>def</th><th>if</th><th>raise</th></tr></thead><tbody><tr><td>False</td><td>def</td><td>if</td><td>raise</td></tr><tr><td>None</td><td>del</td><td>import</td><td>return</td></tr><tr><td>True</td><td>elif</td><td>in</td><td>try</td></tr><tr><td>and</td><td>else</td><td>is</td><td>while</td></tr><tr><td>as</td><td>except</td><td>lambda</td><td>with</td></tr><tr><td>assert</td><td>finally</td><td>nonlocal</td><td>yield</td></tr><tr><td>break</td><td>for</td><td>not</td><td></td></tr><tr><td>class</td><td>from</td><td>or</td><td></td></tr><tr><td>continue</td><td>global</td><td>pass</td><td></td></tr></tbody></table><h3 id="1-3-保留字"><a href="#1-3-保留字" class="headerlink" title="1.3 保留字"></a>1.3 保留字</h3><p>Python 没有保留字（Reserved Words）的概念，但是有一些特殊用途的标识符，应当避免使用它们作为变量、函数名等标识符。这些特殊用途的标识符包括：</p><ul><li><code>_</code>（单下划线）：一般用作临时变量、不重要的变量、表示国际化文本中的占位符等。</li><li><code>__</code>（双下划线）：用于类中的私有属性和方法，Python 会自动将属性名改为 <code>_类名__属性名</code> 的形式。</li><li><code>__xxx__</code>（双下划线开头和结尾）：Python 中的特殊方法，如 <code>__init__</code>、<code>__str__</code> 等。</li></ul><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h2><h3 id="2-1-定义变量"><a href="#2-1-定义变量" class="headerlink" title="2.1 定义变量"></a>2.1 定义变量</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">变量名 &#x3D; 值eg ： a &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>标识符命名规则是Python中定义各种名字的时候的统一规范，具体如下：</p><ul><li>由数字、字母、下划线组成</li><li>不能数字开头</li><li>不能使用内置关键字</li><li>严格区分大小写</li></ul><h3 id="2-2-命名习惯"><a href="#2-2-命名习惯" class="headerlink" title="2.2 命名习惯"></a>2.2 命名习惯</h3><ul><li>见名知义。</li><li>大驼峰：即每个单词首字母都大写，例如：<code>MyName</code>。</li><li>小驼峰：第二个（含）以后的单词首字母大写，例如：<code>myName</code>。</li><li>下划线：例如：<code>my_name</code>。</li></ul><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><h3 id="3-1-基础数据类型"><a href="#3-1-基础数据类型" class="headerlink" title="3.1 基础数据类型"></a>3.1 基础数据类型</h3><img src="/2023/05/16/Python-grammer/1.png" class=""><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 这里介绍的是python中的数据类型a &#x3D; 1 # int 整形b &#x3D; 3.14 # float 浮点型c &#x3D; True # bool 布尔型d &#x3D; &#39;LOVE&#39; # str 字符串e &#x3D; [&#39;good&#39;] # list 列表f &#x3D; (10, 20, 30) # tuple 元组g &#x3D; &#123;&#39;Tom&#39;&#125; # set 集合h &#x3D; &#123;&#39;name&#39; : &#39;Tom&#39;, &#39;age&#39; : &#39;18&#39;&#125; # 字典print(type(a))print(type(b))print(type(c))print(type(d))print(type(e))print(type(f))print(type(g))print(type(h))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-数据类型的转换"><a href="#3-2-数据类型的转换" class="headerlink" title="3.2 数据类型的转换"></a>3.2 数据类型的转换</h3><img src="/2023/05/16/Python-grammer/3.png" class=""><p><strong>代码示例：</strong></p><pre class="line-numbers language-pytho" data-language="pytho"><code class="language-pytho"># python中数据的输入(input)# python中输入的用户输入的数据都是当做字符串str来处理password &#x3D; input(&#39;请输入您的密码：&#39;)print(f&#39;您输入的密码是&#123;password&#125;&#39;)print(type(password))  # 数据类型为：strprint(type(int(password))) # 将数据类型转换为 int型list1 &#x3D; [10, 20, 30] # 列表 listprint(list1)         # 列表 list [10, 20, 30]print(tuple(list1))  # 元组 tuple (10, 20, 30)print(set(list1))    # 集合 set  &#123;10, 20, 30&#125;print(type(list1))   # 若未标明转换的数据类型，则仍然输出原始的数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h2><h3 id="4-1-算数运算符"><a href="#4-1-算数运算符" class="headerlink" title="4.1 算数运算符"></a>4.1 算数运算符</h3><blockquote><p>💡 <em><em>混合运算优先级顺序：()高于 *</em> 高于 * &#x2F; &#x2F;&#x2F; % 高于 + -</em>*</p></blockquote><img src="/2023/05/16/Python-grammer/2.png" class=""><p>*** 这里是和C语言不同的算数运算符***</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; 11 &#x2F;&#x2F; 2  # 相当于int型的整数除法y &#x3D; 2 ** 4   # 这里是求2的4次方print(x, y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-2-逻辑运算符"><a href="#4-2-逻辑运算符" class="headerlink" title="4.2 逻辑运算符"></a>4.2 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与”:如果×为False，x and y返回False，否则它返回y的值</td><td>True and False，返回False。</td></tr><tr><td>or</td><td>x or y</td><td>布尔”与”:如果×为False，x and y返回False，否则它返回y的值</td><td>False or True，返回True。</td></tr><tr><td>not</td><td>not x</td><td>布尔”与”:如果×为False，x and y返回False，否则它返回y的值</td><td>not True返回False, not False返回True</td></tr></tbody></table><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 多个变量赋值um1, float1, str1 &#x3D; 10, 0.5, &#39;hello world&#39;print(um1,  float1,  str1)a &#x3D; b &#x3D; c &#x3D; d &#x3D; 10print(a, b, c, d)aa &#x3D; 4bb &#x3D; 6cc &#x3D; 4dd &#x3D; 0print(aa &gt; bb)  # 输出Falseprint(aa &#x3D;&#x3D; cc) # 输出True# 逻辑运算 和(and)  或(or)print(aa &gt; bb) and (aa &#x3D;&#x3D; cc) # 输出Falseprint(aa &#x3D;&#x3D; cc) or (aa &gt; bb)  # 输出Trueprint(aa and dd) # 不成立 输出0print(aa and bb) # 成立 输出的是较大的数 bb &#x3D; 6print(aa or dd)  # 成立 输出的是较大的数 aa &#x3D; 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-补充知识"><a href="#4-3-补充知识" class="headerlink" title="4.3 补充知识"></a>4.3 补充知识</h3><p><strong>数字之间的逻辑运算</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; 0b &#x3D; 1c &#x3D; 2# and运算符，只要有一个值为0，则结果为0，否则结果为最后一个非0数字print(a and b)  # 0print(b and a)  # 0print(a and c)  # 0print(c and a)  # 0print(b and c)  # 2print(c and b)  # 1# or运算符，只有所有值为0结果才为0，否则结果为第一个非0数字print(a or b)  # 1print(a or c)  # 2print(b or c)  # 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-控制语句"><a href="#5-控制语句" class="headerlink" title="5. 控制语句"></a>5. 控制语句</h2><h3 id="5-1-while循环"><a href="#5-1-while循环" class="headerlink" title="5.1 while循环"></a>5.1 while循环</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">while 条件:    条件成立重复执行的代码1    条件成立重复执行的代码2    ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例代码：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># Python中的while循环n &#x3D; 10while n:    print(&quot;I&#39;m a good boy&quot;)    n -&#x3D; 5# 求1——100的累加和i &#x3D; 1result &#x3D; 0while i &lt;&#x3D; 100:    result +&#x3D; i    i +&#x3D; 1# 输出5050print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-for循环"><a href="#5-2-for循环" class="headerlink" title="5.2 for循环"></a>5.2 for循环</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># for循环&#39;&#39;&#39;(切记 &quot; : &quot; 这个符号)for 临时存储变量 in 序列：    if 条件 :&#39;&#39;&#39;str &#x3D; &#39;Hello world&#39;for i in str:    if i &#x3D;&#x3D; &#39;l&#39;:        continue    print(i)# 使用for循环遍历输出列表中的值cars &#x3D; [&#39;bwn&#39;, &#39;audi&#39;, &#39;bens&#39;, &#39;toyota&#39;]for car in cars:    if car &#x3D;&#x3D; &#39;bens&#39;:        print(car.upper())    else:        print(car.title())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-循环的嵌套"><a href="#5-3-循环的嵌套" class="headerlink" title="5.3 循环的嵌套"></a>5.3 循环的嵌套</h3><h4 id="5-3-1-while循环嵌套"><a href="#5-3-1-while循环嵌套" class="headerlink" title="5.3.1  while循环嵌套"></a>5.3.1  while循环嵌套</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">while 条件1:    条件1成立执行的代码    ......    while 条件2:        条件2成立执行的代码        ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例代码：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 重复打印9行表达式j &#x3D; 1while j &lt;&#x3D; 9:    # 打印一行里面的表达式 a * b &#x3D; a*b    i &#x3D; 1    while i &lt;&#x3D; j:        print(f&#39;&#123;i&#125;*&#123;j&#125;&#x3D;&#123;j*i&#125;&#39;, end&#x3D;&#39;\\t&#39;)        i +&#x3D; 1    print()    j +&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-while…else…语句"><a href="#5-3-2-while…else…语句" class="headerlink" title="5.3.2 while…else…语句"></a>5.3.2 while…else…语句</h4><blockquote><p>💡 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行,都是continue语句结束可以执行else语句。</p></blockquote><p><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">while 条件:    条件成立重复执行的代码else:    循环正常结束之后要执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例代码：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">i &#x3D; 1while i &lt;&#x3D; 5:    print(&#39;Hello World&#39;)    i +&#x3D; 1else:    print(&#39;执行完毕&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-3-for…else…-语句"><a href="#5-3-3-for…else…-语句" class="headerlink" title="5.3.3  for…else… 语句"></a>5.3.3  for…else… 语句</h4><blockquote><p>💡 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行,都是continue语句结束可以执行else语句。</p></blockquote><p><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for 临时变量 in 序列:    重复执行的代码    ...else:    循环正常结束之后要执行的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-跳出循环"><a href="#5-4-跳出循环" class="headerlink" title="5.4 跳出循环"></a>5.4 跳出循环</h3><blockquote><p>💡  break和continue是循环中满足一定条件退出循环的两种不同方式。</p></blockquote><pre class="line-numbers language-python" data-language="python"><code class="language-python"># break实例i &#x3D; 1while i &lt;&#x3D; 5:    if i &#x3D;&#x3D; 4:        print(f&#39;吃饱了不吃了&#39;)        break    print(f&#39;吃了第&#123;i&#125;个苹果&#39;)    i +&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-操作列表（数组）"><a href="#6-操作列表（数组）" class="headerlink" title="6. 操作列表（数组）"></a>6. 操作列表（数组）</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># python中的列表就相当于C语言中的数组bicycles &#x3D; [&#39;trek&#39;, &#39;cannon dale&#39;, &#39;redline&#39;, &#39;specialized&#39;]print(bicycles[0]) # 输出：trek<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="7-字典（键值对）"><a href="#7-字典（键值对）" class="headerlink" title="7. 字典（键值对）"></a>7. 字典（键值对）</h2><h3 id="7-1-字典的定义及字典元素的输出"><a href="#7-1-字典的定义及字典元素的输出" class="headerlink" title="7.1 字典的定义及字典元素的输出"></a>7.1 字典的定义及字典元素的输出</h3><blockquote><p>💡 <strong>在Python中键和值之间用冒号分隔，而键—值对之间用逗号分隔。</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#字典就是给每个集合中的么个值一个关键字，简称键值对girlfriend &#x3D; &#123;&#39;tall&#39; : 160, &#39;type&#39; : &#39;cute&#39;&#125;print(girlfriend[&#39;tall&#39;]) # 160print(girlfriend[&#39;type&#39;]) # cute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>添加键值对</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">girlfriend &#x3D; &#123;&#39;tall&#39; : 160, &#39;type&#39; : &#39;cute&#39;&#125;print(girlfriend[&#39;tall&#39;])print(girlfriend[&#39;type&#39;])girlfriend[&#39;love&#39;] &#x3D;&#39;DD&#39; # 在字典的尾部添加一个键值对girlfriend[&#39;intersted&#39;] &#x3D; &#39;aiai&#39;# 字典的尾部插入一个键值对print(girlfriend)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建一个新的字典</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 创建一个新的字典boyfriend &#x3D; &#123;&#125;boyfriend[&#39;name&#39;] &#x3D; &#39;HCD&#39;boyfriend[&#39;fun&#39;] &#x3D; &#39;basketball&#39;print(boyfriend)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改字典中的值</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">boyfriend &#x3D; &#123;&#125;boyfriend[&#39;name&#39;] &#x3D; &#39;HCD&#39;boyfriend[&#39;fun&#39;] &#x3D; &#39;basketball&#39;print(boyfriend) # &#123;&#39;name&#39;: &#39;HCD&#39;, &#39;fun&#39;: &#39;basketball&#39;&#125;# 修改字典中的值boyfriend[&#39;fun&#39;] &#x3D; &#39;computer&#39;print(boyfriend) # &#123;&#39;name&#39;: &#39;HCD&#39;, &#39;fun&#39;: &#39;computer&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出键值对（del语句）</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 删除键值对boyfriend1 &#x3D;&#123;&#39;name&#39; : &#39;HCD&#39;, &#39;fun&#39; : &#39;computer&#39;, &#39;type&#39; : &#39;sun&#39;&#125;del boyfriend1[&#39;fun&#39;] # 删除使用 del 语句print(boyfriend1) # &#123;&#39;name&#39;: &#39;HCD&#39;, &#39;type&#39;: &#39;sun&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类似对象组成的字典（方便观看和查找键值对）</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 类似对象的键值对favorite_languages &#x3D; &#123;    &#39;jen&#39;: &#39;python&#39;,    &#39;sarah&#39;: &#39;c&#39;,    &#39;edward&#39;: &#39;ruby&#39;,    &#39;phil&#39;: &#39;python&#39;,&#125;# jen favorite langeuages is Python.print(f&#39;jen favorite langeuages is &#39;+ favorite_languages[&#39;jen&#39;].title() + &#39;.&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-遍历字典"><a href="#7-2-遍历字典" class="headerlink" title="7.2 遍历字典"></a>7.2 遍历字典</h3><p>遍历字典需要使用for循环，需要声明两个变量，可用于作为存储键值对的关键字，for语句的第二部分包含字典名和方法items()，它返回一个键—值对列表。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 遍历字典的for循环方法（需要用到items()方法）for 变量1, 变量2 in 字典名称 . items(): # 这里是需要遍历的字典favorite_languages &#x3D; &#123;    &#39;jen&#39;: &#39;python&#39;,    &#39;sarah&#39;: &#39;c&#39;,    &#39;edward&#39;: &#39;ruby&#39;,    &#39;phil&#39;: &#39;python&#39;,&#125;# 遍历字典for name, language in favorite_languages.items():    print(&#39;\\nname : &#39; + name)    print(&#39;language : &#39; + language)# 下面是输出的语句&#39;&#39;&#39;name : jenlanguage : pythonname : sarahlanguage : cname : edwardlanguage : rubyname : phillanguage : python&#39;&#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>遍历字典中的所有键（ key()方法 ）</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"> # 这里是需要遍历的字典favorite_languages &#x3D; &#123;    &#39;jen&#39;: &#39;python&#39;,    &#39;sarah&#39;: &#39;c&#39;,    &#39;edward&#39;: &#39;ruby&#39;,    &#39;phil&#39;: &#39;python&#39;,&#125;# 遍历字典中的所有键for name in favorite_languages.keys():    print(name.title())# 输出&#39;&#39;&#39;JenSarahEdwardPhil&#39;&#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>按顺序遍历字典中的所有键</strong></p><p>要以特定的顺序返回元素，一种办法是在for循环中对返回的键进行排序。为此，可使用函数sorted()来获得按特定顺序排列的键列表的副本。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 这里是需要遍历的字典favorite_languages &#x3D; &#123;    &#39;jen&#39;: &#39;python&#39;,    &#39;sarah&#39;: &#39;c&#39;,    &#39;edward&#39;: &#39;ruby&#39;,    &#39;phil&#39;: &#39;python&#39;,&#125;# 按顺序遍历字典中的所有键for name in sorted(favorite_languages.keys()):print(name.title())# 输出&#39;&#39;&#39;EdwardJenPhilSarah&#39;&#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>遍历字典中的所有值（ values()方法 ）</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"> # 这里是需要遍历的字典favorite_languages &#x3D; &#123;    &#39;jen&#39;: &#39;python&#39;,    &#39;sarah&#39;: &#39;c&#39;,    &#39;edward&#39;: &#39;ruby&#39;,    &#39;phil&#39;: &#39;python&#39;,&#125;# 遍历字典中的所有值for value in favorite_languages.values():    print(value.title())# 输出&#39;&#39;&#39;PythonCRubyPython&#39;&#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>💡 <strong>有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。</strong></p></blockquote><p><strong>在列表中存储字典</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 嵌套alien_0 &#x3D; &#123;&#39;color&#39;: &#39;green&#39;, &#39;points&#39;: 5&#125;alien_1 &#x3D; &#123;&#39;color&#39;: &#39;yellow&#39;, &#39;points&#39;: 10&#125;alien_2 &#x3D; &#123;&#39;color&#39;: &#39;red&#39;, &#39;points&#39;: 15&#125;aliens &#x3D; [alien_0, alien_1, alien_2] # 将字典存储到列表中for alien in aliens: # 输出列表中的所有字典     print(alien)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在字典中存储列表</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在字典中存储列表favorite_languages &#x3D; &#123;&#39;jen&#39;: [&#39;python&#39;, &#39;c&#39;],&#39;sarah&#39;: [&#39;c&#39;],&#39;edward&#39;: [&#39;ruby&#39;, &#39;go&#39;],&#39;phil&#39;: [&#39;python&#39;, &#39;vue&#39;],&#125;for name, language in favorite_languages.items():    print(&quot;\\n&quot; + name.title() + &quot; is favorite languages1 are: &quot;)    for food in language:        print(&#39;\\t The favorite language2 is : &#39; + food.title())&#39;&#39;&#39;Jen is favorite languages1 are:  The favorite language2 is : Python The favorite language2 is : CSarah is favorite languages1 are:  The favorite language2 is : CEdward is favorite languages1 are:  The favorite language2 is : Ruby The favorite language2 is : GoPhil is favorite languages1 are:  The favorite language2 is : Python The favorite language2 is : Vue进程已结束,退出代码0&#39;&#39;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路</title>
      <link href="/2023/05/15/Shortest-path/"/>
      <url>/2023/05/15/Shortest-path/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路-Dijkstra-Bellman-ford-SPFA-Floyd"><a href="#最短路-Dijkstra-Bellman-ford-SPFA-Floyd" class="headerlink" title="最短路(Dijkstra, Bellman-ford, SPFA, Floyd)"></a>最短路(Dijkstra, Bellman-ford, SPFA, Floyd)</h1><img src="/2023/05/15/Shortest-path/1.png" class=""><h2 id="1-Dijsttra"><a href="#1-Dijsttra" class="headerlink" title="1. Dijsttra"></a>1. Dijsttra</h2><h3 id="1-1-素版Dijkstra算法（稠密图——邻接矩阵）"><a href="#1-1-素版Dijkstra算法（稠密图——邻接矩阵）" class="headerlink" title="1.1 素版Dijkstra算法（稠密图——邻接矩阵）"></a>1.1 素版Dijkstra算法（稠密图——邻接矩阵）</h3><blockquote><p>💡时间复杂度：$O(N^2)$</p></blockquote><h4 id="1-1-1-朴素版Dijkstra算法思想："><a href="#1-1-1-朴素版Dijkstra算法思想：" class="headerlink" title="1.1.1 朴素版Dijkstra算法思想："></a>1.1.1 朴素版Dijkstra算法思想：</h4><p>迪杰斯特拉（dijkstra）算法是一种求单源最短路的算法，假若从一个点a出发，终点是s，dijkstra算法可以求出从a到达s的最短路径（所有边权都是正数）。</p><img src="/2023/05/15/Shortest-path/1.gif" class=""><h4 id="1-1-2-朴素版Dijkstra算法实现方式："><a href="#1-1-2-朴素版Dijkstra算法实现方式：" class="headerlink" title="1.1.2 朴素版Dijkstra算法实现方式："></a>1.1.2 朴素版Dijkstra算法实现方式：</h4><ul><li>初始化距离<strong>dist[1] &#x3D; 0 , dist[i] &#x3D; 无穷</strong> （表示起点到i点的距离）</li><li>循环n次<ul><li>将已确定的最短距离的点存放到数组<strong>dist</strong>中</li><li>找到不在<strong>dist</strong>中且距离最近的点—&gt;<strong>t</strong></li><li>将 <strong>t</strong> 加到<strong>dist</strong>中，用 <strong>t</strong> 更新其它点的距离</li><li>判断<strong>dist[x] &gt; dist[t] + w</strong></li></ul></li></ul><h4 id="1-1-3-朴素版Dijkstra算法代码模板："><a href="#1-1-3-朴素版Dijkstra算法代码模板：" class="headerlink" title="1.1.3 朴素版Dijkstra算法代码模板："></a>1.1.3 朴素版Dijkstra算法代码模板：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数int g[N][N];  &#x2F;&#x2F; 存储每条边int dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离bool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);&#x2F;&#x2F;将所有点的距离都初始化为无穷大    dist[1] &#x3D; 0;&#x2F;&#x2F;初始化距离，这里表示第一个点的距离为0    for (int i &#x3D; 0; i &lt; n - 1; i ++ )    &#123;        int t &#x3D; -1;     &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))                t &#x3D; j;        &#x2F;&#x2F; 用t更新其他点的距离        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);        st[t] &#x3D; true;    &#125;    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-堆优化版Dijkstra算法（稀疏图——邻接表）"><a href="#1-2-堆优化版Dijkstra算法（稀疏图——邻接表）" class="headerlink" title="1.2 堆优化版Dijkstra算法（稀疏图——邻接表）"></a>1.2 堆优化版Dijkstra算法（稀疏图——邻接表）</h3><blockquote><p>💡 <strong>时间复杂度：</strong>$O(M*log N)$</p></blockquote><h4 id="1-2-1-堆优化版Dijkstra算法思想："><a href="#1-2-1-堆优化版Dijkstra算法思想：" class="headerlink" title="1.2.1 堆优化版Dijkstra算法思想："></a>1.2.1 堆优化版Dijkstra算法思想：</h4><table><thead><tr><th>方法</th><th>描述</th><th>示例</th><th>时间复杂度</th></tr></thead><tbody><tr><td>push</td><td>将元素插入堆</td><td>q.push(x)</td><td>O(log n)</td></tr><tr><td>pop</td><td>删除堆顶元素</td><td>q.pop()</td><td>O(long n)</td></tr><tr><td>top</td><td>查询堆顶元素</td><td>int x &#x3D; q.top()</td><td>O（1）</td></tr></tbody></table><img src="/2023/05/15/Shortest-path/2.png" class=""><h4 id="1-2-2-堆优化版Dijkstra算法实现方式："><a href="#1-2-2-堆优化版Dijkstra算法实现方式：" class="headerlink" title="1.2.2 堆优化版Dijkstra算法实现方式："></a>1.2.2 堆优化版Dijkstra算法实现方式：</h4><ul><li>初始化距离<strong>dist[1] &#x3D; 0 , dist[i] &#x3D; 无穷</strong> （表示起点到i点的距离）</li><li>循环n次（dist为已经确定最短距离的点）<ul><li>找到不在<strong>dist</strong>中且离起点最近的点，赋值<strong>→t</strong>（优化：小根堆）</li><li>将 <strong>t 加入</strong>如到<strong>dist</strong>中</li><li>用 <strong>t</strong> 更新所有点的距离（优化：用堆更新了每个点的时间复杂度为O（log n））</li></ul></li></ul><h4 id="1-2-3-堆优化版的Dijkstra算法代码模板："><a href="#1-2-3-堆优化版的Dijkstra算法代码模板：" class="headerlink" title="1.2.3 堆优化版的Dijkstra算法代码模板："></a>1.2.3 堆优化版的Dijkstra算法代码模板：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II时间复杂度 O(mlogn)O(mlogn), nn 表示点数，mm 表示边数typedef pair&lt;int, int&gt; PII;int n;      &#x2F;&#x2F; 点的数量int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边int dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离bool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0, 1&#125;);      &#x2F;&#x2F; first存储距离，second存储节点编号    while (heap.size())    &#123;        auto t &#x3D; heap.top();        heap.pop();        int ver &#x3D; t.second, distance &#x3D; t.first;        if (st[ver]) continue;        st[ver] &#x3D; true;        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if (dist[j] &gt; dist[ver] + w[i])            &#123;                dist[j] &#x3D; dist[ver] + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-Bellman-Ford"><a href="#2-Bellman-Ford" class="headerlink" title="2. Bellman-Ford"></a>2. Bellman-Ford</h2><blockquote><p>💡 <strong>时间复杂度：</strong>$O(N*M)$</p></blockquote><h3 id="2-1-Bellman-Ford算法思想："><a href="#2-1-Bellman-Ford算法思想：" class="headerlink" title="2.1 Bellman-Ford算法思想："></a>2.1 Bellman-Ford算法思想：</h3><p>Bellman_Ford算法的原理是对n条边进行n - 1次松弛操作，得到所有可能的最短路径。由于是有<strong>步数限制和负数边</strong>存在，我们不能使用Djkstra算法，但是Bellman_Ford算法的实现和Djkstra算法在思路上还是差不多。Ballman_Ford算法可以解决存在负权边的问题，对于一些有步数限制的问题只能使用Bellman_ford算法，但是其他的负权边问题用SPFA解决会更佳。</p><h3 id="2-2-Bellman-Ford算法实现方式："><a href="#2-2-Bellman-Ford算法实现方式：" class="headerlink" title="2.2 Bellman-Ford算法实现方式："></a>2.2 Bellman-Ford算法实现方式：</h3><ul><li>初始化距离<strong>dist[1] &#x3D; 0 , dist[i] &#x3D; 无穷</strong> （表示起点到i点的距离）</li><li><strong>循环n次（外层）</strong></li><li>循环m次（内层）→遍历所有边<ul><li>每一次更新一个节点的最短距离（<strong>dist[b] &#x3D; dist[a] + w</strong>(松弛操作)）</li><li>循环n次后所有边都满足：<strong>dist[b] &#x3D; dist[a] + w</strong>(三角不等式)</li></ul></li></ul><p><strong>迭代k次的意义：从1号点结果k条边到每一个点的最短距离。</strong></p><h3 id="2-3-Bellman-Ford算法代码模板："><a href="#2-3-Bellman-Ford算法代码模板：" class="headerlink" title="2.3 Bellman-Ford算法代码模板："></a>2.3 Bellman-Ford算法代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。int n, m;       &#x2F;&#x2F; n表示点数，m表示边数int dist[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离struct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重&#123;    int a, b, w;&#125;edges[M];&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    &#x2F;&#x2F; 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i &#x3D; 0; i &lt; n; i ++ )    &#123;        for (int j &#x3D; 0; j &lt; m; j ++ )        &#123;            int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] &#x3D; dist[a] + w;        &#125;    &#125;    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-SPFA"><a href="#3-SPFA" class="headerlink" title="3. SPFA"></a>3. SPFA</h2><blockquote><p>💡 <strong>时间复杂度：</strong>$O(N)或(N * M)$</p></blockquote><h3 id="3-1-SPFA算法思想："><a href="#3-1-SPFA算法思想：" class="headerlink" title="3.1 SPFA算法思想："></a>3.1 SPFA算法思想：</h3><p><em><strong>代码跟堆优化版Dijkstra相似，只用更改一下spfa函数即可</strong></em></p><p>SPFA算法就是将bellman_ford算法加上了队列优化，在使用bellman_ford算法时<strong>对每一条边都要进行遍历</strong>，实际上是将每一个边都进行了n - 1 次松弛操作，实际上我们没必要松弛每一个点，那么我们希望去掉一些无用的松弛操作，这个时候我们用<strong>队列</strong>来维护哪些点可能会需要松弛操作，这样就能<strong>只访问必要的边</strong>，SPFA同样能处理负权回路的图。</p><h3 id="3-2-SPFA算法实现方式："><a href="#3-2-SPFA算法实现方式：" class="headerlink" title="3.2 SPFA算法实现方式："></a>3.2 SPFA算法实现方式：</h3><ul><li>初始化距离<strong>dist[1] &#x3D; 0 , dist[i] &#x3D; 无穷</strong> （表示起点到i点的距离）</li><li>将源点的队头元素入列给t， 然后弹出</li><li>队首 <strong>t</strong> 出队，<strong>并将 t 标记为没有访问过</strong>，方便下次入队(进行松弛操作)</li><li>遍历以队首为起点的所有边<strong>（t, i)</strong> ,如果 <strong>dist[ i ] &gt; dist [ t ] + w [ i ]</strong> ,更新 <strong>dist [ i ]</strong></li><li>如果 i不在队列中，则标记入队，一直循环到为空为止</li></ul><h3 id="3-3-SPFA代码模板："><a href="#3-3-SPFA代码模板：" class="headerlink" title="3.3 SPFA代码模板："></a>3.3 SPFA代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), nn 表示点数，mm 表示边数int n;      &#x2F;&#x2F; 总点数int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边int dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    queue&lt;int&gt; q;    q.push(1);    st[1] &#x3D; true;    while (q.size())    &#123;        auto t &#x3D; q.front();        q.pop();        st[t] &#x3D; false;        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] &#x3D; dist[t] + w[i];                if (!st[j])     &#x2F;&#x2F; 如果队列中已存在j，则不需要将j重复插入                &#123;                    q.push(j);                    st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-SPFA算法判断图中是否存在负环问题"><a href="#3-4-SPFA算法判断图中是否存在负环问题" class="headerlink" title="3.4 SPFA算法判断图中是否存在负环问题"></a>3.4 SPFA算法判断图中是否存在负环问题</h3><p><strong>判断存在负环的思想：</strong></p><ul><li><p>dsit[ x ] 表示的是1号点到x号点的距离</p></li><li><p>cnt[ x ]表示的是1号点到x号点的边的数量</p></li><li><p>判断负环是增加了更新的步骤</p><ul><li>dist [x] &#x3D; dist[t] + w[i]（这里是更新1号点到x号点的距离，用dist[t]更新）</li><li>cnt[x] &#x3D; cnt[t] + 1（这里入下图所示，因为1号点到t号点的距离更新了，1号点到x号点的边数相对于1号点到t号点多了1，所以ccnt[x]就应该加上1）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数int n;      &#x2F;&#x2F; 总点数int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边int dist[N], cnt[N];        &#x2F;&#x2F; dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中&#x2F;&#x2F; 如果存在负环，则返回true，否则返回false。bool spfa()&#123;    &#x2F;&#x2F; 不需要初始化dist数组    &#x2F;&#x2F; 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。&#x2F;&#x2F;*****************************************************    queue&lt;int&gt; q;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        q.push(i);        st[i] &#x3D; true;    &#125;&#x2F;&#x2F;****************************************************    while (q.size())    &#123;        auto t &#x3D; q.front();        q.pop();        st[t] &#x3D; false;        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] &#x3D; dist[t] + w[i];                cnt[j] &#x3D; cnt[t] + 1;                if (cnt[j] &gt;&#x3D; n) return true;       &#x2F;&#x2F; 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环                if (!st[j])                &#123;                    q.push(j);                    st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="4-Floyd"><a href="#4-Floyd" class="headerlink" title="4. Floyd"></a>4. Floyd</h2><blockquote><p>💡 <strong>时间复杂度：</strong>$O(N^3)$</p></blockquote><h3 id="4-1-Floyd算法思想："><a href="#4-1-Floyd算法思想：" class="headerlink" title="4.1 Floyd算法思想："></a>4.1 Floyd算法思想：</h3><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，算法的主要思想基于动态规划（Dp)。</p><h3 id="4-2-Floyd算法实现方式："><a href="#4-2-Floyd算法实现方式：" class="headerlink" title="4.2 Floyd算法实现方式："></a>4.2 Floyd算法实现方式：</h3><ul><li>邻接矩阵(二维数组)dist储存路径，数组中的值开始表示点点之间初始直接路径，最终是点点之间的最小路径，有两点需要注意的，第一是如果没有直接相连的两点那么默认为一个很大的值(不要因为计算溢出成负数)，第二是自己和自己的距离要为 0。</li><li>状态转移方程（其中**d[i][j]**的意思可以理解为点a到点b的最短路径,所以**d[i][k]**的意思可以理解为**i到k的最短路径d[k][j]**的意思为**k到j的最短路径.**）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">dp[i][j]&#x3D;min(dp[i][j],dp[i][k]+dp[k][j])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>从第1个到第n个点依次加入松弛计算，每个点加入进行试探枚举是否有路径长度被更改(自己能否更新路径)。顺序加入(k枚举)松弛的点时候，需要遍历图中每一个点对(i,j双重循环)，判断每一个点对距离是否因为加入的点而发生最小距离变化，如果发生改变(变小)，那么两点(i,j)距离就更改。</li><li>重复上述直到最后插点试探完成。</li></ul><h3 id="4-3-Floyd代码模板："><a href="#4-3-Floyd代码模板：" class="headerlink" title="4.3 Floyd代码模板："></a>4.3 Floyd代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">floyd算法 —— 模板题 AcWing 854. Floyd求最短路时间复杂度是 O(n3)O(n3), nn 表示点数初始化：    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;            else d[i][j] &#x3D; INF;&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离void floyd()&#123;    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树和图的遍历</title>
      <link href="/2023/05/15/Tree-graph-traversal/"/>
      <url>/2023/05/15/Tree-graph-traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h1><h3 id="1-树与图的存储"><a href="#1-树与图的存储" class="headerlink" title="1. 树与图的存储"></a>1. 树与图的存储</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">**树与图的存储**树是一种特殊的图，与图的存储方式相同。对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。因此我们可以只考虑有向图的存储。(1) 邻接矩阵：g[a][b] 存储边a-&gt;b(2) 邻接表： h[0] -&gt; a -&gt; b -&gt; c -&gt; d -&gt; null  h[1] -&gt; a -&gt; b -&gt; nullh[2] -&gt; a -&gt; nullh[3] -&gt; null&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;&#x2F;&#x2F; 添加一条边a-&gt;bvoid add(int a, int b)&#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;&#x2F;&#x2F; 初始化idx &#x3D; 0;memset(h, -1, sizeof h);树与图的遍历时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-树的深度优先遍历"><a href="#2-树的深度优先遍历" class="headerlink" title="2. 树的深度优先遍历"></a>2. 树的深度优先遍历</h2><h3 id="2-1-树的深度优先遍历的算法思想："><a href="#2-1-树的深度优先遍历的算法思想：" class="headerlink" title="2.1 树的深度优先遍历的算法思想："></a>2.1 树的深度优先遍历的算法思想：</h3><img src="/2023/05/15/Tree-graph-traversal/1.gif" class=""><p>树的深度优先遍历，（既一条道走到黑），先从第一个点开始往下遍历，依次遍历以下的每一个点，直到遍历到最后的点为止。</p><h3 id="2-2-代码模板："><a href="#2-2-代码模板：" class="headerlink" title="2.2 代码模板："></a>2.2 代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">深度优先遍历 —— 模板题 AcWing 846. 树的重心int dfs(int u)&#123;    st[u] &#x3D; true; &#x2F;&#x2F; st[u] 表示点u已经被遍历过    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])    &#123;        int j &#x3D; e[i];        if (!st[j]) dfs(j);    &#125;&#125;int dfs(int u)&#123;    st[u] &#x3D; true;        int sum &#x3D; 1, res &#x3D; 0;    for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])    &#123;        int j &#x3D; e[i];        if(!st[j])        &#123;            int s &#x3D; dfs(j);            res &#x3D; max(res, s);            sum +&#x3D; s;        &#125;    &#125;    res &#x3D; max(res, n - sum);        ans &#x3D; min(ans, res);        return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-树的宽度优先遍历"><a href="#3-树的宽度优先遍历" class="headerlink" title="3. 树的宽度优先遍历"></a>3. 树的宽度优先遍历</h2><h3 id="3-1-树的宽度优先遍历的算法思想："><a href="#3-1-树的宽度优先遍历的算法思想：" class="headerlink" title="3.1 树的宽度优先遍历的算法思想："></a>3.1 树的宽度优先遍历的算法思想：</h3><p>树的宽度优先遍历，既按层级从上层到下层依次遍历，比如说从第一个点开始，1号点可以拓展到它周围的所有邻点，每次只向下拓展一次，每次拓展的数都属于同一层级。</p><h3 id="3-2-代码模板："><a href="#3-2-代码模板：" class="headerlink" title="3.2 代码模板："></a>3.2 代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次queue&lt;int&gt; q;st[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过q.push(1);while (q.size())&#123;    int t &#x3D; q.front();    q.pop();    for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])    &#123;        int j &#x3D; e[i];        if (!st[j])        &#123;            st[j] &#x3D; true; &#x2F;&#x2F; 表示点j已经被遍历过            q.push(j);        &#125;    &#125;&#125;int bfs()&#123;    int hh &#x3D; 0, tt &#x3D; 0;    q[0] &#x3D; 1;&#x2F;&#x2F;q[0]为1号点，此题强制q[0]为1        memset(d, -1, sizeof d);        d[1] &#x3D; 0;&#x2F;&#x2F;表示1号点到1号点的距离为0        while(hh &lt;&#x3D; tt)    &#123;        int t &#x3D; q[hh ++ ];&#x2F;&#x2F;去除队头                for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];&#x2F;&#x2F;用j记录当前的点            if(d[j] &#x3D;&#x3D; -1)&#x2F;&#x2F;如果该点没有被扩展过            &#123;                d[j] &#x3D; d[t] + 1;                q[ ++ tt] &#x3D; j;            &#125;        &#125;    &#125;        return d[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/2023/05/15/BFS/"/>
      <url>/2023/05/15/BFS/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS—宽度优先搜索"><a href="#BFS—宽度优先搜索" class="headerlink" title="BFS—宽度优先搜索"></a>BFS—宽度优先搜索</h1><blockquote><p> 💡 <strong>BFS</strong>是一个对连通图进行遍历的算法。它的思想是从一个被选定的点出发；然后从这个点依次向所有方向每散发，每次直走一步。（即其中一个方向走完一步之后换下一个方向继续走）；如果得不到目的解，那就返回事先定好的值，如果找到直接返回目的解。 与dfs不同的是，<strong>bfs不是运用的递归，而是运用队列和函数内循环构造的</strong>。</p></blockquote><h2 id="1-BFS算法思想："><a href="#1-BFS算法思想：" class="headerlink" title="1. BFS算法思想："></a>1. BFS算法思想：</h2><blockquote><p>💡 <strong>BFS：queue（队列）</strong>   时间复杂度：$O（2^N）$</p></blockquote><p>BFS既宽度优先搜索，搜索方式为<strong>按层级搜索</strong>，先搜索第一层，再依次搜索下一层（既不管每一层元素有多少，都是按层级从上到下的顺序搜索），如果树或图的<strong>边权为 1</strong> ，可作为<strong>最短路</strong>的方式搜索。BFS是通过<strong>队列实现</strong>的。</p><h2 id="2-BFS算法实现方式："><a href="#2-BFS算法实现方式：" class="headerlink" title="2. BFS算法实现方式："></a>2. BFS算法实现方式：</h2><ul><li>BFS通过队列实现，int g[N][N]，int d[N][N] &#x2F;&#x2F;分别存储图和距离</li><li>q[0] &#x3D;{0, 0} 这里定义的是起点（题目要求从（0,0）起点开始）</li><li>memset (d, -1, sizeof d) ，将d数组至为 -1，表示没有遍历（拓展）过</li><li>int dx[4] &#x3D; {-1, 0, 1, 0} , dy[4] &#x3D; {0, 1, 0, -1};定义上下左右四个方向的扩展</li><li>如果点满足在图中的要求，则可以向不同的方向扩展</li><li>从上到下依次按层级遍历</li></ul><h2 id="3-BFS代码模板："><a href="#3-BFS代码模板：" class="headerlink" title="3. BFS代码模板："></a>3. BFS代码模板：</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; BFS——套路模板queue &lt;-- 初始状态while (queue 非空) &#123; t &lt;-- 取出队头元素   for (拓展 t) &#123;       ver &lt;-- 新节点       if ( 该点未遍历 )  &#123;           在队尾插入 ver       &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; BFS——模板题 AcWing 846. 走迷宫int bfs()&#123;    int hh &#x3D; 0, tt &#x3D; 0;    q[0] &#x3D;&#123;0, 0&#125;;        memset(d, -1, sizeof d);    d[0][0] &#x3D; 0;        int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125; , dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;&#x2F;&#x2F;四个点的坐标分别为上，下，左，右        while(hh &lt;&#x3D; tt)    &#123;        auto t &#x3D; q[hh ++ ];&#x2F;&#x2F;取出队头                for(int i &#x3D; 0; i &lt; 4; i ++)&#x2F;&#x2F;让该点向不同的方向扩展        &#123;            &#x2F;&#x2F;表示能够扩展成功的方向            int x &#x3D; t.first + dx[i], y &#x3D; t.second + dy[i];            if(x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] &#x3D;&#x3D; 0 &amp;&amp; d[x][y] &#x3D;&#x3D; -1)            &#123;                d[x][y] &#x3D; d[t.first][t.second] + 1;                q[ ++ tt] &#x3D; &#123;x, y&#125;;            &#125;        &#125;    &#125;    return d[n - 1][m - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS</title>
      <link href="/2023/05/15/DFS/"/>
      <url>/2023/05/15/DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS——深度优先搜索"><a href="#DFS——深度优先搜索" class="headerlink" title="DFS——深度优先搜索"></a>DFS——深度优先搜索</h1><blockquote><p> 💡 DFS：深度优先搜索算法（Depth-First-Search）是一种用于<strong>遍历</strong>或<strong>搜索树</strong>或<strong>图</strong>的算法.沿着树的<strong>深度遍历</strong>树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将<strong>回溯</strong>到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行<strong>直到所有节点都被访问为止</strong>。</p></blockquote><h2 id="1-DFS算法思想："><a href="#1-DFS算法思想：" class="headerlink" title="1. DFS算法思想："></a>1. DFS算法思想：</h2><blockquote><p> 💡 <strong>DFS：stack（栈）</strong>   时间复杂度：$O（N）$</p></blockquote><p>DFS既深度优先搜索，通过从上到下每一层依次往深处搜索，（顺序为从上到下，从左到右），搜到最低处输出，然后回溯到相应的位置（回溯要恢复原来的数据），然后依稀按照之前的方式搜索。</p><img src="/2023/05/15/DFS/1.gif" class=""><h2 id="2-DFS算法的实现方式："><a href="#2-DFS算法的实现方式：" class="headerlink" title="2. DFS算法的实现方式："></a>2. DFS算法的实现方式：</h2><p><strong>树的深度优先搜索（对树上的每一个节点都要进行搜索一遍）</strong></p><ul><li>首先以数的头结点为第0层，即 U&#x3D; 0（往下依次增加一层）</li><li>依次对从上到下，从左到右的每一条路径上的每一个节点进行搜索，直到搜到底未知</li><li>若搜索到了底部的叶子节点，开始回溯，直到找到他的父节点有其他子节点的点继续往下搜索</li><li>递归上面的方式，依次搜索每一个节点</li></ul><img src="/2023/05/15/DFS/2.png" class=""><h2 id="3-DFS代码模板："><a href="#3-DFS代码模板：" class="headerlink" title="3. DFS代码模板："></a>3. DFS代码模板：</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; DFS—— 模板题 AcWing 842. 排列数字    int n;  &#x2F;&#x2F;n为输入的数字的个数int path[N]; &#x2F;&#x2F;path存储树的值bool st[N];  &#x2F;&#x2F;判断当前的数是否已经被使用，false为未使用，true为已使用void dfs(int u)&#123;    if(u &#x3D;&#x3D; n)&#x2F;&#x2F;如果当前的路已经走到了最后，输出路径上的所有值    &#123;        for(int i &#x3D; 0; i &lt; n; i ++) cout &lt;&lt; path[i] &lt;&lt;&quot; &quot;;        puts(&quot;&quot;);        return ;    &#125;        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++)    &#123;        if(!st[i]) &#x2F;&#x2F;判断当前的数还未使用        &#123;            path[u] &#x3D; i;  &#x2F;&#x2F;给当前的数赋值            st[i] &#x3D; true; &#x2F;&#x2F;标记当前数已被使用            dfs(u + 1);   &#x2F;&#x2F;递归下一个数            st[i] &#x3D; false;&#x2F;&#x2F;回溯，恢复原来的数据        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java编码规范</title>
      <link href="/2023/05/12/java_code_standard/"/>
      <url>/2023/05/12/java_code_standard/</url>
      
        <content type="html"><![CDATA[<h1 id="Java编码规范"><a href="#Java编码规范" class="headerlink" title="Java编码规范"></a>Java编码规范</h1><blockquote><p>💡 俗话说： “没有规矩不成方圆”。 编程工作往往都是一个团队协同进行， 因而一致的编码规范非常有必要， 这样写成的代码便于团队中的其他人员阅读， 也便于编写者自己以后阅读。</p></blockquote><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ol><li>主要的命名方法有一下两种</li></ol><ul><li>匈牙利命名， 一般只是命名变量， 原则是： 变量名 &#x3D; 类型前缀 + 描述， 如bFoo表示布尔类型变量， pFoo表示指针类型变量。 匈牙利命名还是有一定争议的， 在Java编码规范中基本不被采用。</li><li>驼峰命名（Camel-Case） ， 又称“骆驼命名法”， 是指混合使用大小写字母来命名。 驼峰命名又分为小驼峰法和大驼峰法。 小驼峰法就是第一个单词是全部小写， 后面的单词首字母大写， 如myRoomCount； 大驼峰法是第一个单词的首字母也大写， 如ClassRoom。</li></ul><blockquote><p>💡 除了包和常量外， Java编码规范命名方法采用驼峰法， 下面分类说明一下。</p></blockquote><ul><li>包名： 包名是全小写字母， 中间可以由点分隔开。 作为命名空间， 包名应该具有唯一性， 推荐采用公司或组织域名的倒置， 如com.apple.quicktime.v2。 但Java核心库包名不采用域名的倒置命名， 如java.awt.event。</li><li>类和接口名： 采用大驼峰法， 如SplitViewController。</li><li>文件名： 采用大驼峰法， 如BlockOperation.java。</li><li>变量： 采用小驼峰法， 如studentNumber。</li><li>常量名： 全大写， 如果是由多个单词构成， 可以用下划线隔开， 如YEAR和WEEK_OF_MONTH。</li><li>方法名： 采用小驼峰法， 如balanceAccount、 isButtonPressed等。</li></ul><h2 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.a51work6;public class Date extends java.util.Date &#123;private static final int DEFAULT_CAPACITY &#x3D; 10;private int size;public static Date valueOf(String s) &#123;final int YEAR_LENGTH &#x3D; 4;final int MONTH_LENGTH &#x3D; 2;int firstDash;int secondDash;...&#125; public String toString () &#123;int year &#x3D; super.getYear() + 1900;int month &#x3D; super.getMonth() + 1;int day &#x3D; super.getDate();...&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><blockquote><p>💡 Java中注释的语法有三种： 单行注释（&#x2F;&#x2F;） 、 多行注释（&#x2F;<em>…</em>&#x2F;） 和文档注释（&#x2F;**…*&#x2F;） </p></blockquote><blockquote><p>💡 代码注释一般是采用单行注释（&#x2F;&#x2F;） 和多行注释（&#x2F;<em>…</em>&#x2F;）</p></blockquote><p><strong>文件注释</strong></p><p>文件注释就是在每一个文件开头添加注释。文件注释通常包括如下信息:版权信息、文件名、所在模块、作者信息、历史版本信息、文件内容和作用等。</p><p>下面看一个文件注释的示例:</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">/**许可信息查看LICENSE.txt文件*描述:*实现日期基本功能*历史版本:*2015-7-22:创建文档*2015-8-20:添加socket库*2015-8-22:添加math库*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述注释只是提供了版权信息、文件内容和历史版本信息等，文件注释要根据本身的实际情况包括内容。</p><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><blockquote><p>💡 文档注释就是指这种注释内容能够生成API帮助文档， JDK中javadoc命令能够提取这些注释信息并生成HTML文件。 文档注释主要对类（或接口） 、 实例变量、 静态变量、 实例方法和静态方法等进行注释。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.a51work6;&#x2F;*** 自定义的日期类， 具有日期基本功能， 继承java.util.Date* &lt;p&gt;实现日期对象和字符串之间的转换&lt;&#x2F;p&gt;* @author 关东升*&#x2F;public class Date extends java.util.Date &#123;private static final int DEFAULT_CAPACITY &#x3D; 10;&#x2F;*** 容量*&#x2F;public int size;&#x2F;*** 将字符串转换为Date日期对象* @param s 要转换的字符串* @return Date日期对象*&#x2F;public static Date valueOf(String s) &#123;final int YEAR_LENGTH &#x3D; 4;final int MONTH_LENGTH &#x3D; 2;int firstDash;int secondDash;...&#125; &#x2F;*** 将日期转换为yyyy-mm-dd格式的字符串* @return yyyy-mm-dd格式的字符串*&#x2F;public String toString () &#123;int year &#x3D; super.getYear() + 1900;int month &#x3D; super.getMonth() + 1;int day &#x3D; super.getDate();...&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文档注释标签"><a href="#文档注释标签" class="headerlink" title="文档注释标签"></a>文档注释标签</h3><blockquote><p>💡 如果你想生成API帮助文档， 可以使用javadoc指令， 如图5-1所示， 在命令行中输入javadoc -d apidocData.java指令， -d参数指明要生成文档的目录， apidoc是当前目录下面的apidoc目录， 如果不存在javadoc会创建一个apidoc目录； Data.java是当前目录下的Java源文件。</p></blockquote><h3 id="地标注释"><a href="#地标注释" class="headerlink" title="地标注释"></a>地标注释</h3><blockquote><p>💡 Eclipse等IDE工具都为Java源代码提供了一些特殊的注释， 就是在代码中加一些标识， 便于IDE工具快速定位代码， 称为“地标注释”。 这种注释虽然不是Java官方所提供的， 但是主流语言和主流的IDE工具也都支持“地标注释”。</p></blockquote><h3 id="Eclipse工具支持如下三种地标注释："><a href="#Eclipse工具支持如下三种地标注释：" class="headerlink" title="Eclipse工具支持如下三种地标注释："></a>Eclipse工具支持如下三种地标注释：</h3><ul><li>TODO： 说明此处有待处理的任务， 或代码没有编写完成。</li><li>FIXME： 说明此处代码是错误的， 需要修正。</li><li>XXX： 说明此处代码虽然实现了功能， 但是实现的方法有待商榷， 希望将来能改进。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础语法</title>
      <link href="/2023/05/12/java_grammer/"/>
      <url>/2023/05/12/java_grammer/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h1><h2 id="1-标识符，关键字和保留字"><a href="#1-标识符，关键字和保留字" class="headerlink" title="1. 标识符，关键字和保留字"></a>1. 标识符，关键字和保留字</h2><h3 id="1-1-标识符"><a href="#1-1-标识符" class="headerlink" title="1.1 标识符"></a>1.1 标识符</h3><p>标识符就是变量、常量、方法、枚举、类、接口等由程序员指定的名字。构成标识符的字母均有一定的规范，Java语言中标识符的命名规则如下：</p><ul><li>区分大小写：Myname与myname是两个不同的标识符。</li><li>首字符，可以是下划线（_）或美元符或字母，但不能是数字。</li><li>除首字符外其他字符，可以是下划线（_）、美元符、字母和数字。</li><li>关键字不能作为标识符。</li><li></li></ul><h3 id="1-2-java关键字"><a href="#1-2-java关键字" class="headerlink" title="1.2 java关键字"></a>1.2 java关键字</h3><blockquote><p>Java中的关键字全部是小写字母</p></blockquote><img src="/2023/05/12/java_grammer/1.jpg" class=""><h3 id="1-3-保留字"><a href="#1-3-保留字" class="headerlink" title="1.3 保留字"></a>1.3 保留字</h3><p>Java中有一些字符序列既不能当作标识符使用，也不是关键字，也不能在程序中使用，这些字符序列称为保留字。Java语言中的保留字只有两个goto和const：</p><ul><li><p>goto：在其他语言中叫做“无限跳转”语句，在Java语言中不再使用goto语句，因为“无限跳转”语句会破坏程序结构。在Java语言中goto的替换语句可以通过break、continue和return实现“有限跳转”。</p></li><li><p>const：在其他语言中是声明常量关键字，在Java语言中声明常量使用public static final 方式声明。</p></li></ul><blockquote><p>java分隔符：用”;”表示一条语句的结束</p></blockquote><h2 id="2-常量，变量"><a href="#2-常量，变量" class="headerlink" title="2. 常量，变量"></a>2. 常量，变量</h2><h3 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h3><blockquote><p>💡 final 数据类型 变量名 &#x3D; 初始值;</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld &#123;  &#x2F;&#x2F; 静态常量，替代保留字const  public static final double PI &#x3D; 3.14; ①  &#x2F;&#x2F; 声明成员常量  final int y &#x3D; 10; ②  public static void main(String[] args) &#123;  &#x2F;&#x2F; 声明局部常量  final double x &#x3D; 3.3; ③  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常量有三种类型：①静态常量、②成员常量和③局部常量</strong></p><h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><blockquote><p>💡 数据类型  变量名 &#x3D; [初始值]</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld &#123;&#x2F;&#x2F; 声明int型成员变量int y; ①public static void main(String[] args) &#123;&#x2F;&#x2F; 声明int型局部变量int x; ②&#x2F;&#x2F; 声明float型变量并赋值float f &#x3D; 4.5f; ③&#x2F;&#x2F; x &#x3D; 10;System.out.println(&quot;x &#x3D; &quot; + x);&#x2F;&#x2F; 编译错误，局部变量 x未初始化 ④System.out.println(&quot;f &#x3D; &quot; + f);if (f &lt; 10) &#123;&#x2F;&#x2F; 声明型局部变量int m &#x3D; 5; ⑤&#125;System.out.println(m); &#x2F;&#x2F; 编译错误 ⑥&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第①行是声明的成员变量y，成员变量是在类体中，而在方法之外，作用域是整个类，如果没有初始赋值，系统会为它分配一个默认值，每一种数据类型都有默认值，int类型默认值是0。</li><li>第②和③行声明局部变量作用域是整个方法</li><li>第⑤行声明的m变量作用域是当前的if语句。</li><li>第④行和第⑥行会有编译错误方法，因为没有初始化，局部变量使用前是需要进行初始化的</li></ul><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><blockquote><p>💡 Java语言的数据类型分为： 基本类型和引用类型。在声明变量或常量时会用到数据类型， 在前面已经用到一些数据类型， 例如int、 double和String等。</p></blockquote><h3 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h3><img src="/2023/05/12/java_grammer/10.png" class=""><p><em><strong>基本类型表示简单的数据， 基本类型分为4大类， 共8种数据类型。</strong></em></p><ul><li>整数类型： byte、 short、 int和long</li><li>浮点类型： float和double</li><li>字符类型： char</li><li>布尔类型： boolean</li></ul><img src="/2023/05/12/java_grammer/2.png" class="" title="数据类型之间的转换关系"><h4 id="3-1-1-整形类型"><a href="#3-1-1-整形类型" class="headerlink" title="3.1.1 整形类型"></a>3.1.1 整形类型</h4><blockquote><p>💡如图可见Java中整数类型包括： byte、 short、 int和long ， 它们之间的区别仅仅是宽度和范围的不同。 Java中整数都是有符号， 与C不同没有无符号的整数类型。</p></blockquote><img src="/2023/05/12/java_grammer/3.png" class=""><blockquote><p>💡 long类型需要在数值后面加L, double类型加D, float类型加F</p></blockquote><p><strong>代码如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld &#123;  public static void main(String[] args) &#123;    &#x2F;&#x2F; 声明整数变量    &#x2F;&#x2F; 输出一个默认整数常量    System.out.println(&quot;默认整数常量 &#x3D; &quot; + 16); &#x2F;&#x2F;此处16默认为整数类型    byte a &#x3D; 16;     short b &#x3D; 16;     int c &#x3D; 16;     &#x2F;&#x2F;long类型后面加l或L，l容易混淆，建议加L    long d &#x3D; 16L;     long e &#x3D; 16l;     System.out.println(&quot;byte整数 &#x3D; &quot; + a);    System.out.println(&quot;short整数 &#x3D; &quot; + b);    System.out.println(&quot;int整数 &#x3D; &quot; + c);    System.out.println(&quot;long整数 &#x3D; &quot; + d);    System.out.println(&quot;long整数 &#x3D; &quot; + e);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-2-浮点类型"><a href="#3-1-2-浮点类型" class="headerlink" title="3.1.2 浮点类型"></a>3.1.2 浮点类型</h4><blockquote><p>💡浮点类型主要用来储存小数数值， 也可以用来储存范围较大的整数。 它分为浮点数（float） 和双精度浮点数（double） 两种， 双精度浮点数所使用的内存空间比浮点数多， 可表示的数值范围与精确度也比较大</p></blockquote><table><thead><tr><th>浮点类型</th><th align="center">宽度</th></tr></thead><tbody><tr><td>float</td><td align="center">4字节（32位）</td></tr><tr><td>double</td><td align="center">8字节（64位）</td></tr></tbody></table><ul><li>Java语言浮点类型默认是double类型， 例如0.0表示double类型常量， 而不是float类型。 如果想要表示float类型， 则需要在数值后面加f或F</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HelloWorld &#123;public static void main(String[] args) &#123;&#x2F;&#x2F; 声明浮点数&#x2F;&#x2F; 输出一个默认浮点常量System.out.println(&quot;默认浮点常量 &#x3D; &quot; + 360.66); float myMoney &#x3D; 360.66f; double yourMoney &#x3D; 360.66; final double PI &#x3D; 3.14159d; System.out.println(&quot;float整数 &#x3D; &quot; + myMoney);System.out.println(&quot;double整数 &#x3D; &quot; + yourMoney);System.out.println(&quot;PI &#x3D; &quot; + PI);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-3-字符类型"><a href="#3-1-3-字符类型" class="headerlink" title="3.1.3 字符类型"></a>3.1.3 字符类型</h4><blockquote><p>💡字符类型表示单个字符， Java中char声明字符类型， Java中的字符常量必须用单引号括起来的单个字符 ，如char c &#x3D; ‘A’;</p></blockquote><img src="/2023/05/12/java_grammer/4.png" class="" title="转义字符"><h4 id="3-1-4-布尔类型"><a href="#3-1-4-布尔类型" class="headerlink" title="3.1.4 布尔类型"></a>3.1.4 布尔类型</h4><blockquote><p>💡在Java语言中声明布尔类型的关键字是boolean， 它只有两个值： true和false。不能与int等数值类型之间进行数学计算或类型转化。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;唯一正确的两种赋值方式boolean isMan &#x3D; true;boolean isWoman &#x3D; false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-数字的表示方法"><a href="#3-2-数字的表示方法" class="headerlink" title="3.2 数字的表示方法"></a>3.2 数字的表示方法</h3><h4 id="3-2-1-进制数字的表示"><a href="#3-2-1-进制数字的表示" class="headerlink" title="3.2.1 进制数字的表示"></a>3.2.1 进制数字的表示</h4><p>如果为一个整数变量赋值， 使用二进制数、 八进制数和十六进制数表示， 它们的表示方式分别如下：</p><ul><li>二进制数： 以 0b 或0B为前缀， 注意0是阿拉伯数字， 不要误认为是英文字母o。</li><li>八进制数： 以0为前缀， 注意0是阿拉伯数字。</li><li>十六进制数： 以 0x 或0X为前缀， 注意0是阿拉伯数字。<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;int型28的不同表示方法int decimalInt &#x3D; 28;&#x2F;&#x2F;二进制int binaryInt1 &#x3D; 0b11100;int binaryInt2 &#x3D; 0B11100;&#x2F;&#x2F;八进制int octalInt &#x3D; 034;&#x2F;&#x2F;十六进制int hexadecimalInt1 &#x3D; 0x1C;int hexadecimalInt2 &#x3D; 0X1C;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="3-2-2-指数表示"><a href="#3-2-2-指数表示" class="headerlink" title="3.2.2 指数表示"></a>3.2.2 指数表示</h4><blockquote><p>💡如果采用十进制表示指数， 需要使用大写或小写的e表示幂， e2表示102。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;表示为3.36×10^2double myMoney &#x3D; 3.36e2;&#x2F;&#x2F;表示为1.56×10^(-2)double interestRate &#x3D; 1.56e-2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-3-数值类型的转换"><a href="#3-3-3-数值类型的转换" class="headerlink" title="3.3.3 数值类型的转换"></a>3.3.3 数值类型的转换</h4><p><strong>自动转换类型</strong>：</p><p>自动类型转换就是需要类型之间转换是自动的，不需要采取其他手段，总的原则是小范围数据类型可以自动转换为大范围数据类型，列类型转换顺序如图所示，从左到右是自动。</p><img src="/2023/05/12/java_grammer/5.jpg" class=""><p><strong>计算过程中自动类型转换规则</strong></p><img src="/2023/05/12/java_grammer/6.jpg" class=""><p><strong>代码如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 声明整数变量byte byteNum &#x3D; 16;short shortNum &#x3D; 16;int intNum &#x3D; 16;long longNum &#x3D; 16L;&#x2F;&#x2F; byte类型转换为int类型intNum &#x3D; byteNum;&#x2F;&#x2F; 声明char变量char charNum &#x3D; &#39;花&#39;;&#x2F;&#x2F; char类型转换为int类型intNum &#x3D; charNum;&#x2F;&#x2F; 声明浮点变量&#x2F;&#x2F; long类型转换为float类型float floatNum &#x3D; longNum;&#x2F;&#x2F; float类型转换为double类型double doubleNum &#x3D; floatNum;&#x2F;&#x2F;表达式计算后类型是doubledouble result &#x3D; floatNum * intNum + doubleNum &#x2F; shortNum;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-强制类型转换"><a href="#3-3-强制类型转换" class="headerlink" title="3.3 强制类型转换"></a>3.3 强制类型转换</h3><p><em><strong>强制类型转换是在变量或常量之前加上“(目标类型)”实现， 示例代码如下：</strong></em></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;int型变量int i &#x3D; 10;&#x2F;&#x2F;把int变量i强制转换为bytebyte b &#x3D; (byte) i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;int型变量int i &#x3D; 10;&#x2F;&#x2F;把int变量i强制转换为bytebyte b &#x3D; (byte) i;int i2 &#x3D; (int)i; ①int i3 &#x3D; (int)b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>引用数据类型（包含： 类、 接口和数组声明的数据类型）</strong></p><img src="/2023/05/12/java_grammer/7.png" class=""><blockquote><p>💡Java中的引用数据类型， 相当于C等语言中指针（pointer） 类型， 引用事实上就是指针， 是指向一个对象的内存地址。 引用数据类型变量中保持的是指向对象的内存地址。 很多资料上提到Java不支持指针， 事实上是不支持指针计算， 而指针类型还是保留了下来， 只是在Java中称为引用数据类型。</p></blockquote><p><strong>引用数据类型实例如下</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int x &#x3D; 7;①int y &#x3D; x;②String str1 &#x3D; &quot;Hello&quot;;③String str2 &#x3D; str1;④str2 &#x3D; &quot;World&quot;;⑤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码声明了两个基本数据类型(int）和两个引用数据类型(String)。当程序执行完第②行代码后，x值为7，x赋值给y，这时y的值也是7，它们的保持方式如图6-4所示，x和y两个变量值都是7，但是它们之间是独立的，任何一个变化都不会影响另一个。</p><p>当程序执行完第③行时，字符串“Hello”对象被创建，保持到内存地址0x12345678中，str1是引用类型变量，它保存的是内存地址Ox12345678，这个地址指向”Hello”对象。</p><p>当程序执行完第④行时，str1变量内容（Ox12345678）被赋值给str2是引用类型变量，这样一来str1和str2保存了相同的内存地址，都指向”Hello”对象。见图6-4所示，此时str1和str2本质上是引用一个对象，通过任何一个引用都可以修改对象本身。</p><p>当程序执行完第⑤行时，字符串“World”对象被创建，保持到内存地址0x23455678中，地址保存到str2变量中，此时，str1和str2不再指向相同内存地址，见图6-5所示。</p><h2 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h2><h3 id="4-1-算数运算符"><a href="#4-1-算数运算符" class="headerlink" title="4.1 算数运算符"></a>4.1 算数运算符</h3><blockquote><p>Java中的算术运算符主要用来组织数值类型数据的算术运算， 按照参加运算的操作数的不同可以分为一元运算符和二元运算符。</p></blockquote><p><strong>一元运算符</strong></p><img src="/2023/05/12/java_grammer/11.png" class=""><p><em><strong>i ++ 和 ++ i的区别：</strong></em></p><ul><li>i ++ 是先赋值再自加</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int i &#x3D; 1;System.out.println( i ++) &#x2F;&#x2F;  i &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>++ i 是先自加再赋值</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int i &#x3D; 1;System.out.println( ++ i) &#x2F;&#x2F;  i &#x3D; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>二级运算符</strong></p><img src="/2023/05/12/java_grammer/12.png" class=""><h3 id="4-2-关系运算符"><a href="#4-2-关系运算符" class="headerlink" title="4.2 关系运算符"></a>4.2 关系运算符</h3><blockquote><p>关系运算是比较两个表达式大小关系的运算， 它的结果是布尔类型数据， 即true或false。 关系运算符有6种： &#x3D;&#x3D;、 !&#x3D;、 &gt;、 &lt;、 &gt;&#x3D;和&lt;&#x3D;</p></blockquote><img src="/2023/05/12/java_grammer/13.png" class=""><h3 id="4-3-逻辑运算符"><a href="#4-3-逻辑运算符" class="headerlink" title="4.3 逻辑运算符"></a>4.3 逻辑运算符</h3><blockquote><p>💡 逻辑运算符是对布尔型变量进行运算， 其结果也是布尔型</p></blockquote><img src="/2023/05/12/java_grammer/14.png" class=""><h3 id="4-4-位运算符"><a href="#4-4-位运算符" class="headerlink" title="4.4 位运算符"></a>4.4 位运算符</h3><blockquote><p>位运算是以二进位（bit） 为单位进行运算的， 操作数和结果都是整型数据。 位运算符有如下几个运算符： &amp;、 |、 ^、 ~、 &gt;&gt;、 &lt;&lt;和&gt;&gt;&gt;， 以及相应的赋值运算符</p></blockquote><img src="/2023/05/12/java_grammer/15.png" class=""><p><em><strong>注意 无符号右移&gt;&gt;&gt;运算符仅被允许用在int和long整数类型, 如果用于short或byte数据, 则数据在位移之前， 转换为int类型后再进行位移计算。</strong></em></p><p><strong>代码演示：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">byte a &#x3D; 0B00110010; &#x2F;&#x2F;十进制50 ①byte b &#x3D; 0B01011110; &#x2F;&#x2F;十进制94 ②System.out.println(&quot;a | b &#x3D; &quot; + (a | b)); &#x2F;&#x2F; 0B01111110 ③System.out.println(&quot;a &amp; b &#x3D; &quot; + (a &amp; b)); &#x2F;&#x2F; 0B00010010 ④System.out.println(&quot;a ^ b &#x3D; &quot; + (a ^ b)); &#x2F;&#x2F; 0B01101100 ⑤System.out.println(&quot;~b &#x3D; &quot; + (~b)); &#x2F;&#x2F; 0B10100001 ⑥System.out.println(&quot;a &gt;&gt; 2 &#x3D; &quot; + (a &gt;&gt; 2)); &#x2F;&#x2F; 0B00001100 ⑦System.out.println(&quot;a &gt;&gt; 1 &#x3D; &quot; + (a &gt;&gt; 1)); &#x2F;&#x2F; 0B00011001 ⑧System.out.println(&quot;a &gt;&gt;&gt; 2 &#x3D; &quot; + (a &gt;&gt;&gt; 2)); &#x2F;&#x2F; 0B00001100 ⑨System.out.println(&quot;a &lt;&lt; 2 &#x3D; &quot; + (a &lt;&lt; 2)); &#x2F;&#x2F; 0B11001000 ⑩System.out.println(&quot;a &lt;&lt; 1 &#x3D; &quot; + (a &lt;&lt; 1)); &#x2F;&#x2F; 0B01100100 ⑪int c &#x3D; -12; ⑫System.out.println(&quot;c &gt;&gt;&gt; 2 &#x3D; &quot; + (c &gt;&gt;&gt; 2)); ⑬System.out.println(&quot;c &gt;&gt; 2 &#x3D; &quot; + (c &gt;&gt; 2)); ⑭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出结果：</strong></p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">a | b = 126a &amp; b = 18a ^ b = 108~b = -95a >> 2 = 12a >> 1 = 25a >>> 2 = 12a &lt;&lt; 2 = 200a &lt;&lt; 1 = 100c >>> 2 = 1073741821c >> 2 = -3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>上述代码第①行和第②行分别定义了byte变量a和b， 为了便于查看代码采用二进制整数表示。</li><li>代码第③行中表达式(a | b)进行位或运算， 结果是二进制的0B01111110。 a和b按位进行或计算， 只要有</li><li>一个为1， 这一位就为1， 否则为0。代码第④行(a &amp; b)是进行位与运算， 结果是二进制的0B00010010。 a和b按位进行与计算， 只有两位全</li><li>部为1， 这一位才为1， 否则为0。代码第⑤行(a ^ b)是进行位异或运算， 结果是二进制的0B01101100。 a和b按位进行异或计算， 只有两</li><li>位相反时这一位才为1， 否则为0。代码第⑦行(a &gt;&gt; 2)是进行有符号右位移2位运算， 结果是二进制的0B00001100。 a的低位被移除掉， 由</li><li>于是正数符号位是0， 高位空位用0补。 类似代码第⑧行(a &gt;&gt; 1)是进行右位移1位运算， 结果是二进制的0B00011001。</li><li>代码第⑨行(a &gt;&gt;&gt; 2)是进行无符号右位移2位运算， 与代码第⑦行不同的是， 无论是否有数符号位， 高位空位用0补， 所以在正数情况下&gt;&gt;和&gt;&gt;&gt;运算结果是一样的。</li><li>代码第⑩行(a &lt;&lt; 2)是进行左位移2位运算， 结果是二进制的0B11001000。 a的高位被移除掉， 低位用0补位。 类似代码第⑪行(a &lt;&lt; 1)是进行左位移1位运算， 结果是二进制的0B01100100。</li><li>代码第⑫声明int类型负数。 右位移（&gt;&gt;&gt;和&gt;&gt;） 在负数情况下差别比较大。 代码第⑬行的(c &gt;&gt;&gt; 2)表达式输出结果是1073741821， 这是一个如此大的正数， 从一个负数变成一个正数， 这说明无符号右位移对于负数计算会导致精度的丢失。 而有符号右位移对于负数的计算是正确的， 见代码第⑭行。</li></ul><blockquote><p>提示 有符号右移n位， 相当于操作数除以2n， 例如代码第⑦行(a &gt;&gt; 2)表达式相当于(a &#x2F; 22)， a &#x3D;50所以结果等于12， 类似的还有代码第⑧行和第⑭行。 另外， 左位移n位， 相当于操作数乘以2n，例如代码第⑩行(a &lt;&lt; 2)表达式相当于(a * 22)， a &#x3D; 50所以结果等于200， 类似的还有代码第⑪行。</p></blockquote><h3 id="4-5-三元运算符"><a href="#4-5-三元运算符" class="headerlink" title="4.5 三元运算符"></a>4.5 三元运算符</h3><blockquote><p>三元运算符（ a ?  b : c ) –&gt; 表示 a表达式是否成立，成立的话执行b语句，否则执行c语句</p></blockquote><p><strong>示例代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Date;public class HelloWorld &#123;public static void main(String[] args) &#123;int score &#x3D; 80;String result &#x3D; score &gt; 60 ? &quot;及格&quot; : &quot;不及格&quot;; &#x2F;&#x2F; 三元运算符（? : ）System.out.println(result);Date date &#x3D; new Date(); &#x2F;&#x2F; new运算符可以创建Date对象System.out.println(date.toString()); &#x2F;&#x2F;通过.运算符调用方法&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-运算符优先级"><a href="#4-6-运算符优先级" class="headerlink" title="4.6 运算符优先级"></a>4.6 运算符优先级</h3><blockquote><p>运算符优先级</p></blockquote><img src="/2023/05/12/java_grammer/3.jpg" class=""><blockquote><p>总结 运算符优先级大体顺序， 从高到低是： 算术运算符→位运算符→关系运算符→逻辑运算符→赋值运算符。</p></blockquote><h2 id="5-控制语句"><a href="#5-控制语句" class="headerlink" title="5. 控制语句"></a>5. 控制语句</h2><h3 id="5-1-while循环"><a href="#5-1-while循环" class="headerlink" title="5.1 while循环"></a>5.1 while循环</h3><h3 id="5-2-for循环"><a href="#5-2-for循环" class="headerlink" title="5.2 for循环"></a>5.2 for循环</h3><h3 id="5-3-循环的嵌套"><a href="#5-3-循环的嵌套" class="headerlink" title="5.3 循环的嵌套"></a>5.3 循环的嵌套</h3><h3 id="5-4-跳出循环"><a href="#5-4-跳出循环" class="headerlink" title="5.4 跳出循环"></a>5.4 跳出循环</h3><h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6.数组"></a>6.数组</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/2023/05/12/binary-search/"/>
      <url>/2023/05/12/binary-search/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="1-整数二分"><a href="#1-整数二分" class="headerlink" title="1.整数二分"></a>1.整数二分</h2><blockquote><p>💡 时间复杂度：$logN$</p></blockquote><h3 id="a-快速排序算法实现方式"><a href="#a-快速排序算法实现方式" class="headerlink" title="(a)快速排序算法实现方式:"></a>(a)快速排序算法实现方式:</h3><p><strong>有单调性一定可以二分，可以二分不一定有单调性</strong></p><p>二分查找是通过将一个有序序列划分为两个区间，通过不断的缩小区间的大小在不同的区间寻找答案的一种方式，相比与顺序查找效率高了很多，缺点是二分之前要对数据进行排序，耗时。</p><p>二分查找要求：<strong>线性表是有序表</strong>，即表中<strong>结点按关键字有序，并且要用向量作为表的存储结构</strong> 。<em><strong>二分我们需要确定一个区间，使得目标在一定的区间中。</strong></em></p><p><strong>二分满足的性质：</strong></p><ul><li>具有二段性（一段满足，另一段不满足）</li><li>答案是二分的<strong>分界点</strong></li></ul><p><strong>整数二分分为两种情况：</strong></p><img src="/2023/05/12/binary-search/1.png" class=""><img src="/2023/05/12/binary-search/2.png" class=""><h3 id="b-算法描述"><a href="#b-算法描述" class="headerlink" title="(b)算法描述:"></a>(b)算法描述:</h3><ul><li><p>首先确定该区间的中点位置</p></li><li><p>将待查的X值与q[mid]比较：若相等，则查找成功并返回此位置，否则须确定新的查找区间，继续二分查找</p></li><li><p>① 若q[mid] &gt; X，将查找区间变为[ L ,  mid - 1 ]</p><p>②若q[mid] &lt; X，将查找区间变为[ mid + 1 , R ]</p></li><li><p>假设目标值在 [ L ，R ]中，每次查找区间将缩小一半，当 L &#x3D; R 时，我们就找到了目标。</p></li></ul><h3 id="c-整数二分查找代码模板："><a href="#c-整数二分查找代码模板：" class="headerlink" title="(c)整数二分查找代码模板："></a>(c)整数二分查找代码模板：</h3><p><strong>版本一：</strong><br>当我们将区间[l, r]划分为[l, mid]和[mid + 1, r]时，其更新操作是r &#x3D; mid 或 l &#x3D; mid + 1,计算mid时不需要加1。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool check( int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123;while (l &lt; r)&#123;int mid &#x3D; l + r &gt;&gt; 1;if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质else l &#x3D; mid + 1;&#125;return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>版本二：</strong><br>当我们将区间[l, r]划分为[l, mid - 1]和[mid, r]时，其更新操作是l &#x3D; mid - 1或 l &#x3D; mid,计算mid时需要加1。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool check( int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123;while (l &lt; r)&#123;int mid &#x3D; l + r &gt;&gt; 1;if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质else l &#x3D; mid + 1;&#125;return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-浮点数二分"><a href="#2-浮点数二分" class="headerlink" title="2. 浮点数二分"></a>2. 浮点数二分</h2><h3 id="a-浮点数二分查找代码模板："><a href="#a-浮点数二分查找代码模板：" class="headerlink" title="(a)浮点数二分查找代码模板："></a>(a)浮点数二分查找代码模板：</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质double bsearch_3(double l, double r)&#123;const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求while (r - l &gt; eps)&#123;double mid &#x3D; (l + r) &#x2F; 2;if (check(mid)) r &#x3D; mid;else l &#x3D; mid;&#125;return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
